<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[YouCompleteMe配置与我的vimrc备份]]></title>
    <url>%2F2018%2F02%2F14%2Fycm-vim-cfg%2F</url>
    <content type="text"><![CDATA[作为一个C++爱好者同时也是vi爱好者，我个人觉得vi就是写代码工具不是IDE所以只用少数几个插件，其中YouCompleteMe是我极力推荐的插件，YouCompleteMe主要是自动补全，还有跳转，类型显示等功能，与之前的基于规则补全插件不同的是YouCompleteMe是基于语义，从安装过程就可以看出来。 我用vundle安装和管理插件，YCM的官方安装文档也是推荐vundle，但是我配置好vimrc之后用执行vundle的PlugInstall时发现速度巨慢，其实这个过程本质就是在.vim/bundle中执行git clone https://github.com/Valloric/YouCompleteMe.git，之后可以在YouCompleteMe目录中执行git submodule update –init –recursive。 后面的安装步骤非常简单， cd ~/.vim/bundle/YouCompleteMe./install.py –clang-completer 我的环境是ubuntu-64bit，详细参考官方文档。需要注意的是YCM会默认往上级目录查找直到HOME目录去查找一个.ycm_extra_conf.py的文件（可以自己配置），在.vimrc中我指定了使用官方默认的，配置如下， 1let g:ycm_global_ycm_extra_conf='/home/macduan/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py' 在具体的项目中，在项目的根目录中放一个.ycm_extra_conf.py，并且加上头文件目录的配置，比如，12345678910111213141516171819202122232425flags = ['-Wall','-Wextra','-Werror','-Wno-long-long','-Wno-variadic-macros','-fexceptions','-DNDEBUG',...'-I','/home/macduan/work/opensource/brpc/src','-I','/home/macduan/work/opensource/brpc/src/brpc','-I','/home/macduan/work/opensource/brpc/src/bthread','-I','/home/macduan/work/opensource/brpc/src/butil','-I','/home/macduan/work/opensource/brpc/src/bvar','-I','/home/macduan/work/opensource/brpc/src/json2pb','-I','/home/macduan/work/opensource/brpc/src/mcpack2pb'] 附上我的.vimrc 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" =&gt; Vundle"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""set nocompatible " be iMproved, requiredfiletype off " required" set the runtime path to include Vundle and initializeset rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()" alternatively, pass a path where Vundle should install plugins"call vundle#begin('~/some/path/here')" let Vundle manage Vundle, requiredPlugin 'VundleVim/Vundle.vim'" The following are examples of different formats supported." Keep Plugin commands between vundle#begin/end." plugin on GitHub repoPlugin 'tpope/vim-fugitive'" PowerlinePlugin 'Lokaltog/vim-powerline'" plugin from http://vim-scripts.org/vim/scripts.html" Plugin 'L9'" Git plugin not hosted on GitHubPlugin 'git://git.wincent.com/command-t.git'" Powerline" Plugin 'powerline/powerline'Plugin 'vim-airline/vim-airline'Plugin 'vim-airline/vim-airline-themes'Plugin 'scrooloose/nerdtree'" color schemePlugin 'sickill/vim-monokai'Plugin 'junegunn/seoul256.vim'Plugin 'tomasr/molokai'"Cpp hightPlugin 'octol/vim-cpp-enhanced-highlight'" DoxygenPlugin 'vim-scripts/DoxygenToolkit.vim'" TaglistPlugin 'vim-scripts/taglist.vim'" YouCompleteMePlugin 'Valloric/YouCompleteMe' "git clone it from github is rather quicker than this" git repos on your local machine (i.e. when working on your own plugin)" Plugin 'file:///home/gmarik/path/to/plugin'" Install L9 and avoid a Naming conflict if you've already installed a" different version somewhere else." Plugin 'ascenator/L9', &#123;'name': 'newL9'&#125;" All of your Plugins must be added before the following linecall vundle#end() " requiredfiletype plugin indent on " required" To ignore plugin indent changes, instead use:"filetype plugin on"" Brief help" :PluginList - lists configured plugins" :PluginInstall - installs plugins; append `!` to update or just :PluginUpdate" :PluginSearch foo - searches for foo; append `!` to refresh local cache" :PluginClean - confirms removal of unused plugins; append `!` to auto-approve removal"" see :h vundle for more details or wiki for FAQ" Put your non-Plugin stuff after this line"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" Basic Configuration"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""set history=500 " Sets how many lines of history VIM has to remembersyntax on " Enable filetype plugins" Colorcolumnset cc=100hi Search guibg=peru guifg=wheat" Set to auto read when a file is changed from the outsideset autoread" With a map leader it's possible to do extra key combinations" like &lt;leader&gt;w saves the current filelet mapleader = ","let g:mapleader = ","" Smart way to move between windowsmap &lt;C-j&gt; &lt;C-W&gt;jmap &lt;C-k&gt; &lt;C-W&gt;kmap &lt;C-h&gt; &lt;C-W&gt;hmap &lt;C-l&gt; &lt;C-W&gt;l" color schemesyntax enable" colorscheme monokai" colo seoul256" let g:seoul256_srgb = 1colorscheme molokai" let g:rehash256 = 1let g:molokai_original = 1 " use original monokai" these part refer http://harttle.land/2013/11/08/vim-config.htmlset tabstop=4 " Number of spaces that a &lt;Tab&gt; in the file counts for. set shiftwidth=4 " Number of spaces to use for each step of (auto)indent. set expandtab " Use the appropriate number of spaces to insert a &lt;Tab&gt;. " Spaces are used in indents with the '&gt;' and '&lt;' commands " and when 'autoindent' is on. To insert a real tab when " 'expandtab' is on, use CTRL-V &lt;Tab&gt;.set softtabstop=4 set smarttab " When on, a &lt;Tab&gt; in front of a line inserts blanks " according to 'shiftwidth'. 'tabstop' is used in other " places. A &lt;BS&gt; will delete a 'shiftwidth' worth of space " at the start of the line. set showcmd " Show (partial) command in status line.set number " Show line numbers.set showmatch " When a bracket is inserted, briefly jump to the matching " one. The jump is only done if the match can be seen on the " screen. The time to show the match can be set with " 'matchtime'. set hlsearch " When there is a previous search pattern, highlight all " its matches. set incsearch " While typing a search command, show immediately where the " so far typed pattern matches. set ignorecase " Ignore case in search patterns. set smartcase " Override the 'ignorecase' option if the search pattern " contains upper case characters. set backspace=2 " Influences the working of &lt;BS&gt;, &lt;Del&gt;, CTRL-W " and CTRL-U in Insert mode. This is a list of items, " separated by commas. Each item allows a way to backspace " over something. set autoindent " Copy indent from current line when starting a new line " (typing &lt;CR&gt; in Insert mode or when using the "o" or "O" " command). set textwidth=100 " Maximum width of text that is being inserted. A longer " line will be broken after white space to get this width. set formatoptions=c,q,r,t " This is a sequence of letters which describes how " automatic formatting is to be done. " " letter meaning when present in 'formatoptions' " ------ --------------------------------------- " c Auto-wrap comments using textwidth, inserting " the current comment leader automatically. " q Allow formatting of comments with "gq". " r Automatically insert the current comment leader " after hitting &lt;Enter&gt; in Insert mode. " t Auto-wrap text using textwidth (does not apply " to comments) set ruler " Show the line and column number of the cursor position, " separated by a comma. set background=dark " When set to "dark", Vim will try to use colors that look " good on a dark background. When set to "light", Vim will " try to use colors that look good on a light background. " Any other value is illegal. set mouse=a " Enable the use of the mouse. filetype plugin indent onsyntax on""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" " vim-airline/vim-airline""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" "" These lines setup the environment to show graphics and colors correctly.set nocompatibleset t_Co=256" Always show the status lineset laststatus=2" Format the status line" set statusline=%F%m%r%h\ %w\ \ CWD:\ %r%&#123;getcwd()&#125;%h\ \ \ Line:\ %l\ \ Column:\ %clet g:airline#extensions#tabline#enabled = 1" let g:airline#extensions#tabline#left_sep = ' '" let g:airline#extensions#tabline#left_alt_sep = '&gt;'let g:cpp_class_scope_highlight = 1let g:cpp_member_variable_highlight = 1let g:cpp_class_decl_highlight = 1" NERDTreemap &lt;C-n&gt; :NERDTreeToggle&lt;CR&gt;"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" doxygen" Dox DoxAuthor DoxLic DoxUndoc"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""let g:DoxygenToolkit_briefTag_pre="@brief"let g:DoxygenToolkit_paramTag_pre="@Param "let g:DoxygenToolkit_returnTag="@Returns "let g:DoxygenToolkit_authorName="duanmeng@outlook.com"let g:DoxygenToolkit_licenseTag="@License I don't care"let g:DoxygenToolkit_commentType = "C++"let g:ycm_global_ycm_extra_conf='/home/macduan/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py'let g:ycm_collect_identifiers_from_tag_files=1let g:ycm_seed_identifiers_with_syntax=1let g:ycm_confirm_extra_conf=0let g:ycm_key_invoke_completion='&lt;C-/&gt;'let g:ycm_goto_buffer_command='new-or-existing-tab' "open new tabe when jump to definitionlet g:ycm_autoclose_preview_window_after_completion=1 " auto-close preview window after select a completion stringlet g:ycm_autoclose_preview_window_after_insertion=1 " close preview window after leaving insert modennoremap &lt;leader&gt;jd :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt;nnoremap &lt;leader&gt;jdf :YcmCompleter GoToDefinition&lt;CR&gt;nnoremap &lt;leader&gt;jdc :YcmCompleter GoToDeclaration&lt;CR&gt;nnoremap &lt;leader&gt;st :YcmCompleter GetType&lt;CR&gt;nnoremap &lt;F5&gt; :YcmForceCompileAndDiagnostics&lt;CR&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Epoll的一些事情]]></title>
    <url>%2F2017%2F12%2F24%2Fepoll-notes%2F</url>
    <content type="text"><![CDATA[Epoll出现使得Linux平台上C10K迎刃而解。这里不说epoll的使用，man/google一下即可，只关注三个微小的方面:线程安全，触发机制以及客户端断开。 Epoll线程安全吗？这个网上居然搜到的资料不多，有个简短的说法（from gejun）, epoll_wait和epoll_ctl都是线程安全的, 前者带acquire语意, 后者带release语意, 换句话说, 如果epoll_wait后能拿到某个新fd的事件, 那么对应的epoll_ctl前发生的内存修改都可见. 其实从源码eventpoll.c的注释上一看就一目了然（主要是懒不想看源码）,详细请看注释和源码，epoll有3层锁，从上到下的顺序如下： epmutex(mutex) eventpoll_release_file()和ep_free()需要一个全局锁 ep-&gt;mtx(mutex) event loop中从内核空间拷贝数据到用户空间需要一个允许休眠的锁 ep-&gt;lock(spinlock) 从IRQ context调用的wake_up()需要操作poll callback中的对象，而在poll callback中不能休眠，所以用spinlock 边沿触发和水平触发区别和应用场景， 水平触发，只要fd可读/写（缓冲区不空/不满），就一直触发。 边沿触发，只有fd可读/写状态发送变化（翻转），才会触发。 再次引用gejun的观点： 在eventloop类型(包括各类fiber/coroutine)的程序中， 处理逻辑和epoll_wait都在一个线程， ET相比LT没有太大的差别。 反而由于LT醒的更频繁， 可能时效性更好些。 在老式的多线程RPC实现中， 消息的读取分割和epoll_wait在同一个线程中运行， 类似上面的原因， ET和LT的区别不大。但在更高并发的RPC实现中， 为了对大消息的反序列化也可以并行， 消息的读取和分割可能运行和epoll_wait不同的线程中，这时ET是必须的，否则在读完数据前，epoll_wait会不停地无谓醒来。 客户端断开某服务端的fd与客户端的连接断开会使得该fd状态变成可读，但是在read的时候会返回0即EOF，这时可以close并且将该fd从epoll events中移除(EPOLL_CTL_DEL)。]]></content>
      <tags>
        <tag>multithreading</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Cheat Sheet (keep updating ...)]]></title>
    <url>%2F2017%2F12%2F16%2FC-Notes%2F</url>
    <content type="text"><![CDATA[有一阵子没有关注C++了，随着年纪增长记忆力下降，感觉需要一个小抄记录些C++的知识可以随时查阅，碰到什么值得记录知识点就记录在这里，时不时更新下这个文档。 1 Lvalues &amp; Rvalues lvalue和rvalue继承自C语言，在C语言中是这样定义的：能在赋值操作左边的是lvalue而rvalue不能 但是在C++中则lvalue和rvalue的区别则复杂很多，大致说来就是一个对象被用作右值时，用的是对象的值（内容），一个对象被用作左值时，用的是对象的标识（内存中的位置） 对于运算符（赋值，取址等操作）来说，不同之处是运算符需要lvalue还是rvalue，返回的是lvalue还是rvalue；重要的一点就是可以在需要rvalue的地方使用lvalue）在需要lvalue的地方则不能使用rvalue（比如std::move） 赋值操作需要lvalue在赋值运算符左边（右边都可以），且产出的是一个左值 取址操作需要lvalue，且返回的是一个rvalue的指针， 解引用，下标操作（vector、 string等的[]运算符）和迭代器解引用使用lvalue和rvalue都可以，且都返回的是lvalue 迭代器自增减需要lvalue，且返回lvalue 参考： C++ Primer 5th Edition 4.1.1 P135 2 Named CastNamed cast背后的思想就是让程序员显示的表达转型（cast）的意愿1。 2.1 static_caststatic_cast可用于C风格的转型（int to double， double to int， char to int等），const类型到non-const类型的转换，相同层级类指针之间的转型，子类指针向基类指针转型，基类指针向子类指针转型（不安全，必须确认指向的对象是子类对象）。 2.2 const_castconst_cast用于去除const特性。 2.3 reinterpret_castreinterpret_cast用于不安全的指针之间转型和int到指针转型，必须清楚其带来的后果。 2.4 dynamic_castdynamic_cast用于运行时具有继承关系的类之间（子类到基类，基类到子类，兄弟类之间）的指针和引用的安全转型，如果失败指针转型返回空，引用转型抛出bad_cast异常。但是G和B家的C++编程规范都是禁止使用dynamic_cast；除非在UT代码中，比如测试工厂模式类创建的对象类型，或者管理对象与它们的mock之间的关系。为什么要禁止呢，主要是容易出错，会造成判断分支过多不易维护，可以用其它机制比如多态来代替。这里贴出G家编程规范对其缺点描述的原文： Cons Querying the type of an object at run-time frequently means a design problem. Needing to know the type of an object at runtime is often an indication that the design of your class hierarchy is flawed. Undisciplined use of RTTI makes code hard to maintain. It can lead to type-based decision trees or switch statements scattered throughout the code, all of which must be examined when making further changes. Decision RTTI has legitimate uses but is prone to abuse, so you must be careful when using it. You may use it freely in unittests, but avoid it when possible in other code. In particular, think twice before using RTTI in new code. If you find yourself needing to write code that behaves differently based on the class of an object, consider one of the following alternatives to querying the type: Virtual methods are the preferred way of executing different code paths depending on a specific subclass type. This puts the work within the object itself. If the work belongs outside the object and instead in some processing code, consider a double-dispatch solution, such as the Visitor design pattern. This allows a facility outside the object itself to determine the type of class using the built-in type system. 参考1 TC++PL 11.5.2. Named Casts2 https://google.github.io/styleguide/cppguide.html#Run-Time_Type_Information__RTTI_3 https://google.github.io/styleguide/cppguide.html#Casting 3 -pthread &amp; -lpthread -lpthread就是链接选项，告知编译器链接pthread库。 -pthread告诉编译器链接pthread库，同时告知编译器预处理时设置_REENTRANT宏，使得libc的头文件选择thread-safe的实现。 下面示例代码1很好的展示了区别 1234567$gcc -pthread -E -dM test.c &gt; dm.pthread.txt$gcc -E -dM test.c &gt; dm.nopthread.txt$diff dm.pthread.txt dm.nopthread.txt 152d151&lt; #define _REENTRANT 1208d206&lt; #define __USE_REENTRANT 1 为什么diff结果为什么有两个宏被设置了呢2 Defining _REENTRANT causes the compiler to use thread safe (i.e. re-entrant) versions of several functions in the C library. It simply defined _REENTRANT for the preprocessor. Somewhere in the associated code, you’ll probably find #ifdef _REENTRANT or #if defined(_REENTRANT) in at least a few places. Also note that the name “_REENTRANT: is in the implementer’s name space (any name starting with an underscore followed by another underscore or a capital letter is), so defining it means you’ve stepped outside what the standard defines (at least the C or C++ standards). 参考链接 1 https://stackoverflow.com/questions/23250863/difference-between-pthread-and-lpthread-while-compiling2 https://stackoverflow.com/questions/2601753/what-is-the-reentrant-flag 4 一个String类展示四种constructor12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstring&gt; // strlen, strcpy#include &lt;utility&gt; // move#include &lt;iostream&gt; // coutclass String final &#123;public: String() : _data(new char[1]) &#123; std::cout &lt;&lt; "Default Constructor\n"; &#125; explicit String(const char* src) : _data(new char[std::strlen(src) + 1]) &#123; std::cout &lt;&lt; "char* constructor\n"; std::strcpy(_data, src); &#125; ~String() &#123; delete []_data; &#125; String(const String&amp; rhs) : _data(new char[rhs.size() + 1]) &#123; std::cout &lt;&lt; "copy constructor\n"; std::strcpy(_data, rhs._data); &#125; String&amp; operator=(const String&amp; rhs) &#123; // copy &amp; swap idiom std::cout &lt;&lt; "assign constructor\n"; String tmp(rhs); std::swap(_data, tmp._data); return *this; &#125; String(String&amp;&amp; rhs) : _data(rhs._data) &#123; std::cout &lt;&lt; "move copy constructor\n"; rhs._data = nullptr; &#125; String&amp; operator=(String&amp;&amp; rhs) &#123; std::cout &lt;&lt; "move assign constructor\n"; std::swap(_data, rhs._data); return *this; &#125; size_t size() const &#123; return std::strlen(_data); &#125;private: char* _data;&#125;;int main(int, char**) &#123; String defaultConstructor; String charPointerConstructor("hello"); String copyConstructor1(charPointerConstructor); String copyConstructor2 = charPointerConstructor; defaultConstructor = copyConstructor1; // copy then assign constructor std::cout &lt;&lt; copyConstructor1.size() &lt;&lt; std::endl; String moveCopyConstructor(std::move(copyConstructor1)); moveCopyConstructor = String("hello"); // char pointer constructor then move assign constructor moveCopyConstructor = std::move(copyConstructor2); // move assign std::cout &lt;&lt; copyConstructor1.size() &lt;&lt; std::endl; return 0;&#125; $./a.outDefault Constructorchar constructorcopy constructorcopy constructorassign constructorcopy constructor5move copy constructorchar constructormove assign constructormove assign constructorSegmentation fault (core dumped)]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GFS总结 (未完待续)]]></title>
    <url>%2F2017%2F12%2F07%2Fgfs-notes%2F</url>
    <content type="text"><![CDATA[本文是阅读完google经典的论文The Google File System后的总结。 Environment 组件故障是常态，持续监控、错误侦测、容错和自动恢复是系统必须的， 文件通常是巨大的，IO操作和块大小需要被重新审视， 大部分是append新数据，随机写非常少， 提供类似文件系统API，放松了一致性模型。 Assumptions 系统是构建在很多廉价的机器上的， 系统存储的大多数是大文件， 读负载主要两种，大型流式读和小型随机读， 写负载主要是大型顺序追加写， 多个客户端并发读写， 高可持续带宽比某一次读写操作的低延时更重要。 InterfaceGFS提供和POSIX类似的接口（create, delete, open, close, read and write），也支持快照和并发追加操作。 Architecture 一个GFS集群是由一个master和多个chunkservers组成，它们可以被多个客户端访问， 文件被分成多个固定大型的chunk，每个chunk由一个64bit的全局唯一的chunk handle标识， Chunkservers以linux files的形式在本地磁盘存储在本地磁盘，默认是3备份， master维护metadata，租约管理，垃圾回收和chunk迁移，周期性的与chunkservers通过心跳消息收集状态， Chunk Size一般一个Chunk Size为64MB。 Single Master GFS采用Single Master简化了设计，可以利用全局信息进行复杂的chunk placement和副本决策， 客户端通过master获取chunkservers信息，直接与chunkservers读写数据，这样single master不会成为瓶颈， 客户端把文件名和偏移量翻译成chunk index，向master发送包含文件名和chunk index的请求， master回复chunk handle和副本位置，客户端会缓存这些信息一段时间， 客户端向一个副本发送包含chunk handle和byte range的请求， 接下来客户端就直接与副本交互，直到缓存信息过期或者重新打开文件， 客户端会一次向master请求多个chunk信息，master也会主动把可能要访问的其它chunk信息一并返回，降低master负载。 Metadata master存储三种主要的metadata： 文件名，chunk namespace， 文件名到chunks的映射， 每个chunk副本的位置。 前两种会被持久化到operation log，master恢复时会读取这个log， 第三种只在内存中，master在启动和新的chunkservers加入时，master去请求位置信息。 In-Memory Data StructuresMetadata]]></content>
      <tags>
        <tag>distributed</tag>
        <tag>google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式原理与工程 —— Quorum机制]]></title>
    <url>%2F2017%2F12%2F03%2FQuorum%2F</url>
    <content type="text"><![CDATA[Quorum机制是一种分布式系统中常用的，用来保证数据冗余和最终一致性的投票算法 其主要数学思想来源于鸽巢原理1。 Quorum机制定义我们普遍使用副本(Replication)技术来保证一致的性能和高可用性2，Quorum是一种简单有效的管理副本的机制，我们先建立如下定以（[2]中也有描述）： N = 存储数据副本的节点的数量W = 更新成功所需的副本更新成功的数量R = 一次数据对象读取要访问的副本的数量 更新时，只有至少W副本更新成功时才算更新操作成功；读取时，至少要读取R个副本的数据。这样当$W + R &gt; N$时，对于同一个数据对象，更新集合与读取集合一定有重叠，保证了读取的数据中一定有最近更新的值。 WARO (Write All Read One)WARO是Quorum机制的特例（GFS使用WARO），也就是更新时必须所有的副本都更新成功，而读取 时只需要读取一个副本的数据就可以。 Quorum机制与一致性Quorum本身无法保证强一致性，除非有一个获取最新成功提交的版本号的metadata服务；假设$N = 5, W = 3, R = 3$，数据V2提交成功但是只在三个副本真正更新了，副本中数据分布是[V2, V2, V2, V1, V1]，那么客户端可能读到[V2, V2, V1]，也可能读到[V2, V1, V1]；注意这里的版本V1，V2是数据本身的版本号不是最新成功提交的版本号，所以无法确认是V1还是V2；如果要保证强一致性必须继续读取副本，来确定最新至少写入的W个副本也就是提交成功的数据。 参考链接 https://zh.wikipedia.org/wiki/Quorum_(分布式系统) https://duanmeng.github.io/2017/11/19/Eventually-Consistent%20-%20Revisited/]]></content>
      <tags>
        <tag>distributed</tag>
        <tag>system design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[deeplearning.ai系列学习笔记]]></title>
    <url>%2F2017%2F11%2F26%2Fcoursera-ng-deeplearning-notes%2F</url>
    <content type="text"><![CDATA[吴恩达(Andrew Ng)离开老东家之后创立了一个创业公司叫deeplearing.ai，并且在Coursera（Ng也是cofounder）上开设一个5门课程组成deeplearning系列，我学习了前两门（完成了作业和实验拿到了证书，算是上班远坐地铁时间长的福利吧），难能可贵的是Ng考虑到国内的情况在网易云课堂上免费提供了该系列课程的学习视频和资料，所以我可以在笔记中引用课程资料，但是不会上传作业答案与实验代码。 1. Neural Networks and Deep Learning1.1 week01什么是神经网络以房价预测为例（Ng很喜欢这个例子）给出了一个非常简单的Neural Network，如下图所示，有输入层，隐藏层和输出层（输入层不算做NN的层数之中），输入层是简单的特征，隐藏层则是输入层简单特征组合成的更复杂的特征，那些圆圈是“激励”（activator）一般是ReLU）和Sigmoid这一类函数。 深度学习为什么兴起大数据驱动了深度学习的兴起（当然少不了Hinton大神的卓越贡献)，如下图可以看到随着数据量的增大，深度学习/神经网络与传统机器学习的效果差距越来越大。之前团队培训时一个策略高工说过业务 &gt; 数据 &gt; 模型，离开具体业务场景和数据支撑空谈模型是没有意义的。 该课程的术语与表示因为本系列课程都是用Python，为了优化会矩阵化，矩阵形状对比是一个很实用且重要的调试手段之一，比如输入X的形状是(nx, m)，m是训练用例的数量，nx则是输入特征的数量。 1.2 week02Logistic Regression （逻辑回归）LR虽然叫逻辑回归，但它实际是解决分类问题；它是一个线性回归在一个激励（ReLU, Sigmoid等）上的输出，本周以Sigmoid为例，其实就是神经网络图中的一个圆圈，用数学公式描述如下， Model: $a = \sigma(W^TX + b)$ where $\sigma(Z) = \frac{1}{1 + e^{-z}}$Train: $\lbrace(x^{(1), y^{(1)}}), … (x^{(i), y^{(i)}}) … , (x^{(m), y^{(m)}})\rbrace$ where $a^{(i)} \approx y^{(i)}$ Logistic Regression Cost Function度量Cost时很常见的一种方法就是square error（$\frac{(a - y)^2}{2}$），但是如果采用它会使得LR的cost function非凸，无法找到全局最优解（估计是sigmoid的特性造成的，数学原理我就不去深究了）；所以采用cross-entropy: $L(a, y) = -(ylog(a) + (1 - y)log(1 - a))$对此一个Ng给出了个感性的解释：由于$0 &lt; a, y &lt; 1$，当$y = 1$时$L(a, y) = -log(a)$，那么a无限接近1时L(a, y)最小；当$y = 0$时$L(a, y) = -log(1 - a)$，那么a无限接近0时$L(a, y)$最小。选择cross-entropy后cost function如下：$J(W, b) = \frac{1}{m}\sum^{m}_{i = 1}{L(a, y)^2}$ Gradient Descent （梯度下降）梯度下降是通过反复迭代找到使J最小的parameters（W和b），其中迭代次数和learning rate（$\alpha$）属于hyper parameters（后面会讲到）， $W := W - \alpha\frac{\nabla{J}}{\nabla{W}}$$d := d - \alpha\frac{\nabla{J}}{\nabla{b}}$ forward propagation与post propagation从梯度下降的公式可以看出迭代过程中需要知道$\frac{\nabla{J}}{\nabla{W}}$，这就是通过fp与pp推到出来的，以下面的LR过程为例： forward propagation:$[x_1, w_1, x_2, w_2, b]$ -&gt; $[z = w_1x_1 + w_2x_2 + b]$ -&gt; $[a = sigmoid(z)]$ -&gt; $[L(a, y)]$ 以推导dw1为例演示post propagation, 其中d(xx)代表$\frac{\nabla{J}}{\nabla{(xx)}}$: $[a = sigmoid(z)]$ &lt;- $[L(a, y)]$ =&gt; $da = \frac{\nabla{L}}{\nabla{a}} = -\frac{y}{a} + \frac{1 - y}{1 - a}$ $[z = w_1x_1 + w_2x_2 + b]$ &lt;- $[a = sigmoid(z)]$ =&gt; $dz = \frac{\nabla{L(a, y)}}{\nabla{z}} = \frac{\nabla{L}}{\nabla{a}}\frac{\nabla{a}}{\nabla{z}} = da\frac{\nabla{a}}{\nabla{z}} = a - y$ $[x_1, w_1, x_2, w_2, b]$ &lt;- $[z = w_1x_1 + w_2x_2 + b]$ =&gt; $dw_{1} = \frac{\nabla{L}}{\nabla{w_1}} = \frac{\nabla{L}}{\nabla{z}}\frac{\nabla{z}}{\nabla{w_1}} = x_1dz$ 这样$dw_1$就推导出来了，同理$dw_2 = x_2dz$，$db = dz$。 汇总用上面几节的结论以及python的向量化（主要是解决m个训练样本时避免for循环）汇总一个训练W，b的伪代码， 12345678for i in xrange(iterNum): Z = W.T * X + b A = sigmoid(Z) dZ = A - y dw = 1 / m * X * dZ.T db = 1 / m * sum(dZ) W = W - alpha * dW b = b - alpha * db]]></content>
      <tags>
        <tag>coursera</tag>
        <tag>deep learning</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++11 Memory Model]]></title>
    <url>%2F2017%2F11%2F24%2FC-11-Memory-Model%2F</url>
    <content type="text"><![CDATA[Herb Sutter在一次对C++11内存模型的演讲中提到C++11的内存模型，让C++有了标准独立于编译器和平台线程库和标准的多线程内存控制方式。 咋一看这个句话很奇怪，难道C++98/03及以前的内存模型不支持多线程吗， 用C++03的标准不照样写多线程程序。 其实我忽略了一个事实在B家同学们都是gcc &amp; linux，潜意识posix标准的pthread就是C++的线程库存，其实还有cl &amp; windows:) C++标准是基于一个抽象的机器制定的（大部分语言标准应该也是这样），它没有具体的CPU或编译器。 C++98/03标准没有对每次读写（loads and stores)以及执行顺序作出规定，所以无法写出完全可移植的多线程代码（能同时支持freebsd，linux和windows就很不错了）。C++11标准则在设计上引入了支持多线程的内存模型，它规定了在多线程环境中内存的读写的操作以及可能的执行顺序1。 在cppreference.com上可以看到load和store的原型如下, 12T load( std::memory_order order = std::memory_order_seq_cst ) const noexcept;void store( T desired, std::memory_order order = std::memory_order_seq_cst ) noexcept; 对于memory order多线程环境中（CPU也是乱序执行的）的几种规定如下下表， Value Explanation memory_order_relaxed 对其它读写操作没有同步，只保证本操作是原子的 memory_order_consume load操作，当前线程依赖该原子变量的访存操作不能reorder到该指令之前，对其他线程store操作(release)可见 memory_order_acquire load操作，当前线程所有访存操作不能reorder到该指令之前，对其他线程store操作(release)可见 memory_order_release store操作，当前线程所有访存操作不能reorder到该指令之后，对其他线程load操作(consume)可见 memory_order_acq_rel load/store操作，memory_order_acquire + memory_order_release memory_order_seq_cst memory_order_acq_rel + 顺序一致性(sequential consisten) 关于memory_order_seq_cst与memory_order_acq_rel，下面这段代码很直观的体现了， 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;thread&gt;#include &lt;atomic&gt;#include &lt;cassert&gt; std::atomic&lt;bool&gt; x = &#123;false&#125;;std::atomic&lt;bool&gt; y = &#123;false&#125;;std::atomic&lt;int&gt; z = &#123;0&#125;; void write_x()&#123; x.store(true, std::memory_order_seq_cst);&#125; void write_y()&#123; y.store(true, std::memory_order_seq_cst);&#125; void read_x_then_y()&#123; while (!x.load(std::memory_order_seq_cst)) ; if (y.load(std::memory_order_seq_cst)) &#123; ++z; &#125;&#125; void read_y_then_x()&#123; while (!y.load(std::memory_order_seq_cst)) ; if (x.load(std::memory_order_seq_cst)) &#123; ++z; &#125;&#125; int main()&#123; std::thread a(write_x); std::thread b(write_y); std::thread c(read_x_then_y); std::thread d(read_y_then_x); a.join(); b.join(); c.join(); d.join(); assert(z.load() != 0); // will never happen&#125; 知乎上有个G家的stephen w很认真的翻阅了经典计算机体系结构：量化研究方法给了不错的总结2, “SC要求所有内存操作表现为(appear)逐个执行（任一次的执行结果都像是所有处理器的操作都以某种次序执行），每个处理器中的操作都以其程序指定的次序执行。SC有两点要求：在每个处理器内，维护每个处理器的程序次序；在所有处理器间，维护单一的表征所有操作的次序。对于写操作W1, W2, 不能出现从处理器 P1 看来，执行次序为 W1-&gt;W2; 从处理器 P2 看来，执行次序却为 W2-&gt;W1 这种情况。 参考链接 https://stackoverflow.com/questions/6319146/c11-introduced-a-standardized-memory-model-what-does-it-mean-and-how-is-it-g https://www.zhihu.com/question/24301047/answer/83422523]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译]最终一致性 - 修订版(Eventually Consistent - Revisited)]]></title>
    <url>%2F2017%2F11%2F19%2FEventually-Consistent%20-%20Revisited%2F</url>
    <content type="text"><![CDATA[译者注：这是AWS CTO Werner Vogels写的一致性模型的经典文章在其博客All Things Distributed上亦有发布。 大约一年前，我发表了关于一致性模型文章的第一个版本，但是我对它一直不是很满意，因为它写的很匆忙，而且这个太重要值得更充分的研究。 ACM Queue让我修订一下发表在他们的杂志上，我利用这个机会改进了这篇文章。这篇是那篇的修订版。 最终一致性 - 在全球范围构建可靠的分布式系统需要在一致性和支撑Amazon云计算的基础服务，例如Amazon的S3(Simple Storage Service)，SimpleDB和EC2(Elastic Compute Cloud)提供构建互联网规模计算平台和各种应用所需的资源。放在这些基础服务的需求非常严格；它们需要在安全性、 可伸缩性、 可用性、 性能和成本效率方面都非常优秀，同时为全球数以百万计的客户持续提供服务。 这些服务底层是全球范围运行的大规模分布式系统。这样的规模带来了额外的挑战，因为当一个系统处理海量请求时，那些低概率事件就会变成必然事件，并且需要在系统设计和架构中预先列出。考虑到这些全球范围的系统，我们普遍使用副本(Replication)技术来保证一致的性能和高可用性。 虽然副本技术让我们更接近目标，但是它不能以完全透明的方式实现它们；在一些条件下，这些服务的用户将会面临使用副本技术带来的后果。 这些方面的表现方式之一就是提供的数据一致性类型，特别当底层的分布式系统为数据副本提供一种最终一致性模型。当在Amazon设计这些大规模系统时，我们用一组与大规模数据副本(data replication)相关的指导原则和抽象，并集中在高可用性与数据一致性的权衡上。 这篇文章我介绍了一些相关背景展示了我们交付需要在全球范围运行的可靠的分布式系统的方法。这篇文章的早期版本于2017年12月发表在网络博客All Things Distributed，并且在读者的帮助下改进了很多。 历史观点在理想世界中，只会有一种一致性模型：当更新完成，所有的观察者都会看到。 70年代末期，在数据系统中第一次发现这个模型难以实现。关于这个主题最好的历史文献是Bruce Lindsay等人的分布式数据库注释 5。 它阐述了数据库副本的基本原则，并讨论了一些找实现一致性的技术。 这些技术中许多试图实现分布式透明，就是对用户来说它似乎只在使用一个系统而不是多个协作系统。这段时期许多系统采用这种方法，即使让整个系统失效也不破坏透明性 2。 在90年代中期，随着大型互联网的兴起，这些方法被重新审视。 当时人们开始意识到对于这些系统而言可用性是最重要的属性，但是他们也在纠结牺牲什么来保证可用性。 Eric Brewer，加州伯克利的系统学教授，Inktomi的头，在2001年的PODC(Principles of Distributed Computing)会议的主题演讲上提出了一并提出了不同的取舍方案 1。 他演示CAP理论，指出共享数据系统的三大属性即数据一致性，系统可用性和网络分区容忍性，在任何时刻只能同时保证两个。 Seth Gilbert和Nancy Lynch在他们2002年的一篇论文 4中给出了正式确认。 不能容忍网络分区的系统可以同时实现数据一致性和可用性，这个通常是通过事务协议来实现。 为了实现这样的系统，客户端和存储系统必须在相同环境中； 他们在某些场景下会整体失效，只有这样客户端才无法感知分区。 一个重要发现是在大型分布式系统中，网络分区无法避免，因此，一致性和可用性无法同时实现。 这意味着有两个放弃的选项： 放宽一致性保证系统的可用性，或者保证一致性接受某些场景下系统不可用。 两个选项都需要客户端开发者清楚系统可以提供什么。 如果强调一致性，开发者需要面对系统可能不可用的现实，例如，一次写操作。 如果这次写操作因为系统不可用，客户端开发者需要处理数据无法写入。 如果系统强调可用性，它可能会一直接受写操作，但是一些条件下读操作无法返回最新写入的数据。 开发者需要决定客户端是否始终访问最新的更新。 有一批应用可以处理稍微陈旧的数据，它们在这个模型下可以很好的提供服务。 原则上事务系统的ACID（原子性，一致性，隔离线，持久性）中的一致性属性是一种不同的一致性保证。 在ACID中，一致性是指事务完成后数据库是处于一种一致状态；例如，一个账户转钱给另一个账户，两个账户总额不应该改变。 在ACID-based系统中，这样的一致性通常是编写事务的开发者的责任，但是可以由数据库管理完整性约束来辅助。 一致性 —— 客户端与服务端有两种视角看待一致性。 一种是开发者/客户端的视角：他们如何观察数据更新。 另一种是服务端视角：更新如何在系统中流通，以及系统能给这些更新的保证。 客户端一致性 客户端有以下部分： 一种存储系统。 我们先把它当作一个黑盒，但是要了解它底层是大规模分布式系统，为保证持久性和可用性而构建。 进程A。 这个进程读写存储系统。 进程B和进程C。 这两个进程独立于进程A且读写存储系统。这与他们是否真是进程或者同一进程中的线程无关；真正重要的是他们相互独立且需要通信共享信息。 客户端一致性需要处理如何和何时观察者们（这个例子中进程A，B或者C）看到数据对象在存储系统中更新。 接下来的例子演示了不同的类型的一致性，流程A对数据对象进行了更新： 强一致性。 更新完成后，任何后续访问（来自A，B或C）将会返回更新的值。 弱一致性。 系统不保证后续访问会得到更新的值。 获取更新值之前需要满足一些条件。 从更新到保证任何观察者将会一直看到更新值的时期被称为不一致窗口。 最终一致性。 这是弱一致性的一种特例； 存储系统保证如果对象没有新的更新，最终所以的访问将会返回最近更新的值。 如果没有失败发生，不一致窗口的大小由通信延迟，系统负载和复制方案的副本数量决定。 最广泛的最终一致性系统是DNS(Nomain Name System)。 一个域名的更新根据配置模式以及时间控制缓存被分布；最终，所以客户端将会看到更新。 最终一致性模型有一些重要的变种需要被考虑到： 因果一致性。 如果进程A通知进程B它更新了一项数据，后续进程B的访存会返回更新的值，并且保证写入将取代之前的写入。与过程A没有因果关系的进程C的访存是遵循一般的最终一致性规则。 读你所写一致性。 这是一种重要的模型，进程A更新一个数据项之后总会得到更新的值永远不会得到旧值。这是因果一致性的一种特例。 会话一致性。 这是上个模型的实践版本，其中是一个进程在一个会话上下文中访问存储系统。 只要这个会话存在，系统保证读你所写一致性。 如果会话因为一些特定场景失效，一个新的会话需要被创建且一致性保证不会跨会话。 单调读一致性。 如果一个进程读取到了一个对象的值，任何后续访问都不会得到之前的值。 单调写一致性。 在这种情况下，系统保证由相同的进程序列化写操作。系统不保证这样的一致性非常难以编程。 以上一致性特性中的一部分可以被组合。例如，单调读一致性可以和会话一致性组合。从实践角度来看，这两个特性（单调读和读你所写）是最终一致性系统中最需要的，但不是一直必须的。这两个特性让开发者更容易构建应用，同时允许存储系统放松一致性且提供高可用性。 从这些变化中可以看出，很多场景是可能的。相应的后果能否被接受取决于特定的应用程序。 最终一致性不是什么极限分布式系统的深奥特性。许多现代关系型数据库管理系统（RDBMSs），提供主备（primary-backup）可靠性，在同步和异步模式实现副本技术。在同步模式副本更新是事务的一部分。在异步模式会延迟到达副本，通常通过日志传输的方式。在异步模式如果主服务在log送达之前宕机，从切换的备份服务读取的将会是旧的，不一致的值。同时，为了支持更好大规模读性能，RDBMSs已经提供从备份服务读取的功能，这是一个经典的保证最终一致性的案例，其不一致性窗口取决于日志传送的周期。 服务端一致性在服务端我们需要更深入地理解更新在系统中执行的流程，从而理解是什么让开发者遇到不同模式。开始前，让我们先建立一些定义： N = 存储数据副本的节点的数量W = 更新成功所需的副本更新成功的数量 （译者注：如果副本更新没有达到这个数量就是更新失败）R = 一次数据对象读取要访问的副本的数量 如果$W + R &gt; N$，那么写集和读集会一直重叠，这样可以保证强一致性。在使用同步副本的主备RDBMSs场景中，$N = 2, W = 2, R = 1$。客户端无论从哪个副本读都会得到一致的结果。在异步模式且可从备份读取的场景中，$N = 2, W = 1, R = 1$，一致性不能被保证。 这些配置方案就是基本的仲裁协议（quorum protocols），当系统以为故障无法写入W个节点时，写操作失败，意味着系统的不可用。例如$N = 3, W = 3$且只有2个节点可用，系统的写操作失败。 在需要提供高性能和高可用性的分布式存储系统中，副本数量基本上要大于2。只关注容错的系统通常用$N = 3$且$W =2, R = 2$的配置。需要提供非常高的读负载的系统通常会使用超过关注容错系统的副本数量；N可以是几十甚至几百，R配置成1，这样读一次副本就可以返回结果。关注一致性的系统通常为更新设置W = N，这样就降低了写成功的可能性。关注容错而不是一致性的系统通常配置是$W = 1$，获取最小更新持久性（译者注：这是什么鬼）并通过惰性（lazy/epidemic，译者注：跟GFS的primary-secondary更新很像）更新机制去更新其他副本。 如何更新$N, W, R$，依赖于常见的操作是什么和哪个性能指标需要被优化。当$R = 1, N = W$时我们优化读操作，当$W = 1, R = N$我们优化快速写操作。当然对于后者持久性在发生异常时不被保证，如果$W &lt; (N + 1) / 2$，冲突写（译者注：比如，不同客户端发起的写操作）的集合可能不会重叠。 弱或最终一致性产生于$W + R &lt;= N$，意味着存在读写集没有重叠的可能性。如果不是刻意的配置或者基于容错用例，几乎没有任何理由设置R为1而不是其它值。这发生在两种场景中：第一个为了前面提到的读操作扩展的大规模副本；第二个是数据获取更复杂。在简单键值模型非常容易通过版本对比来决定最新写入系统的值，但是在返回对象集的系统中非常难决定最新正确的集合应该是哪个。在大多数写集合小于副本集合的系统中，有一种机制就是，用惰性更新的方式更新副本中剩余未更新的节点。所有副本更新之前的时间段被称为前面提到的不一致性窗口。如果$W + R &lt;= N$，那么系统容易从尚未更新的节点读取数据。 读你所写一致性，会话一致性和单调一致性能否实现，大体上依赖于客户端与对它们执行分布式协议服务端的“粘性”。如果每次都是相同的服务器，那么比较容易保证读你所写和单调一致性读。这样会让负载均衡和容错稍微难以管理，但是是一个简单解决方案。用粘性的会话，让这个显示和提供了一个客户端可以推断的暴露级别。（译者注：什么鬼） 有时候在客户端实现了读你所写和单调读。通过为写添加版本，客户端丢弃读取的版本号比上次所见低的数据。 当系统中一些节点与其它节点断开时分区发生了，但是这两批节点可以被一组客户端访问。如果使用经典的多数仲裁方法，那么当其它副本无法访问时，拥有W个节点的副本集依旧可以继续接受更新。读集合亦是如此。考虑到两个集合的重叠，根据定义，少数集合变得不可用。分区不会经常发生，但是他们的确发生在数据中心之间，以及数据中心内部。 在一些应用中任何分区的不可达都是不可接受的，重要的是能够访问该分区的客户端可以取得进展。在这种场景下两个分区都分配一组新的存储节点接收数据，并且在分区恢复后执行合并操作。例如，在亚马逊购物车就是使用这样的永远可写系统；这样即使发生分区，客户可以继续添加商品到购物车，即使原来的购物车位于其它分区。一旦分区恢复购物车应用（译者注：客户端？）会帮助购物车数据合并。 亚马逊的Dynamo亚马逊的Dynamo就是这样一个把所有这些特性显示控制的应用架构的系统，它是一个键值存储系统，跟AWS（Amazon’s Web Service）一样，它在内部被广泛用于构建亚马逊电子商务平台的服务。一个重要的设计目标就是让创建Dynamo存储系统（它通常分布在多个数据中心）实例的应用服务的拥有者能在一致性，持久性，可用性和性能之间在一定代价上作出权衡。3 总结在大规模可靠的分布式系统中，必须容忍数据不一致的原因有两个：在高并发条件下改善读写性能；处理分区场景中大部分模型让系统不可用，即使节点都在运行。 能否接受非一致性取决于客户端应用。在所有场景中，开发者需要意识到一致性保证由存储系统提供，需要在开发应用时考虑到。有许多对最终一致性模型实际的改进，比如会话一致性和单调读，它们提供了更好的工具给开发者。很多时候应用可以很好的处理存储系统的最终一致性。一个流行的用例就是网站，我们可以有用户感知一致性的概念。在这个场景下，不一致性窗口需要小于返回客户加载的下一页所需的时间。这个允许在下次读之前更新可以传播到整个系统。 这篇文章的目的就是引起运行在全球范围的工程系统复杂性的认识，这个系统需要仔细调优来保证它们可以交付应用所需要的持久性，可用性和性能。系统设计者拥有的一个工具之一就是一致性窗口的长度，在这个时间段内系统的客户端可能暴露在大规模工程系统的现实中。 参考文献 Brewer, E. A. 2000. Towards robust distributed systems (abstract). In Proceedings of the 19th Annual ACM Symposium on Principles of Distributed Computing (July 16-19, Portland, Oregon): 7 A Conversation with Bruce Lindsay. 2004. ACM Queue 2(8): 22-33. DeCandia, G., Hastorun, D., Jampani, M., Kakulapati, G., Lakshman, A., Pilchin, A., Sivasubramanian, S., Vosshall, P., Vogels, W. 2007. Dynamo: Amazon’s highly available key-value store. In Proceedings of the 21st ACM Symposium on Operating Systems Principles (Stevenson, Washington, October). Gilbert , S., Lynch, N. 2002. Brewer’s conjecture and the feasibility of consistent, available, partition-tolerant Web services. ACM SIGACT News 33(2). Lindsay, B. G., Selinger, P. G., et al. 1980. Notes on distributed databases. In Distributed Data Bases, ed. I. W. Draffan and F. Poole, 247-284. Cambridge: Cambridge University Press. Also available as IBM Research Report RJ2517, San Jose, California (July 1979).]]></content>
      <tags>
        <tag>distributed</tag>
        <tag>system design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Learning Design and Coding From LevelDB (keep updating ...)]]></title>
    <url>%2F2017%2F11%2F05%2FLearning-Design-and-Coding-From-LevelDB%2F</url>
    <content type="text"><![CDATA[LevelDB is a fast key-value storage library written at Google by Jeff Dean that provides an ordered mapping from string keys to string values. We could learn design and coding from the source code. 概述include/leveldb &amp; utilStatus include/leveldb/status.h util/status.cc Status是对每次操作结果的封装, 它只有一个成员变量char* state_来表示状态信息，它包含三个字段[length, code, message], length表示message的长度，code是返回码，message是状态信息：123456789101112131415161718192021222324252627// OK status has a NULL state_. Otherwise, state_ is a new[] array// of the following form:// state_[0..3] == length of message// state_[4] == code// state_[5..] == messageconst char* state_;enum Code &#123; kOk = 0, kNotFound = 1, kCorruption = 2, kNotSupported = 3, kInvalidArgument = 4, kIOError = 5&#125;;Code code() const &#123; return (state_ == NULL) ? kOk : static_cast&lt;Code&gt;(state_[4]);&#125;const char* Status::CopyState(const char* state) &#123; uint32_t size; memcpy(&amp;size, state, sizeof(size)); char* result = new char[size + 5]; memcpy(result, state, size + 5); return result;&#125; 这个类对字符串的操作非常精妙，比如上述代码通过memcpy获取message长度信息. Slice include/leveldb/slice.h 封装数据和其长度，便于直接通过指针操作, 并提供向std::String的转换.1234567class Slice &#123;...private: const char* data_; size_t size_; ...&#125; Cache include/leveldb/cache.h utils/cache.cc overviewCache一个接口类，提供了有淘汰机制KV的接口，客户代码可以自己定义具体的实现，也可以使用默认的LRUCache,从下面代码中的注释中可以看出设计思路。12345678910111213141516171819202122232425// A Cache is an interface that maps keys to values. It has internal// synchronization and may be safely accessed concurrently from// multiple threads. It may automatically evict entries to make room// for new entries. Values have a specified charge against the cache// capacity. For example, a cache where the values are variable// length strings, may use the length of the string as the charge for// the string.//// A builtin cache implementation with a least-recently-used eviction// policy is provided. Clients may use their own implementations if// they want something more sophisticated (like scan-resistance, a// custom eviction policy, variable cache sizing, etc.)// Create a new cache with a fixed size capacity. This implementation// of Cache uses a least-recently-used eviction policy.extern Cache* NewLRUCache(size_t capacity);class Cache &#123; public: // Opaque handle to an entry stored in the cache. struct Handle &#123; &#125;; virtual Handle* Insert(const Slice&amp; key, void* value, size_t charge, void (*deleter)(const Slice&amp; key, void* value)) = 0; virtual Handle* Lookup(const Slice&amp; key) = 0; ... ... 虽然其接口参数有明确，但是数据类型并没有明确而是留给具体实现代码，所以返回类型是12Handle*struct Handle &#123;&#125;; 这就是一个典型的Opaque data type的应用，wikipedia: opaque pointer, wikipedia: opaque data type, stackoverflow: What is an opaque value? 你会发现在cache.h中有一段extern声明,1extern Cache* NewLRUCache(size_t capacity); 在cache.cc中有它的一种实现,123Cache* NewLRUCache(size_t capacity) &#123; return new ShardedLRUCache(capacity);&#125; 通过extern声明(#include “cache.h”), 在链接的时候(链接cache.o)既可以选择cache.cc的默认实现即ShardedLRUCache, 也可以链接自己的实现。 ShardedLRUCachecache.cc中提供了一个默认的cache实现即ShardedLRUCache, 其组成是LRUCache并基于key进行shard.LRUCache依赖cache.c中的opaque数据抽象的具体实现LRUHandle和自己实现的一个哈希表HashHandle.总而言之ShardedLRUCache就是二级hashtable, 其节点就是多个LRUCache. ShardedLRUCache在bucket分配与key的shard时用一些非常有意思的位操作，代码如下12345678static const int kNumShardBits = 4;static const int kNumShards = 1 &lt;&lt; kNumShardBits;LRUCache shard_[kNumShards];static uint32_t Shard(uint32_t hash) &#123; return hash &gt;&gt; (32 - kNumShardBits);&#125; kNumShards = 2 ^ kNumShardBits 这个左移代替指数计算好理解，但是shard操作hash &gt;&gt; (32 - kNumShardBits)这个值得思考，一般会直接余除，但是这样效果会一样吗或者说会均匀分布在kNumShards个bucket中吗？假设我们考虑4个bit的uint4_t（虽然并没有这样的类型），当kNumShardBits = 1时，bucket数量也就是kNumShards为2,那么 4 - kNumShardBits = 3，每次Shard的时候右移动3个bit，这时会发现只有bit 3的那个bit右移没有消失（在bit 0），也就是说bit 3的那个bit决定了Shard的value(0 / 1)，正好均匀分布在2个bucket上了.同理对于32bit的uint32_t整型数，其bit分布如下 31 … (32 - kNumShardBits), (32 - kNumShardBits - 1) … 0 如果右移32 - kNumShardBits，只有第一部分kNumShardBits个高位的bit有效，那么正好有2 ^ kNumShardBits 种可能的值，均匀分布在index为0 - (2 ^ kNumShardBits - 1)的bucket上.一个简单的Shard对效率都这么苛刻(位操作避免除法)，由此可见作者对性能的要求. LRUCache &amp; LRUHandle &amp; HandleTableLRUCache由两个循环链表和一个HashTable组成（List+Hash的经典实现），一个链表是连接正在被使用的Node，一个链表连接不再被使用的Node，HashTable就是使用链表解决Hash碰撞，所以每个Node（即LURHandle包含三个pointer和一个ref），作者使用了经典的链表操作dummy node和二级指针Linus。Hash值的生成实现请见Hash &amp; Coding哪一章。 Hash &amp; Codingutil/hash.cc util/hash.hutil/coding.cc util/coding.hhash.cc提供了一个默认的类似murmurhash的hash值计算的实现，coding.cc中提供了32/64整型数和Slice/String的转换. env &amp; env_posixutil/env.cc include/leveldb/env.hutil/env_posix.cc envenv中的接口类Env（虚基类）提供了文件操作的抽象，比如目录操作，日志，文件顺序/随机读取，在Option中可以配置Env使用的实现, leveldb提供了默认的posix标准的实现（具体见下一节）.SequentialFile/RandomAccessFile封装了文件顺序/随机Read和Skip，WritableFile封装了文件的Append/Close/Flush/Sync操作，Loger则封装了类似变长参数的logv接口（类似vprintf）. env_posixenv_posix是leveldb对Env接口类提供的默认implementation.Limiter类通过基于RAII的Scope互斥锁和原子操作提供线程安全的计数操作，避免资源过度消耗，比如fd, mmap file数量.PosixSequentialFile是SequentialFile的子类实现了其Read和Seek接口, 本质就是对fread和seek的wrapper.PosixRandomAccessFile是RandomAccessFile的子类, 实际是pread() based random-access, 同时包含了Limiter, 不知道为什么Random Accesss为什么需要Limiter.PosixMmapReadableFile是MmapReadableFile的子类, 实际是mmap() based random-access.]]></content>
      <tags>
        <tag>C++</tag>
        <tag>leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode using C++ and Java (keep updating ...)]]></title>
    <url>%2F2017%2F11%2F04%2FLeetCode%20with%20C%2B%2B%20and%20Java%20and%20little%20scala%2F</url>
    <content type="text"><![CDATA[LeetCode的题目非常是碎片化时间来做，而且可以尝试最新的C++标准和多种语言， 正好要学习Java，就C++和Java两种语言来做题，如果碰到可以用immutable方式的题目就再用Scala做一下。 1. Two Sum Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution, and you may not use the same element twice. Example:Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. Tags: Array, HashTable C++123456789101112131415class Solution &#123; // (both index1 and index2) are not zero-based.public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, size_t&gt; umap; for (size_t i = 0; i &lt; nums.size(); ++i) &#123; auto item = nums[i]; if (umap.find(target - item) == umap.end()) &#123; umap[item] = i; &#125; else &#123; return vector&lt;int&gt;&#123;umap[target - item], i&#125;; &#125; &#125; return vector&lt;int&gt;&#123;-1, -1&#125;; &#125;&#125;; Java1234567891011121314public class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; hm = new HashMap&lt;&gt;(); for (int i = 0; i != nums.length; ++i) &#123; int complement = target - nums[i]; if (hm.get(complement) != null) &#123; return new int[] &#123;hm.get(complement), i&#125;; &#125; else &#123; hm.put(nums[i], i); &#125; &#125; return null; &#125;&#125; Scala1234567891011121314object Solution &#123; def twoSum(nums: Array[Int], target: Int): Array[Int] = &#123; var ht = collection.mutable.Map.empty[Int, Int] for (i &lt;- 0 until nums.size) &#123; val tmp = target - nums(i) if (ht.contains(tmp)) &#123; return Array(ht(tmp), i) &#125; else &#123; ht(nums(i)) = i &#125; &#125; Array(-1, -1) &#125;&#125; 2. Add Two Numbers You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself.Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 Tags: Linked List, Math C++12345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode dummy(-1); ListNode* ptr = &amp;dummy; int carry = 0; while (l1 != nullptr || l2 != nullptr) &#123; int a = 0; if (l1 != nullptr) &#123; a = l1-&gt;val; l1 = l1-&gt;next; &#125; int b = 0; if (l2 != nullptr) &#123; b = l2-&gt;val; l2 = l2-&gt;next; &#125; int sum = a + b + carry; carry = sum / 10; ptr-&gt;next = new ListNode(sum % 10); ptr = ptr-&gt;next; &#125; if (carry &gt; 0) &#123; ptr-&gt;next = new ListNode(carry); &#125; return dummy.next; &#125;&#125;; Java123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; int carrier = 0; ListNode dummy = new ListNode(0); ListNode cur = dummy; while (l1 != null || l2 != null) &#123; int x = l1 == null ? 0 : l1.val; int y = l2 == null ? 0 : l2.val; int val = x + y + carrier; carrier = val / 10; cur.next = new ListNode(val % 10); cur = cur.next; if (l1 != null) &#123; l1 = l1.next; &#125; if (l2 != null) &#123; l2 = l2.next; &#125; &#125; if (carrier &gt; 0) &#123; cur.next = new ListNode(carrier); &#125; return dummy.next; &#125;&#125; Scala123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * class ListNode(var _x: Int = 0) &#123; * var next: ListNode = null * var x: Int = _x * &#125; */object Solution &#123; def addTwoNumbers(l1: ListNode, l2: ListNode): ListNode = &#123; var dummyNode = new ListNode(0) var cur = dummyNode var carry = 0 def addInternal(l1: ListNode, l2: ListNode): Unit = &#123; if (l1 != null || l2 != null) &#123; var a = if (l1 != null) l1.x else 0 var b = if (l2 != null) l2.x else 0 var sum = a + b + carry cur.next = new ListNode(sum % 10) cur = cur.next carry = sum / 10 addInternal(if (l1 != null) l1.next else null, if(l2 != null) l2.next else null) &#125; &#125; addInternal(l1, l2) if (carry &gt; 0) &#123; cur.next = new ListNode(carry) &#125; dummyNode.next &#125;&#125; 3. Longest Substring Without Repeating Characters Given a string, find the length of the longest substring without repeating characters. Examples:Given “abcabcbb”, the answer is “abc”, which the length is 3.Given “bbbbb”, the answer is “b”, with the length of 1.Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring. Tags: Hash Table, Two Pointers, String C++123456789101112131415161718class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int ret = 0; vector&lt;int&gt; ht(256, -1); int i = 0; for (int j = 0; j &lt; s.size(); ++j) &#123; auto k = ht[s[j]]; if (k &gt;= i) &#123; i = k + 1; &#125; else &#123; ret = std::max(ret, j - i + 1); &#125; ht[s[j]] = j; &#125; return ret; &#125;&#125;; Java1234567891011121314151617public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int ret = 0; Map&lt;Character, Integer&gt; hm = new HashMap&lt;&gt;(); int i = 0; for (int j = 0; j &lt; s.length(); ++j) &#123; int k = hm.getOrDefault(s.charAt(j), -1); if (k &gt;= i) &#123; i = k + 1; &#125; else &#123; ret = Math.max(ret, j - i + 1); &#125; hm.put(s.charAt(j), j); &#125; return ret; &#125;&#125; 4. Median of Two Sorted Arrays There are two sorted arrays nums1 and nums2 of size m and n respectively.Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). Example 1:nums1 = [1, 3]nums2 = [2]The median is 2.0 Example 2:nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 Tags: Divide and Conquer, Binary Search, Array C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; auto sz = nums1.size() + nums2.size(); if (sz &amp; 0x01) &#123; auto ret = findKthElement(begin(nums1), nums1.size(), begin(nums2), nums2.size(), sz / 2 + 1); //auto ret = findKthElement(nums1.data(), nums1.size(), nums2.data(), nums2.size(), sz / 2 + 1); return static_cast&lt;double&gt;(ret); &#125; else &#123; auto ret1 = findKthElement(begin(nums1), nums1.size(), begin(nums2), nums2.size(), sz / 2); auto ret2 = findKthElement(begin(nums1), nums1.size(), begin(nums2), nums2.size(), sz / 2 + 1); //auto ret1 = findKthElement(nums1.data(), nums1.size(), nums2.data(), nums2.size(), sz / 2); //auto ret2 = findKthElement(nums1.data(), nums1.size(), nums2.data(), nums2.size(), sz / 2 + 1); return (static_cast&lt;double&gt;(ret1) + static_cast&lt;double&gt;(ret2)) / 2.0; &#125; &#125; private: int findKthElement(const int* nums1, size_t len1, const int* nums2, size_t len2, size_t k) &#123; if (len1 &gt; len2) &#123; return findKthElement(nums2, len2, nums1, len1, k); &#125; if (len1 == 0) &#123; return nums2[k - 1]; &#125; if (k == 1) &#123; return min(nums1[k - 1], nums2[k - 1]); &#125; auto dis1 = min(k / 2, len1); auto dis2 = k - dis1; if (nums1[dis1 - 1] &lt; nums2[dis2 - 1]) &#123; return findKthElement(nums1 + dis1, len1 - dis1, nums2, len2, k - dis1); &#125; else if (nums1[dis1 - 1] &gt; nums2[dis2 - 1]) &#123; return findKthElement(nums1, len1, nums2 + dis2, len2 - dis2, k - dis2); &#125; else &#123; return nums1[dis1 - 1]; &#125; return -1; &#125; int findKthElement(vector&lt;int&gt;::const_iterator begin_1, size_t len_1, vector&lt;int&gt;::const_iterator begin_2, size_t len_2, size_t k) &#123; if (len_1 &gt; len_2) &#123; return findKthElement(begin_2, len_2, begin_1, len_1, k); &#125; if (len_1 == 0) &#123; return *(begin_2 + k - 1); &#125; if (k == 1) &#123; return std::min(*begin_1, *begin_2); &#125; auto dis_1 = std::min(k / 2, len_1); auto dis_2 = k - dis_1; if (*(begin_1 + dis_1 - 1) &lt; *(begin_2 + dis_2 - 1)) &#123; return findKthElement(begin_1 + dis_1, len_1 - dis_1, begin_2, len_2, k - dis_1); &#125; else if (*(begin_1 + dis_1 - 1) &gt; *(begin_2 + dis_2 - 1)) &#123; return findKthElement(begin_1, len_1, begin_2 + dis_2, len_2 - dis_2, k - dis_2); &#125; else &#123; return *(begin_1 + dis_1 - 1); &#125; return -1; &#125;&#125;; Java123456789101112131415161718192021222324252627282930313233public class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int len = nums1.length + nums2.length; if ((len &amp; 0x01) == 0x01) &#123; return findKthElement(nums1, 0, nums2, 0, len / 2 + 1); &#125; else &#123; double left = findKthElement(nums1, 0, nums2, 0, len / 2); double right = findKthElement(nums1, 0, nums2, 0, len / 2 + 1); return (left + right) / 2.0; &#125; &#125; private double findKthElement(int[] nums1, int start1, int[] nums2, int start2, int k) &#123; if ((nums1.length - start1) &gt; (nums2.length - start2)) &#123; return findKthElement(nums2, start2, nums1, start1, k); &#125; if ((nums1.length - start1) &lt;= 0) &#123; return (double) nums2[start2 + k - 1]; &#125; if (k == 1) &#123; return Math.min((double) nums1[start1], (double) nums2[start2]); &#125; int dis1 = Math.min(k / 2, nums1.length - start1); int dis2 = k - dis1; if (nums1[start1 + dis1 - 1] &lt; nums2[start2 + dis2 - 1]) &#123; return findKthElement(nums1, start1 + dis1, nums2, start2, k - dis1); &#125; else if (nums1[start1 + dis1 - 1] &gt; nums2[start2 + dis2 - 1]) &#123; return findKthElement(nums1, start1, nums2, start2 + dis2, k - dis2); &#125; else &#123; return (double) nums1[start1 + dis1 - 1]; &#125; &#125;&#125; 5. Longest Palindromic Substring Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example:Input: “babad”Output: “bab”Note: “aba” is also a valid answer. Example:Input: “cbbd”Output: “bb” Tags String 注意C++的substr和Java的substring的区别 C++1234567891011121314151617181920212223242526272829class Solution &#123;public: string longestPalindrome(string s) &#123; int start = 0; int len = 1; for (int i = 0; i &lt; s.length(); ++i) &#123; auto cur = _getLongestPalindromeLength(s, i); if (cur &gt; len) &#123; len = cur; start = i - (len - 1) / 2; &#125; &#125; return s.substr(start, len); &#125; private: inline int _getLongestPalindromeLength(const string &amp;s, int i) &#123; return max(_getLongestPalindromeLength(s, i, i), _getLongestPalindromeLength(s, i, i + 1)); &#125; inline int _getLongestPalindromeLength(const string &amp;s, int left, int right) &#123; while (left &gt;= 0 &amp;&amp; right &lt; static_cast&lt;int&gt;(s.length()) &amp;&amp; s[left] == s[right]) &#123; --left; ++right; &#125; return right - left - 1; &#125; &#125;; Java1234567891011121314151617181920212223242526public class Solution &#123; public String longestPalindrome(String s) &#123; int len = 1; int start = 0; for (int i = 0; i &lt; s.length(); ++i) &#123; int cur = getLongestPalindromeLength(s, i); if (cur &gt; len) &#123; len = cur; start = i - (len - 1) / 2; &#125; &#125; return s.substring(start, start + len); &#125; private int getLongestPalindromeLength(String s, int i) &#123; return Math.max(getLongestPalindromeLength(s, i, i), getLongestPalindromeLength(s, i, i + 1)); &#125; private int getLongestPalindromeLength(String s, int left, int right) &#123; while (left &gt;= 0 &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123; --left; ++right; &#125; return right - left - 1; &#125;&#125; 6. ZigZag Conversion The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)P A H NA P L S I I GY I RAnd then read line by line: “PAHNAPLSIIGYIR”Write the code that will take a string and make this conversion given a number of rows:string convert(string text, int nRows);convert(“PAYPALISHIRING”, 3) should return “PAHNAPLSIIGYIR”. Tags: string C++123456789101112131415161718192021222324class Solution &#123;public: string convert(string s, int numRows) &#123; if (numRows &lt;= 1 || numRows &gt;= static_cast&lt;int&gt;(s.size())) &#123; return s; &#125; vector&lt;string&gt; ret(numRows, ""); int row_cursor = 0; int step = 0; for (size_t idx = 0; idx != s.size(); ++idx) &#123; ret[row_cursor].push_back(s[idx]); if (row_cursor == 0) &#123; step = 1; &#125; else if (row_cursor == numRows - 1) &#123; step = -1; &#125; row_cursor += step; // update row_cursor &#125; string result; result.reserve(numRows); for_each(ret.begin(), ret.end(), [&amp;result](string&amp; item) &#123; result += std::move(item); &#125;); return result; &#125;&#125;; Java1234567891011121314151617181920212223242526public class Solution &#123; public String convert(String s, int numRows) &#123; if (s.isEmpty() || numRows ==1 || numRows &gt;= s.length()) &#123; return s; &#125; ArrayList&lt;StringBuilder&gt; ret = new ArrayList&lt;&gt;(Collections.nCopies(numRows, null)); int idx = 0; int step = 0; for (int i = 0; i &lt; s.length(); ++i) &#123; if (ret.get(idx) == null) &#123; ret.set(idx, new StringBuilder()); &#125; ret.get(idx).append(s.charAt(i)); if (idx == numRows - 1) &#123; step = -1; &#125; else if (idx == 0) &#123; step = 1; &#125; idx += step; &#125; for (int i = 1; i &lt; ret.size(); ++i) &#123; ret.get(0).append(ret.get(i)); &#125; return ret.get(0).toString(); &#125;&#125; 7. Reverse Integer Reverse digits of an integer.Example1: x = 123, return 321Example2: x = -123, return -321 Tags: Math C++1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int reverse(int x) &#123; int ret = 0; for ( ; x != 0; x /= 10) &#123; int tail = x % 10; int tmp = ret * 10 + tail; if ((tmp - tail) / 10 != ret) &#123; // overflow return 0; &#125; ret = tmp; &#125; return ret; &#125;&#125;;class Solution &#123;public: int reverse(int x) &#123; int flag = x &lt; 0 ? -1 : 1; int ret = 0; while (x != 0) &#123; int cur = (x % 10) * flag; if (ret &gt; INT_MAX / 10 || (ret == INT_MAX / 10 &amp;&amp; cur &gt; INT_MAX % 10)) &#123; return 0; &#125; ret = 10 * ret + cur; x /= 10; &#125; return flag * ret; &#125;&#125;; Java123456789101112131415161718192021222324252627282930public class Solution &#123; public int reverse(int x) &#123; int ret = 0; for ( ; x != 0; x /= 10) &#123; int tail = x % 10; int tmp = ret * 10 + tail; if ((tmp - tail) / 10 != ret) &#123; return 0; &#125; ret = tmp; &#125; return ret; &#125;&#125;public class Solution &#123; public int reverse(int x) &#123; int ret = 0; int flag = x &lt; 0 ? -1 : 1; while (x != 0) &#123; int cur = (x % 10) * flag; if (ret &gt; Integer.MAX_VALUE / 10 || (ret == Integer.MAX_VALUE / 10 &amp;&amp; cur &gt; Integer.MAX_VALUE % 10)) &#123; return 0; &#125; ret = 10 * ret + cur; x /= 10; &#125; return flag * ret; &#125;&#125; 8. String to Integer (atoi) Implement atoi to convert a string to an integer.Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases. Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. Tags: Math, String C++123456789101112131415161718192021222324252627class Solution &#123;public: int myAtoi(string str) &#123; int ret = 0; auto int_max = std::numeric_limits&lt;int&gt;::max(); auto int_min = std::numeric_limits&lt;int&gt;::min(); auto iter = std::begin(str); while (*iter == ' ') &#123; ++iter; &#125; bool negative = false; if (*iter == '-' || *iter == '+') &#123; if(*iter == '-') &#123; negative = true; &#125; ++iter; &#125; for ( ; iter != std::end(str) &amp;&amp; std::isdigit(*iter); ++iter) &#123; int cur = *iter - '0'; if (ret &gt; int_max / 10 || (ret == int_max / 10 &amp;&amp; cur &gt; int_max % 10)) &#123; return negative ? int_min : int_max; &#125; ret = ret * 10 + cur; &#125; return negative ? -ret : ret; &#125;&#125;; Java123456789101112131415161718192021222324252627282930public class Solution &#123; public int myAtoi(String str) &#123; int ret = 0; boolean negative = false; int idx = 0; // deal empty string which not the same as C++ and String is iteratable (java Collections) if (str.isEmpty()) &#123; return ret; &#125; // remove leading space for ( ; str.charAt(idx) == ' '; ++idx) &#123;&#125; // get flag if (str.charAt(idx) == '+' || str.charAt(idx) == '-') &#123; negative = (str.charAt(idx) == '-' ? true : false); ++idx; &#125; // parsing digit chars for ( ; idx &lt; str.length(); ++idx) &#123; int cur = str.charAt(idx) - '0'; if (cur &lt; 0 || cur &gt; 9) &#123; break; &#125; if (ret &gt; Integer.MAX_VALUE / 10 || (ret == Integer.MAX_VALUE / 10 &amp;&amp; Integer.MAX_VALUE % 10 &lt; cur)) &#123; return negative ? Integer.MIN_VALUE : Integer.MAX_VALUE; &#125; ret = ret * 10 + cur; &#125; return negative ? -ret : ret; &#125;&#125; 9. Palindrome NumberTags: String Cpp123456789class Solution &#123;public: bool isPalindrome(int x) &#123; string s1 = std::move(std::to_string(x)); string s2(s1); reverse(s1.begin(), s1.end()); return s1 == s2; &#125;&#125;; Java1234567public class Solution &#123; public boolean isPalindrome(int x) &#123; String a = String.valueOf(x); String b = (new StringBuilder(a)).reverse().toString(); return a.equals(b); &#125;&#125; 10. Regular Expression Matching Implement regular expression matching with support for ‘.’ and ‘*‘.‘.’ Matches any single character.‘*‘ Matches zero or more of the preceding element.The matching should cover the entire input string (not partial).The function prototype should be:bool isMatch(const char s, const char p) Some examples:isMatch(“aa”,”a”) ? falseisMatch(“aa”,”aa”) ? trueisMatch(“aaa”,”aa”) ? falseisMatch(“aa”, “a“) ? trueisMatch(“aa”, “.“) ? trueisMatch(“ab”, “.“) ? trueisMatch(“aab”, “ca*b”) ? true Tag: String, Dynamic Programming, Backtracking Use Dynamic ProgrammingCpp12345678910111213141516171819202122232425262728293031class Solution &#123;public: bool isMatch(string s, string p) &#123; // last char is the key postion, which may be '*' or not // match[i][j] record the s[0 : i - 1] matched p[0 : j - 1] so // match[0][0] = true, match[1 : ][0] = false, match[0][1 : ] = (j &gt; 1 &amp;&amp; match[0][j - 2] &amp;&amp; p[j - 1] == '*') // match[i][j] = p[j - 1] != '*' &amp;&amp; (match[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == '.')) // match[i][j] = p[j - 1] == '*' &amp;&amp; (match[i][j - 2] || (match[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 1] == '.'))) vector&lt;vector&lt;bool&gt;&gt; match(s.length() + 1, vector&lt;bool&gt;(p.length() + 1, false)); match[0][0] = true; for (size_t i = 1; i &lt; match.size(); ++i) &#123; match[i][0] = false; &#125; for (size_t j = 1; j &lt; match[0].size(); ++j) &#123; match[0][j] = (j &gt; 1) &amp;&amp; match[0][j - 2] &amp;&amp; (p[j - 1] == '*'); &#125; for (size_t i = 1; i &lt; match.size(); ++i) &#123; for (size_t j = 1; j &lt; match[0].size(); ++j) &#123; if (p[j - 1] != '*') &#123; match[i][j] = match[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == '.'); &#125; else &#123; // p[j - 1] is '*' so p[j - 2] must exist and match[i - 1][j] covers match[i - 1][j - 2] match[i][j] = match[i][j - 2] || (match[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 2] == '.')); &#125; &#125; &#125; return match.back().back(); &#125;&#125;; Java123456789101112131415161718192021222324252627282930public class Solution &#123; public boolean isMatch(String s, String p) &#123; // last char is the key postion, which may be '*' or not // match[i][j] record the s[0 : i - 1] matched p[0 : j - 1] so // match[0][0] = true, match[1 : ][0] = false, match[0][1 : ] = (j &gt; 1 &amp;&amp; match[0][j - 2] &amp;&amp; p[j - 1] == '*') // match[i][j] = p[j - 1] != '*' &amp;&amp; (match[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == '.')) // match[i][j] = p[j - 1] == '*' &amp;&amp; (match[i][j - 2] || (match[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 1] == '.'))) boolean[][] match = new boolean[s.length() + 1][p.length() + 1]; match[0][0] = true; for (int i = 1; i &lt; match.length; ++i) &#123; match[i][0] = false; &#125; for (int j = 1; j &lt; match[0].length; ++j) &#123; match[0][j] = (j &gt; 1) &amp;&amp; match[0][j - 2] &amp;&amp; p.charAt(j - 1) == '*'; &#125; for (int i = 1; i &lt; match.length; ++i) &#123; for (int j = 1; j &lt; match[0].length; ++j) &#123; if (p.charAt(j - 1) != '*') &#123; match[i][j] = match[i - 1][j - 1] &amp;&amp; (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.'); &#125; else &#123; // p[j - 1] is '*' so p[j - 2] must exist and match[i - 1][j] covers match[i - 1][j - 2] match[i][j] = match[i][j - 2] || (match[i - 1][j] &amp;&amp; (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.')); &#125; &#125; &#125; return match[s.length()][p.length()]; &#125;&#125; Use Backtracking123456789101112131415161718192021222324class Solution &#123;public: bool isMatch(string s, string p) &#123; return isMatch(s.c_str(), p.c_str()); &#125;private: // use c++ string's feature (end with '\0') to avoid some condition check in java inline bool charMatch(const char *s, const char *p) &#123; return (*s == *p || (*p == '.' &amp;&amp; *s != '\0')); &#125; bool isMatch(const char *s, const char *p) &#123; if (*p == '\0') &#123; return *s == '\0'; &#125; if (*(p + 1) != '*') &#123; return charMatch(s, p) &amp;&amp; isMatch(s + 1, p + 1); &#125; else if (charMatch(s, p)) &#123; return isMatch(s + 1, p) || isMatch(s, p + 2); &#125; else &#123; return isMatch(s, p + 2); &#125; &#125;&#125;; 11. Container With Most Water Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.Note: You may not slant the container and n is at least 2. Tags: two pointer Cpp12345678910111213141516class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int ret = 0; if (height.size() &lt; 2) &#123; return ret; &#125; size_t left = 0; size_t right = height.size() - 1; while (left &lt; right) &#123; ret = max(ret, min(height[left], height[right]) * static_cast&lt;int&gt;(right - left)); height[left] &lt; height[right] ? ++left : --right; &#125; return ret; &#125;&#125;; Java12345678910111213141516171819public class Solution &#123; public int maxArea(int[] height) &#123; int ret = 0; if (height.length &lt; 2) &#123; return ret; &#125; int left = 0; int right = height.length - 1; while (left &lt; right) &#123; ret = Math.max(ret, Math.min(height[left], height[right]) * (right - left)); if (height[left] &lt; height[right]) &#123; ++left; &#125; else &#123; --right; &#125; &#125; return ret; &#125;&#125; 12. Integer to RomanCpp123456789101112131415class Solution &#123;public: string intToRoman(int num) &#123; vector&lt;string&gt; symbol&#123;"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"&#125;; vector&lt;int&gt; value&#123;1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1&#125;; string ret; for (int i = 0; num &gt; 0; ++i) &#123; while (num &gt;= value[i]) &#123; num -= value[i]; ret += symbol[i]; &#125; &#125; return ret; &#125;&#125;; Java12345678910111213141516public class Solution &#123; public String intToRoman(int num) &#123; String ret = ""; ArrayList&lt;String&gt; symbol = new ArrayList( Arrays.asList("M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I")); ArrayList&lt;Integer&gt; value = new ArrayList( Arrays.asList(1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)); for (int i = 0; num &gt; 0; ++i) &#123; while (num &gt;= value.get(i)) &#123; num -= value.get(i); ret = ret + symbol.get(i); &#125; &#125; return ret; &#125;&#125; 13. Roman to IntegerCpp123456789101112131415161718192021class Solution &#123;public: int romanToInt(string s) &#123; int ret = 0; int pre = 0; unordered_map&lt;char, int&gt; umap &#123; make_pair('I', 1), make_pair('V', 5), make_pair('X', 10), \ make_pair('L', 50), make_pair('C', 100), make_pair('D', 500), \ make_pair('M', 1000)&#125;; for (const auto&amp; c : s) &#123; int cur = umap.at(c); if (cur &lt;= pre) &#123; ret += cur; &#125; else &#123; ret += cur - 2 * pre; // ret = ret - pre + cur - pre &#125; pre = cur; &#125; return ret; &#125;&#125;; Java123456789101112131415161718192021222324public class Solution &#123; public int romanToInt(String s) &#123; HashMap&lt;Character, Integer&gt; hmap = new HashMap&lt;&gt;(); hmap.put('I', 1); hmap.put('V', 5); hmap.put('X', 10); hmap.put('L', 50); hmap.put('C', 100); hmap.put('D', 500); hmap.put('M', 1000); int ret = 0; int pre = 0; for (int i = 0; i &lt; s.length(); ++i) &#123; int cur = hmap.get(s.charAt(i)); if (cur &lt;= pre) &#123; ret += cur; &#125; else &#123; ret = ret - 2 * pre + cur; &#125; pre = cur; &#125; return ret; &#125;&#125; 14. Longest Common PrefixCpp1234567891011121314151617class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if (strs.size() &lt; 1) &#123; return string(""); &#125; for (size_t cursor = 0; cursor &lt; strs[0].size(); ++cursor) &#123; auto cur = strs[0][cursor]; for (size_t i = 1; i &lt; strs.size(); ++i) &#123; if (cur != strs[i][cursor]) &#123; return strs[0].substr(0, cursor); &#125; &#125; &#125; return strs[0]; &#125;&#125;; Java12345678910111213141516public class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; if (strs.length &lt;= 0) &#123; return ""; &#125; for (int cursor = 0; cursor &lt; strs[0].length(); ++cursor) &#123; char pre = strs[0].charAt(cursor); for (int i = 1; i &lt; strs.length; ++i) &#123; if (cursor &gt;= strs[i].length() || strs[i].charAt(cursor) != pre) &#123; return strs[0].substring(0, cursor); &#125; &#125; &#125; return strs[0]; &#125;&#125; 15. 3SumCpp123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; ret; int len = static_cast&lt;int&gt;(nums.size()); std::sort(nums.begin(), nums.end()); for (int i = 0; i &lt; len - 2 &amp;&amp; nums[i] &lt;= 0; ++i) &#123; // remove possible duplicate results if (i &gt; 0 &amp;&amp; nums[i] == nums[i -1 ]) &#123; continue; &#125; int left = i + 1; int right = len - 1; while (left &lt; right) &#123; auto sum = nums[i] + nums[left] + nums[right]; if (sum == 0) &#123; ret.push_back(vector&lt;int&gt;&#123;nums[i], nums[left++], nums[right--]&#125;); // remove possible duplicate results while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) &#123; ++left; &#125; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) &#123; --right; &#125; &#125; else if (sum &gt; 0) &#123; --right; &#125; else &#123; ++left; &#125; &#125; &#125; return ret; &#125;&#125;; Java12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); int len = nums.length; Arrays.sort(nums); for (int i = 0; i &lt; len - 2 &amp;&amp; nums[i] &lt;= 0; ++i) &#123; // remove possible duplicate results if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; int left = i + 1; int right = len - 1; while (left &lt; right) &#123; int sum = nums[i] + nums[left] + nums[right]; if (sum == 0) &#123; ret.add(new ArrayList(Arrays.asList(nums[i], nums[left], nums[right]))); ++left; --right; // remove possible duplicate results while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) &#123; ++left; &#125; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) &#123; --right; &#125; &#125; else if (sum &gt; 0) &#123; --right; &#125; else &#123; ++left; &#125; &#125; &#125; return ret; &#125;&#125; 16. 3sum closetCpp1234567891011121314151617181920212223242526272829class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; int len = nums.size(); assert(len &gt;= 3); int min_diff = INT_MAX; std::sort(nums.begin(), nums.end()); for (int i = 0; i &lt; (len - 2); ++i) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; int left = i + 1; int right = len - 1; while (left &lt; right) &#123; int cur_diff = nums[i] + nums[left] + nums[right] - target; if (cur_diff == 0) &#123; return target; &#125; else if (cur_diff &gt; 0) &#123; right--; &#125; else &#123; left++; &#125; min_diff = abs(cur_diff) &lt; abs(min_diff) ? cur_diff : min_diff; &#125; &#125; return min_diff + target; &#125;&#125;; Java123456789101112131415161718192021222324252627282930public class Solution &#123; public int threeSumClosest(int[] nums, int target) &#123; int len = nums.length; int minDiff = Integer.MAX_VALUE; Arrays.sort(nums); for (int i = 0; i &lt; len - 2; ++i) &#123; // avoid duplicate calc if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; int left = i + 1; int right = len - 1; while (left &lt; right) &#123; int curDiff = nums[i] + nums[left] + nums[right] - target; if (curDiff == 0) &#123; return target; &#125; else if (curDiff &gt; 0) &#123; --right; &#125; else &#123; ++left; &#125; if (Math.abs(curDiff) &lt; Math.abs(minDiff)) &#123; minDiff = curDiff; &#125; &#125; &#125; return minDiff + target; &#125;&#125; 17. Letter Combinations of a Phone Number Given a digit string, return all possible letter combinations that the number could represent.A mapping of digit to letters (just like on the telephone buttons) is given below. Tags: backtracking, string Cpp12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; vector&lt;string&gt; ret; if (digits.empty()) &#123; return ret; &#125; vector&lt;string&gt; keyboard&#123;" ", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"&#125;; // return letterCombinationsIterative(digits, keyboard); letterCombinations(ret, "", 0, digits, keyboard); return ret; &#125;private: void letterCombinations(vector&lt;string&gt; &amp;ret, const string &amp;cur, size_t idx, const string &amp;digits, const vector&lt;string&gt; &amp;keyboard) &#123; if (idx &gt;= digits.size()) &#123; ret.push_back(cur); &#125; else &#123; for (auto c : keyboard[digits[idx] - '0']) &#123; letterCombinations(ret, cur + c, idx + 1, digits, keyboard); &#125; &#125; &#125; vector&lt;string&gt; letterCombinationsIterative(const string &amp;digits, const vector&lt;string&gt; &amp;keyboard) &#123; vector&lt;string&gt; ret&#123;""&#125;; for (auto d : digits) &#123; vector&lt;string&gt; tmp; for (auto r : ret) &#123; for (auto c : keyboard[d - '0']) &#123; tmp.push_back(r + c); &#125; &#125; ret.swap(tmp); &#125; return ret; &#125;&#125;; Java1234567891011121314151617181920212223242526272829303132333435363738394041public class Solution &#123; public List&lt;String&gt; letterCombinations(String digits) &#123; List&lt;String&gt; ret = new ArrayList&lt;&gt;(); if (digits.isEmpty()) &#123; return ret; &#125; ArrayList&lt;String&gt; keyboard = new ArrayList( Arrays.asList(" ", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz")); // return letterCombinationsIterative(digits, keyboard); letterCombinationsRecursive(ret, "", 0, digits, keyboard); return ret; &#125; private void letterCombinationsRecursive(List&lt;String&gt; ret, String cur, int idx, String digits, List&lt;String&gt; keyboard) &#123; if (idx &gt;= digits.length()) &#123; ret.add(cur); &#125; else &#123; String key = keyboard.get(digits.charAt(idx) - '0'); for (int i = 0; i &lt; key.length(); ++i) &#123; letterCombinationsRecursive(ret, cur + key.charAt(i), idx + 1, digits, keyboard); &#125; &#125; &#125; private List&lt;String&gt; letterCombinationsIterative(String digits, List&lt;String&gt; keyboard) &#123; List&lt;String&gt; ret = new ArrayList&lt;&gt;(); ret.add(""); for (int i = 0; i &lt; digits.length(); ++i) &#123; List&lt;String&gt; tmp = new ArrayList&lt;&gt;(); for (String r : ret) &#123; int cur = digits.charAt(i) - '0'; for (int j = 0; j &lt; keyboard.get(cur).length(); ++j) &#123; tmp.add(r + keyboard.get(cur).charAt(j)); &#125; &#125; ret = tmp; &#125; return ret; &#125;&#125; Scala12345678910111213141516171819202122232425262728object Solution &#123; def letterCombinations(digits: String): List[String] = &#123; val ret = List[String]() val keyboard = Array(" ", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz") digits.isEmpty match &#123; case true =&gt; ret case false =&gt; //letterCombinationsIterative(digits, keyboard) letterCombinationsRecursive(0, digits, keyboard) &#125; &#125; private def letterCombinationsRecursive(start: Int, digits: String, keyboard: Array[String]): List[String] = &#123; if (start &gt;= digits.size) &#123; List("") &#125; else &#123; val tmp = letterCombinationsRecursive(start + 1, digits, keyboard) (for &#123; k &lt;- keyboard(digits(start) - '0') t &lt;- tmp &#125; yield (k + t)).toList &#125; &#125; private def letterCombinationsIterative(digits: String, keyboard: Array[String]): List[String] = &#123; digits.foldLeft(List("")) &#123; (ret, d) =&gt; ret.flatMap &#123; r =&gt; keyboard(d - '0').map &#123; k =&gt; r + k &#125; &#125; &#125; &#125;&#125; 18. 4Sum Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.Note: The solution set must not contain duplicate quadruplets.For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] Tags: two pointer Cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;vector&lt;int&gt;&gt; ret; if (nums.size() &lt; 4) &#123; return ret; &#125; sort(nums.begin(), nums.end()); vector&lt;int&gt; cur; ksum(ret, 0, 4, cur, target, nums); return ret; &#125;private: void ksum(vector&lt;vector&lt;int&gt;&gt; &amp;ret, int start, int k, vector&lt;int&gt; &amp;cur, int target, const vector&lt;int&gt; &amp;nums) &#123; if (k * nums.front() &gt; target || k * nums.back() &lt; target) &#123; return; &#125; else if (k == 2) &#123; int left = start; int right = nums.size() - 1; while (left &lt; right) &#123; auto sum = nums[left] + nums[right] - target; if (sum == 0) &#123; auto tmp = cur; tmp.push_back(nums[left]); tmp.push_back(nums[right]); ret.push_back(tmp); ++left; --right; // avoid possible duplicates while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) &#123; ++left; &#125; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) &#123; --right; &#125; &#125; else if (sum &gt; 0) &#123; --right; &#125; else &#123; ++left; &#125; &#125; &#125; else &#123; for (int i = start; i &lt; nums.size() -k + 1; ++i) &#123; if (i &gt; start &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; cur.push_back(nums[i]); ksum(ret, i + 1, k - 1, cur, target - nums[i], nums); cur.pop_back(); &#125; &#125; &#125; &#125;; Java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); if (nums.length &lt; 4) &#123; return ret; &#125; Arrays.sort(nums); List&lt;Integer&gt; cur = new ArrayList&lt;&gt;(); ksum(ret, 0, 4, cur, target, nums); return ret; &#125; private void ksum(List&lt;List&lt;Integer&gt;&gt; ret, int start, int k, List&lt;Integer&gt; cur, int target, int[] nums) &#123; if (k * nums[0] &gt; target || k * nums[nums.length - 1] &lt; target) &#123; return; &#125; else if (k == 2) &#123; int left = start; int right = nums.length - 1; while (left &lt; right) &#123; int sum = nums[left] + nums[right] - target; if (sum == 0) &#123; List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(cur); tmp.add(nums[left]); tmp.add(nums[right]); ret.add(tmp); ++left; --right; // avoid possible duplicates while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) &#123; ++left; &#125; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) &#123; --right; &#125; &#125; else if (sum &gt; 0) &#123; --right; &#125; else &#123; ++left; &#125; &#125; &#125; else &#123; for (int i = start; i &lt; nums.length - k + 1; ++i) &#123; if (i &gt; start &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; cur.add(nums[i]); ksum(ret, i + 1, k - 1, cur, target - nums[i], nums); cur.remove(cur.size() - 1); &#125; &#125; &#125;&#125; Scala123456789101112131415161718192021222324252627282930313233343536373839object Solution &#123; def fourSum(nums: Array[Int], target: Int): List[List[Int]] = &#123; var ret: List[List[Int]] = List() if (nums.size &lt; 4) return ret val sortedNums = nums.sorted var cur: List[Int] = List() def ksum(start: Int, k: Int, target: Int): Unit = &#123; if (k == 2) &#123; var left = start; var right = sortedNums.size - 1 while (left &lt; right) &#123; var sum = sortedNums(left) + sortedNums(right) - target if (sum == 0) &#123; var tmp = cur ::: List(sortedNums(left), sortedNums(right)) ret = ret ::: List(tmp) left += 1 right -= 1 while (left &lt; right &amp;&amp; sortedNums(left) == sortedNums(left - 1)) left += 1 while (left &lt; right &amp;&amp; sortedNums(right) == sortedNums(right + 1)) right -= 1 &#125; else if (sum &gt; 0) &#123; right -= 1 &#125; else left += 1 &#125; &#125; else &#123; for (i &lt;- start until sortedNums.length - k + 1) &#123; if (i == start || sortedNums(i) != sortedNums(i - 1)) &#123; var tmp = cur cur = cur ::: List(sortedNums(i)) ksum(i + 1, k - 1, target - sortedNums(i)) cur = tmp &#125; &#125; &#125; &#125; ksum(0, 4, target) ret &#125;&#125; 19. Remove Nth Node From End of ListTags: List Cpp1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode dummy = ListNode(0); dummy.next = head; ListNode *first = &amp;dummy; for (int i = 0; i &lt; n; ++i) &#123; if (first == nullptr) &#123; return nullptr; &#125; else &#123; first = first-&gt;next; &#125; &#125; ListNode *pre = &amp;dummy; for (; first != nullptr &amp;&amp; first-&gt;next != nullptr; first = first-&gt;next) &#123; pre = pre-&gt;next; &#125; auto tmp = pre-&gt;next-&gt;next; delete pre-&gt;next; pre-&gt;next = tmp; return dummy.next; &#125;&#125;; Java123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode first = dummy; for (int i = 0; i &lt; n; ++i) &#123; if (first == null) &#123; return null; &#125; else &#123; first = first.next; &#125; &#125; ListNode ptr = dummy; for (; first != null &amp;&amp; first.next != null; first = first.next) &#123; ptr = ptr.next; &#125; ListNode tmp = ptr.next.next; ptr.next = null; ptr.next = tmp; return dummy.next; &#125;&#125; 20. Valid ParenthesesTags: Stack Cpp123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: bool isValid(string s) &#123; stack&lt;char&gt; stc; for (auto c : s) &#123; if (isLeft(c)) &#123; stc.push(c); &#125; else if (stc.empty()) &#123; return false; &#125; else if (isMatch(stc.top(), c)) &#123; stc.pop(); &#125; else &#123; return false; &#125; &#125; return stc.empty(); &#125; private: bool isLeft(char c) &#123; return (c == '(' || c == '&#123;' || c == '['); &#125; bool isMatch(char l, char r) &#123; if (l == '(') &#123; return r == ')'; &#125; else if (l == '&#123;') &#123; return r == '&#125;'; &#125; else if (l == '[') &#123; return r == ']'; &#125; else &#123; return false; &#125; &#125; &#125;; Java1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stc = new Stack&lt;&gt;(); for (int i = 0; i &lt; s.length(); ++i) &#123; char c = s.charAt(i); if (isLeft(c)) &#123; stc.push(c); &#125; else if (stc.empty()) &#123; return false; &#125; else if (isMatch(stc.peek(), c)) &#123; stc.pop(); &#125; else &#123; return false; &#125; &#125; return stc.empty(); &#125; private boolean isLeft(char c) &#123; return (c == '(' || c == '&#123;' || c == '['); &#125; private boolean isMatch(char l, char r) &#123; if (l == '(') &#123; return r == ')'; &#125; else if (l == '&#123;') &#123; return r == '&#125;'; &#125; else if (l == '[') &#123; return r == ']'; &#125; else &#123; return false; &#125; &#125; &#125;; Scala123456789101112131415object Solution &#123; def isValid(s: String): Boolean = &#123; val parenthesesMap = Map('(' -&gt; ')', '&#123;' -&gt; '&#125;', '[' -&gt; ']') val ret = s.foldLeft(List[Char]()) &#123; (stc, c) =&gt; c match &#123; case '(' | '&#123;' | '[' =&gt; c :: stc case ')' | '&#125;' | ']' =&gt; if (stc.isEmpty) return false else if (parenthesesMap.get(stc.head) != Some(c)) return false else stc.tail &#125; &#125; ret.isEmpty &#125;&#125; 21. Merge Two Sorted ListsCpp123456789101112131415161718192021222324/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if (l1 == nullptr) &#123; return l2; &#125; else if (l2 == nullptr) &#123; return l1; &#125; else if (l1-&gt;val &lt; l2-&gt;val) &#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125; else &#123; l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; &#125; &#125;&#125;; Java1234567891011121314151617181920212223/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) &#123; return l2; &#125; else if (l2 == null) &#123; return l1; &#125; else if (l1.val &lt; l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125; &#125;&#125; Scala1234567891011121314151617181920212223/** * Definition for singly-linked list. * class ListNode(var _x: Int = 0) &#123; * var next: ListNode = null * var x: Int = _x * &#125; */object Solution &#123; def mergeTwoLists(l1: ListNode, l2: ListNode): ListNode = &#123; (l1, l2) match &#123; case (null, _) =&gt; l2 case (_, null) =&gt; l1 case _ =&gt; (l1.x &lt; l2.x) match &#123; case true =&gt; l1.next = mergeTwoLists(l1.next, l2) l1 case false =&gt; l2.next = mergeTwoLists(l1, l2.next) l2 &#125; &#125; &#125;&#125; 22. Generate ParenthesesCpp123456789101112131415161718192021class Solution &#123;public: vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; ret; generateParenthesis(ret, "", n, n); return ret; &#125;private: void generateParenthesis(vector&lt;string&gt; &amp;ret, string cur, int curLeftNum, int curRightNum) &#123; if (curLeftNum == 0 &amp;&amp; curRightNum == 0) &#123; ret.push_back(cur); &#125; if (curLeftNum &gt; 0) &#123; generateParenthesis(ret, cur + '(', curLeftNum - 1, curRightNum); &#125; if (curRightNum &gt; curLeftNum) &#123; generateParenthesis(ret, cur + ')', curLeftNum, curRightNum - 1); &#125; &#125;&#125;; Java12345678910111213141516171819public class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; ret = new ArrayList&lt;&gt;(); generateParenthesis(ret, "", n, n); return ret; &#125; private void generateParenthesis(List&lt;String&gt; ret, String cur, int curLeftNum, int curRightNum) &#123; if (curLeftNum == 0 &amp;&amp; curRightNum == 0) &#123; ret.add(cur); &#125; if (curLeftNum &gt; 0) &#123; generateParenthesis(ret, cur + "(", curLeftNum - 1, curRightNum); &#125; if (curRightNum &gt; curLeftNum) &#123; generateParenthesis(ret, cur + ")", curLeftNum, curRightNum - 1); &#125; &#125;&#125; Scala12345678910111213141516171819202122232425object Solution &#123; def generateParenthesis(n: Int): List[String] = &#123; generateInternal(List[String](), "", n, n) &#125; private def generateInternal(ret: List[String], cur: String, curLeftNum: Int, curRightNum: Int): List[String] = &#123; if (curLeftNum == 0 &amp;&amp; curRightNum == 0) &#123; ret ::: List(cur) &#125; else &#123; val ret1 = &#123; if (curLeftNum &gt; 0) generateInternal(ret, cur + "(", curLeftNum - 1, curRightNum) else ret &#125; val ret2 = &#123; if (curRightNum &gt; curLeftNum) generateInternal(ret1, cur + ")", curLeftNum, curRightNum - 1) else ret1 &#125; ret2 &#125; &#125;&#125; 23. Merge k Sorted Lists Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. Tags: Linked List, Divide and Conquer, Heap C++123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; if (lists.empty()) &#123; return nullptr; &#125; for (int sz = static_cast&lt;int&gt;(lists.size()); sz &gt; 1; ) &#123; int offset = (sz + 1) / 2; for (int i = 0; i &lt; sz / 2; ++i) &#123; lists[i] = mergeTwoLists(lists[i], lists[i + offset]); &#125; sz = offset; &#125; return lists.front(); &#125; private: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if (l1 == nullptr) &#123; return l2; &#125; else if (l2 == nullptr) &#123; return l1; &#125; else if (l1-&gt;val &lt; l2-&gt;val) &#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125; else &#123; l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; &#125; &#125;&#125;; Java12345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; if (lists.length == 0) &#123; return null; &#125; for (int sz = lists.length; sz &gt; 1; ) &#123; int offset = (sz + 1) / 2; for (int i = 0; i &lt; sz / 2; ++i) &#123; lists[i] = mergeTwoLists(lists[i], lists[i + offset]); &#125; sz = offset; &#125; return lists[0]; &#125; private ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) &#123; return l2; &#125; else if (l2 == null) &#123; return l1; &#125; else if (l1.val &lt; l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125; &#125;&#125; 24. Swap Nodes in Pairs Given a linked list, swap every two adjacent nodes and return its head.For example,Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. Tags: LinkedList C++123456789101112131415161718192021222324/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; ListNode dummy(1); dummy.next = head; auto pre = &amp;dummy; for (auto cur = head; cur != nullptr &amp;&amp; cur-&gt;next != nullptr; cur = cur-&gt;next) &#123; auto tmp = cur-&gt;next; cur-&gt;next = tmp-&gt;next; tmp-&gt;next = cur; pre-&gt;next = tmp; pre = cur; &#125; return dummy.next; &#125;&#125;; Java1234567891011121314151617181920212223/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode swapPairs(ListNode head) &#123; ListNode dummy = new ListNode(1); dummy.next = head; ListNode pre = dummy; for (ListNode cur = head; cur != null &amp;&amp; cur.next != null; cur = cur.next) &#123; ListNode tmp = cur.next; cur.next = tmp.next; tmp.next = cur; pre.next = tmp; pre = cur; &#125; return dummy.next; &#125;&#125; 25. Reverse Nodes in k-Group Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.You may not alter the values in the nodes, only nodes itself may be changed.Only constant memory is allowed. For example,Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5 Tags: Array, HashTable C++1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseKGroup(ListNode* head, int k) &#123; ListNode dummy = ListNode(0); dummy.next = head; auto pre = &amp;dummy; auto ptr = &amp;dummy; for (int i = 0; i &lt; k &amp;&amp; ptr != nullptr; ++i) &#123; ptr = ptr-&gt;next; &#125; while (ptr != nullptr) &#123; auto nextDummy = pre-&gt;next; for (int i = 1; i &lt; k; ++i) &#123; auto tmp = pre-&gt;next-&gt;next; pre-&gt;next-&gt;next = ptr-&gt;next; ptr-&gt;next = pre-&gt;next; pre-&gt;next = tmp; &#125; pre = nextDummy; ptr = nextDummy; for (int i = 0; i &lt; k &amp;&amp; ptr != nullptr; ++i) &#123; ptr = ptr-&gt;next; &#125; &#125; return dummy.next; &#125;&#125;; Java12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseKGroup(ListNode head, int k) &#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode pre = dummy; ListNode ptr = dummy; for (int i = 0; i &lt; k &amp;&amp; ptr != null; ++i) &#123; ptr = ptr.next; &#125; while (ptr != null) &#123; ListNode nextDummy = pre.next; for (int i = 1; i &lt; k; ++i) &#123; ListNode tmp = pre.next.next; pre.next.next = ptr.next; ptr.next = pre.next; pre.next = tmp; &#125; pre = nextDummy; ptr = nextDummy; for (int i = 0; i &lt; k &amp;&amp; ptr != null; ++i) &#123; ptr = ptr.next; &#125; &#125; return dummy.next; &#125;&#125; 26. Remove Duplicates from Sorted ArrayCpp1234567891011121314class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int pre = -1; for (int cur = 0; cur &lt; static_cast&lt;int&gt;(nums.size()); ++cur) &#123; if (pre == -1) &#123; ++pre; &#125; else if (nums[cur] != nums[cur - 1]) &#123; nums[++pre] = nums[cur]; &#125; &#125; return pre + 1; &#125;&#125;; Java12345678910111213public class Solution &#123; public int removeDuplicates(int[] nums) &#123; int pre = -1; for (int cur = 0; cur &lt; nums.length; ++cur) &#123; if (pre == -1) &#123; ++pre; &#125; else if (nums[cur] != nums[cur - 1]) &#123; nums[++pre] = nums[cur]; &#125; &#125; return pre + 1; &#125;&#125; Scala1234567891011121314object Solution &#123; def removeDuplicates(nums: Array[Int]): Int = &#123; var pre = -1 for (cur &lt;- 0 until nums.length) &#123; if (pre == -1) &#123; pre += 1 &#125; else if (nums(cur) != nums(cur - 1)) &#123; pre += 1 nums(pre) = nums(cur) &#125; &#125; return pre + 1 &#125;&#125; 27. Remove ElementC++123456789101112class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int ret = 0; for (auto n : nums) &#123; if (n != val) &#123; nums[ret++] = n; &#125; &#125; return ret; &#125;&#125;; Java1234567891011class Solution &#123; public int removeElement(int[] nums, int val) &#123; int ret = 0; for (int i = 0; i &lt; nums.length; ++i) &#123; if (nums[i] != val) &#123; nums[ret++] = nums[i]; &#125; &#125; return ret; &#125;&#125; Scala123456789101112object Solution &#123; def removeElement(nums: Array[Int], v: Int): Int = &#123; var ret = 0 for (i &lt;- 0 until nums.size) &#123; if (nums(i) != v) &#123; nums(ret) = nums(i) ret += 1 &#125; &#125; return ret &#125;&#125; 28. Implement strStrTags: Two Pointers, String C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Solution &#123;public: int strStr(string haystack, string needle) &#123; int ret1 = strStrBackoff(haystack, needle); int ret2 = strStrBruteForce(haystack, needle); int ret3 = strStrKMP(haystack, needle); cout &lt;&lt; ret1 &lt;&lt; " " &lt;&lt; ret2 &lt;&lt; " " &lt;&lt; ret3 &lt;&lt; endl; assert(ret1 == ret2 &amp;&amp; ret2 == ret3); return ret1; &#125; private: int strStrBruteForce(const string &amp;source, const string &amp;target) &#123; int src_len = static_cast&lt;int&gt;(source.size()); int tgt_len = static_cast&lt;int&gt;(target.size()); for (int i = 0; i &lt;= src_len - tgt_len; ++i) &#123; int j = 0; for ( ; j &lt; tgt_len &amp;&amp; source[i + j] == target[j]; ++j) &#123;&#125; if (j == tgt_len) &#123; return i; &#125; &#125; return -1; &#125; int strStrBackoff(const string &amp;source, const string &amp;target) &#123; int src_len = static_cast&lt;int&gt;(source.size()); int tgt_len = static_cast&lt;int&gt;(target.size()); int i = 0; int j = 0; for ( ; i &lt; src_len &amp;&amp; j &lt; tgt_len; ++i) &#123; if (source[i] == target[j]) &#123; ++j; &#125; else &#123; i -= j; j = 0; &#125; &#125; if (j == tgt_len) &#123; return i - tgt_len; &#125; return -1; &#125; int strStrKMP(string source, string target) &#123; if (target.empty()) &#123; return 0; &#125; auto getPattern = [](const string&amp; str) &#123; vector&lt;int&gt; pattern(str.length(), 0); int k = 0; for (size_t i = 1; i &lt; str.length(); ++i) &#123; while (k &gt; 0 &amp;&amp; str[k] != str[i]) &#123; k = pattern[k - 1]; &#125; if (str[k] == str[i]) &#123; ++k; &#125; pattern[i] = k; &#125; return pattern; &#125;; auto pattern = getPattern(target); int k = 0; for (size_t i = 0; i &lt; source.length(); ++i) &#123; while (k &gt; 0 &amp;&amp; source[i] != target[k]) &#123; k = pattern[k - 1]; &#125; if (source[i] == target[k]) &#123; ++k; &#125; if (k == target.length()) &#123; return i - k + 1; &#125; &#125; return -1; &#125;&#125;; Java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class Solution &#123; public int strStr(String haystack, String needle) &#123; int ret1 = strStrBruteForce(haystack, needle); int ret2 = strKMP(haystack, needle); int ret3 = strStrBackoff(haystack, needle); System.out.println("ret1 = " + ret1 + " ret2 = " + ret2 + " ret3 = " + ret3); assert ret1 == ret2; assert ret2 == ret3; return ret2; &#125; private int strStrBackoff(String source, String target) &#123; int i = 0; int j = 0; for ( ; i &lt; source.length() &amp;&amp; j &lt; target.length(); ) &#123; if (source.charAt(i) == target.charAt(j)) &#123; ++j; &#125; else &#123; i -= j; j = 0; &#125; ++i; &#125; if (j == target.length()) &#123; return i - j; &#125; return -1; &#125; private int strStrBruteForce(String source, String target) &#123; for (int i = 0; i &lt;= source.length() - target.length(); ++i) &#123; int j = 0; for ( ; j &lt; target.length() &amp;&amp; source.charAt(i + j) == target.charAt(j); ++j) &#123;&#125; if (j == target.length()) &#123; return i; &#125; &#125; return -1; &#125; private List&lt;Integer&gt; kmpPattern(String target) &#123; List&lt;Integer&gt; pattern = new ArrayList&lt;&gt;(Collections.nCopies(target.length(), 0)); int k = 0; for (int i = 1; i &lt; target.length(); ++i) &#123; while (k &gt; 0 &amp;&amp; target.charAt(k) != target.charAt(i)) &#123; k = pattern.get(k - 1); &#125; if (target.charAt(k) == target.charAt(i)) &#123; ++k; &#125; pattern.set(i, k); &#125; return pattern; &#125; private int strKMP(String source, String target) &#123; if (target.isEmpty()) &#123; return 0; &#125; List&lt;Integer&gt; pattern = kmpPattern(target); int k = 0; for (int i = 0; i &lt; source.length(); ++i) &#123; while (k &gt; 0 &amp;&amp; source.charAt(i) != target.charAt(k)) &#123; k = pattern.get(k - 1); &#125; if (source.charAt(i) == target.charAt(k)) &#123; ++k; &#125; if (k == target.length()) &#123; return i - k + 1; &#125; &#125; return -1; &#125;&#125; 33. Search in Rotated Sorted ArrayTags: Binary Search Cpp123456789101112131415161718192021222324252627class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0; int right = static_cast&lt;int&gt;(nums.size()) - 1; while (left &lt;= right) &#123; int mid = (right - left) / 2 + left; if (nums[mid] == target) &#123; return mid; &#125; if (nums[mid] &gt;= nums[left]) &#123; if (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; else &#123; if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; &#125; return -1; &#125;&#125;; Java1234567891011121314151617181920212223242526class Solution &#123; public int search(int[] nums, int target) &#123; int left = 0; int right = nums.length - 1; while (left &lt;= right) &#123; int mid = (right - left) / 2 + left; if (nums[mid] == target) &#123; return mid; &#125; if (nums[mid] &gt;= nums[left]) &#123; if (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; else &#123; if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; &#125; return -1; &#125;&#125; 34. Search for a RangeCpp12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; ret&#123;-1, -1&#125;; ret[0] = findLowerBound(nums, target); ret[1] = findUpperBound(nums, target); return ret; &#125;private: int findLowerBound(const vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0; int right = static_cast&lt;int&gt;(nums.size()) - 1; while (left &lt;= right) &#123; int mid = (right - left) / 2 + left; // move left to get first greater or equal than target if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; return nums[left] == target ? left : -1; &#125; int findUpperBound(const vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0; int right = static_cast&lt;int&gt;(nums.size()) - 1; while (left &lt;= right) &#123; int mid = (right - left) / 2 + left; // move right to get first less or equal than target if (nums[mid] &gt; target) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return nums[right] == target ? right : -1; &#125;&#125;; Java1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; int[] ret = &#123;-1, -1&#125;; ret[0] = lowerBound(nums, target); ret[1] = upperBound(nums, target); return ret; &#125; private int lowerBound(int[] nums, int target) &#123; int left = 0; int right = nums.length - 1; while (left &lt;= right) &#123; int mid = (right - left) / 2 + left; if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; if (nums[left] == target) &#123; return left; &#125; else &#123; return -1; &#125; &#125; private int upperBound(int[] nums, int target) &#123; int left = 0; int right = nums.length - 1; while (left &lt;= right) &#123; int mid = (right - left) / 2 + left; if (nums[mid] &gt; target) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; if (nums[right] == target) &#123; return right; &#125; else &#123; return -1; &#125; &#125;&#125; 39. Combination Sum Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.The same repeated number may be chosen from C unlimited number of times.Note:All numbers (including target) will be positive integers.The solution set must not contain duplicate combinations.For example, given candidate set [2, 3, 6, 7] and target 7,A solution set is:[ [7], [2, 2, 3]] Tags: Array, Backtracking C++123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt;&gt; ret; vector&lt;int&gt; cur; std::sort(candidates.begin(), candidates.end()); combinationSum(candidates, target, 0, ret, cur); return ret; &#125;private: void combinationSum(const vector&lt;int&gt;&amp; candidates, int target, size_t start, vector&lt;vector&lt;int&gt;&gt;&amp; ret, vector&lt;int&gt;&amp; cur) &#123; if (target == 0) &#123; ret.push_back(cur); &#125; else if (target &gt; 0 &amp;&amp; start &lt; candidates.size()) &#123; cur.push_back(candidates[start]); combinationSum(candidates, target - candidates[start], start, ret, cur); cur.pop_back(); combinationSum(candidates, target, start + 1, ret, cur); &#125; &#125;&#125;; Java12345678910111213141516171819202122232425class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); Arrays.sort(candidates); LinkedList&lt;Integer&gt; cur = new LinkedList&lt;&gt;(); combinationSum(ret, cur, candidates, target, 0); return ret; &#125; private void combinationSum( List&lt;List&lt;Integer&gt;&gt; ret, LinkedList&lt;Integer&gt; cur, int[] candidates, int target, int start) &#123; if (target == 0) &#123; ret.add(new ArrayList&lt;&gt;(cur)); &#125; else if (target &gt; 0 &amp;&amp; start &lt; candidates.length) &#123; cur.add(candidates[start]); combinationSum(ret, cur, candidates, target - candidates[start], start); cur.removeLast(); combinationSum(ret, cur, candidates, target, start + 1); &#125; &#125;&#125; 40. Combination Sum II Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.Each number in C may only be used once in the combination.Note:All numbers (including target) will be positive integers.The solution set must not contain duplicate combinations.For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,A solution set is:[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] Tags: Array, Dynamic Programming C++123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt;&gt; ret; vector&lt;int&gt; cur; std::sort(candidates.begin(), candidates.end()); combinationSum2(candidates, target, 0, ret, cur); return ret; &#125; private: void combinationSum2( const vector&lt;int&gt;&amp; candidates, int target, size_t start, vector&lt;vector&lt;int&gt;&gt;&amp; ret, vector&lt;int&gt;&amp; cur) &#123; if (target == 0) &#123; ret.push_back(cur); &#125; else if (target &gt; 0 &amp;&amp; start &lt; candidates.size()) &#123; cur.push_back(candidates[start]); combinationSum2(candidates, target - candidates[start], start + 1, ret, cur); cur.pop_back(); do &#123; ++start; &#125; while (start &gt; 0 &amp;&amp; start &lt; candidates.size() &amp;&amp; candidates[start] == candidates[start - 1]); combinationSum2(candidates, target, start, ret, cur); &#125; &#125;&#125;; Java123456789101112131415161718192021222324252627class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); LinkedList&lt;Integer&gt; cur = new LinkedList&lt;&gt;(); Arrays.sort(candidates); combinationSum2(ret, cur, candidates, target, 0); return ret; &#125; private void combinationSum2(List&lt;List&lt;Integer&gt;&gt; ret, LinkedList&lt;Integer&gt; cur, int[] candidates, int target, int start) &#123; if (target == 0) &#123; ret.add(new ArrayList&lt;&gt;(cur)); &#125; else if (target &gt; 0 &amp;&amp; start &lt; candidates.length) &#123; cur.add(candidates[start]); combinationSum2(ret, cur, candidates, target - candidates[start], start + 1); cur.removeLast(); do &#123; // remove duplicate results when same number of contiguous in candidates ++start; &#125; while (target &gt; 0 &amp;&amp; start &lt; candidates.length &amp;&amp; candidates[start] == candidates[start - 1]); combinationSum2(ret, cur, candidates, target, start); &#125; &#125;&#125; 46. PermutationsTags: Backtracking C++12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; ret; permute(ret, nums, 0); return ret; &#125;private: void permute(vector&lt;vector&lt;int&gt;&gt;&amp; ret, vector&lt;int&gt;&amp; nums, int start) &#123; if (start == nums.size()) &#123; ret.push_back(nums); &#125; else &#123; for (size_t i = start; i != nums.size(); ++i) &#123; swap(nums[start], nums[i]); permute(ret, nums, start + 1); swap(nums[start], nums[i]); &#125; &#125; &#125;&#125;; Java1234567891011121314151617181920class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); List&lt;Integer&gt; numList = Arrays.stream(nums).boxed().collect(Collectors.toList()); permute(ret, numList, 0); return ret; &#125; private void permute(List&lt;List&lt;Integer&gt;&gt; ret, List&lt;Integer&gt; nums, int start) &#123; if (start &gt;= nums.size()) &#123; ret.add(new ArrayList(nums)); &#125; else &#123; for (int i = start; i &lt; nums.size(); ++i) &#123; Collections.swap(nums, start, i); permute(ret, nums, start + 1); Collections.swap(nums, start, i); &#125; &#125; &#125;&#125; 47. Permutations IITags: Backtracking C++123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; ret; permutation(ret, nums, 0); return ret; &#125;private: void permutation(vector&lt;vector&lt;int&gt;&gt;&amp; ret, vector&lt;int&gt;&amp; nums, size_t start) &#123; if (start &gt;= nums.size()) &#123; ret.push_back(nums); &#125; else &#123; for (size_t idx = start; idx != nums.size(); ++idx) &#123; if (std::find(nums.begin() + start, nums.begin() + idx, nums[idx]) == (nums.begin() + idx)) &#123; swap(nums[idx], nums[start]); permutation(ret, nums, start + 1); swap(nums[idx], nums[start]); &#125; &#125; &#125; &#125;&#125;; Java1234567891011121314151617181920212223242526272829class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); List&lt;Integer&gt; numList = Arrays.stream(nums).boxed().collect(Collectors.toList()); permute(ret, numList, 0); return ret; &#125; private void permute(List&lt;List&lt;Integer&gt;&gt; ret, List&lt;Integer&gt; nums, int start) &#123; if (start &gt;= nums.size()) &#123; ret.add(new ArrayList(nums)); &#125; else &#123; for (int i = start; i &lt; nums.size(); ++i) &#123; int idx = start; for ( ; idx &lt; i; ++idx) &#123; if (nums.get(idx) == nums.get(i)) &#123; break; &#125; &#125; if (idx &lt; i) &#123; continue; &#125; Collections.swap(nums, start, i); permute(ret, nums, start + 1); Collections.swap(nums, start, i); &#125; &#125; &#125;&#125; 53. Maximum Subarray Find the contiguous subarray within an array (containing at least one number) which has the largest sum.For example, given the array [-2,1,-3,4,-1,2,1,-5,4],the contiguous subarray [4,-1,2,1] has the largest sum = 6. Tags: Array, Dynamic Programming C++12345678910111213141516class Solution &#123;public: // nums[i] may be part of current maxSubArray just start of new current maxSubArray int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) &#123; return 0; &#125; int cur_max = nums[0]; int ret = cur_max; for (int i = 1; i &lt; static_cast&lt;int&gt;(nums.size()); ++i) &#123; cur_max = std::max(cur_max + nums[i], nums[i]); ret = std::max(ret, cur_max); &#125; return ret; &#125;&#125;; Java123456789101112131415class Solution &#123; public int maxSubArray(int[] nums) &#123; if (nums.length == 0) &#123; return 0; &#125; int ret = nums[0]; int cur_max = nums[0]; for (int i = 1; i &lt; nums.length; ++i) &#123; // nums[i] is either part of cur_max sequence or start of a new one cur_max = Math.max(cur_max + nums[i], nums[i]); ret = Math.max(cur_max, ret); &#125; return ret; &#125;&#125; 94. Binary Tree Inorder TraversalTags: Tree C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; // return inorderTraversalIterative(root); return inorderTraversalMorris(root); &#125;private: vector&lt;int&gt; inorderTraversalMorris(TreeNode* root) &#123; vector&lt;int&gt; ret; if (root == nullptr) &#123; return ret; &#125; auto cur = root; while (cur != nullptr) &#123; if (cur-&gt;left == nullptr) &#123; ret.push_back(cur-&gt;val); cur = cur-&gt;right; &#125; else &#123; auto pre = cur-&gt;left; while (pre-&gt;right != nullptr &amp;&amp; pre-&gt;right != cur) &#123; pre = pre-&gt;right; &#125; if (pre-&gt;right == nullptr) &#123; pre-&gt;right = cur; cur = cur-&gt;left; &#125; else &#123; ret.push_back(cur-&gt;val); // move to if would make this preorderTraversal pre-&gt;right = nullptr; cur = cur-&gt;right; &#125; &#125; &#125; return ret; &#125; vector&lt;int&gt; inorderTraversalIterative(const TreeNode* root) &#123; vector&lt;int&gt; ret; if (root == nullptr) &#123; return ret; &#125; stack&lt;const TreeNode*&gt; stc; auto ptr = root; while (ptr != nullptr || !stc.empty()) &#123; if (ptr == nullptr) &#123; ptr = stc.top(); stc.pop(); ret.push_back(ptr-&gt;val); ptr = ptr-&gt;right; &#125; else &#123; stc.push(ptr); ptr = ptr-&gt;left; &#125; &#125; return ret; &#125;&#125;; Java12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); if (root == null) &#123; return ret; &#125; TreeNode cursor = root; Stack&lt;TreeNode&gt; stc = new Stack&lt;&gt;(); while (cursor != null || !stc.empty()) &#123; if (cursor == null) &#123; cursor = stc.peek(); stc.pop(); ret.add(cursor.val); cursor = cursor.right; &#125; else &#123; stc.push(cursor); cursor = cursor.left; &#125; &#125; return ret; &#125;&#125; 103. Binary Tree Zigzag Level Order TraversalTags: Tree, BFS C++12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; ret; if (root == nullptr) &#123; return ret; &#125; vector&lt;TreeNode*&gt; curLevel&#123;root&#125;; bool flag = false; while (!curLevel.empty()) &#123; vector&lt;TreeNode*&gt; nextLevel; vector&lt;int&gt; cur; cur.reserve(curLevel.size()); if (flag) &#123; for (auto itr = curLevel.rbegin(); itr != curLevel.rend(); ++itr) &#123; cur.push_back((*itr)-&gt;val); &#125; &#125; else &#123; for (auto itr = curLevel.begin();itr != curLevel.end(); ++itr) &#123; cur.push_back((*itr)-&gt;val); &#125; &#125; for (auto node : curLevel) &#123; if (node-&gt;left != nullptr) &#123; nextLevel.push_back(node-&gt;left); &#125; if (node-&gt;right != nullptr) &#123; nextLevel.push_back(node-&gt;right); &#125; &#125; flag = !flag; std::swap(curLevel, nextLevel); ret.push_back(std::move(cur)); &#125; return ret; &#125;&#125;; Java12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); if (root == null) &#123; return ret; &#125; List&lt;TreeNode&gt; curLevel = new ArrayList&lt;&gt;(); boolean flag = false; curLevel.add(root); while (!curLevel.isEmpty()) &#123; List&lt;TreeNode&gt; nextLevel = new ArrayList&lt;&gt;(); List&lt;Integer&gt; cur = new ArrayList&lt;&gt;(); if (flag) &#123; for (int i = curLevel.size() - 1; i &gt;= 0; --i) &#123; cur.add(curLevel.get(i).val); &#125; &#125; else &#123; for (TreeNode n : curLevel) &#123; cur.add(n.val); &#125; &#125; for (TreeNode node : curLevel) &#123; if (node.left != null) &#123; nextLevel.add(node.left); &#125; if (node.right != null) &#123; nextLevel.add(node.right); &#125; &#125; ret.add(new ArrayList&lt;&gt;(cur)); flag = !flag; curLevel = nextLevel; nextLevel = null; &#125; return ret; &#125;&#125; 112. Path Sum Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.For example:Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22. Tags: Tree, Backtracking C++1234567891011121314151617181920class Solution &#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; if (root == nullptr) &#123; return false; &#125; sum -= root-&gt;val; if (isLeaf(root)) &#123; return sum == 0; &#125; else &#123; return hasPathSum(root-&gt;left, sum) || hasPathSum(root-&gt;right, sum); &#125; &#125; private: inline bool isLeaf(const TreeNode* root) &#123; return root != nullptr &amp;&amp; root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr; &#125; &#125;; Java12345678910111213141516class Solution &#123; public boolean hasPathSum(TreeNode root, int sum) &#123; if (root == null) &#123; return false; &#125; if (isLeaf(root)) &#123; return sum == root.val; &#125; else &#123; return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val); &#125; &#125; private boolean isLeaf(TreeNode node) &#123; return node.left == null &amp;&amp; node.right == null; &#125;&#125; 113. Path Sum II Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.For example:Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ / \ 7 2 5 1return[ [5,4,11,2], [5,8,4,5]] Tags: Tree, Backtracking C++1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123; vector&lt;vector&lt;int&gt;&gt; ret; vector&lt;int&gt; path; pathSum(root, sum ,ret, path); return ret; &#125; private: void pathSum(const TreeNode* root, int sum, vector&lt;vector&lt;int&gt;&gt;&amp; ret, vector&lt;int&gt;&amp; path) &#123; if (root == nullptr) &#123; return; &#125; path.push_back(root-&gt;val); sum -= root-&gt;val; if (isLeaf(root) &amp;&amp; sum == 0) &#123; ret.push_back(path); &#125; else &#123; pathSum(root-&gt;left, sum, ret, path); pathSum(root-&gt;right, sum, ret, path); &#125; path.pop_back(); &#125; inline bool isLeaf(const TreeNode* root) &#123; return root != nullptr &amp;&amp; root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr; &#125;&#125;; Java12345678910111213141516171819202122232425262728class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123; List&lt;List&lt;Integer&gt;&gt; ret = new LinkedList&lt;&gt;(); LinkedList&lt;Integer&gt; cur = new LinkedList&lt;&gt;(); pathSum(ret, cur, root, sum); return ret; &#125; private void pathSum(List&lt;List&lt;Integer&gt;&gt; ret, LinkedList&lt;Integer&gt; cur, TreeNode root, int sum) &#123; if (root == null) &#123; return; &#125; sum -= root.val; cur.add(root.val); if (isLeaf(root) &amp;&amp; sum == 0) &#123; ret.add(new LinkedList&lt;&gt;(cur)); &#125; else &#123; pathSum(ret, cur, root.left, sum); pathSum(ret, cur, root.right, sum); &#125; cur.removeLast(); &#125; private boolean isLeaf(TreeNode root) &#123; return root != null &amp;&amp; root.left == null &amp;&amp; root.right == null; &#125; &#125; 121. Best Time to Buy and Sell Stock Say you have an array for which the ith element is the price of a given stock on day i.If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. Tags: Dynamic Programming C++123456789101112131415class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if (prices.empty()) &#123; return 0; &#125; int ret = 0; int last_min = prices[0]; for (size_t i = 1; i &lt; prices.size(); ++i) &#123; ret = std::max(prices[i] - last_min, ret); last_min = std::min(prices[i], last_min); &#125; return ret; &#125;&#125;; Java1234567891011121314class Solution &#123; public int maxProfit(int[] prices) &#123; if (prices.length &lt;= 0) &#123; return 0; &#125; int ret = 0; int curMin = prices[0]; for (int i = 1; i &lt; prices.length; ++i) &#123; ret = Math.max(ret, prices[i] - curMin); curMin = Math.min(prices[i], curMin); &#125; return ret; &#125;&#125; 122. Best Time to Buy and Sell Stock II Say you have an array for which the ith element is the price of a given stock on day i.Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). Tags: Greedy C++1234567891011class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int ret = 0; for (size_t i = 1; i &lt; prices.size(); ++i) &#123; auto tmp = prices[i] - prices[i - 1]; ret += (tmp &gt; 0 ? tmp : 0); &#125; return ret; &#125;&#125;; Java123456789101112class Solution &#123; public int maxProfit(int[] prices) &#123; if (prices.length &lt;= 0) &#123; return 0; &#125; int ret = 0; for (int i = 1; i &lt; prices.length; ++i) &#123; ret += Math.max(prices[i] - prices[i - 1], 0); &#125; return ret; &#125;&#125; 144. Binary Tree Preorder TraversalTags: Tree C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; //return preorderTraversalIterative(root); return preorderTraversalMorris(root); &#125;private: vector&lt;int&gt; preorderTraversalMorris(TreeNode* root) &#123; vector&lt;int&gt; ret; if (root == nullptr) &#123; return ret; &#125; // swap left and right and ret make it postorderTraversal auto cur = root; while (cur != nullptr) &#123; if (cur-&gt;left == nullptr) &#123; ret.push_back(cur-&gt;val); cur = cur-&gt;right; &#125; else &#123; auto pre = cur-&gt;left; while (pre-&gt;right != nullptr &amp;&amp; pre-&gt;right != cur) &#123; pre = pre-&gt;right; &#125; if (pre-&gt;right == nullptr) &#123; ret.push_back(cur-&gt;val); // move it to else make this inorderTraversa; pre-&gt;right = cur; cur = cur-&gt;left; &#125; else &#123; pre-&gt;right = nullptr; cur = cur-&gt;right; &#125; &#125; &#125; return ret; &#125; vector&lt;int&gt; preorderTraversalIterative(const TreeNode* root) &#123; vector&lt;int&gt; ret; if (root == nullptr) &#123; return ret; &#125; stack&lt;const TreeNode*&gt; stc; auto ptr = root; while (ptr != nullptr || !stc.empty()) &#123; if (ptr == nullptr) &#123; ptr = stc.top(); stc.pop(); &#125; ret.push_back(ptr-&gt;val); if (ptr-&gt;right != nullptr) &#123; stc.push(ptr-&gt;right); &#125; ptr = ptr-&gt;left; &#125; return ret; &#125;&#125;; Java12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); if (root == null) &#123; return ret; &#125; TreeNode cursor = root; Stack&lt;TreeNode&gt; stc = new Stack&lt;&gt;(); while (cursor != null || !stc.empty()) &#123; if (cursor == null) &#123; cursor = stc.peek(); stc.pop(); &#125; ret.add(cursor.val); if (cursor.right != null) &#123; stc.push(cursor.right); &#125; cursor = cursor.left; &#125; return ret; &#125;&#125; 145. Binary Tree Postorder TraversalTags: Tree C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; //return postorderTraversalIterative(root); return postorderTraversalMorris(root); &#125;private: vector&lt;int&gt; postorderTraversalMorris(TreeNode* root) &#123; vector&lt;int&gt; ret; if (root == nullptr) &#123; return ret; &#125; // swap preorder's left and right and reverse ret makes this postorderTraversal auto cur = root; while (cur != nullptr) &#123; if (cur-&gt;right == nullptr) &#123; ret.push_back(cur-&gt;val); cur = cur-&gt;left; &#125; else &#123; auto pre = cur-&gt;right; while (pre-&gt;left != nullptr &amp;&amp; pre-&gt;left != cur) &#123; pre = pre-&gt;left; &#125; if (pre-&gt;left == nullptr) &#123; ret.push_back(cur-&gt;val); pre-&gt;left = cur; cur = cur-&gt;right; &#125; else &#123; pre-&gt;left = nullptr; cur = cur-&gt;left; &#125; &#125; &#125; reverse(ret.begin(), ret.end()); return ret; &#125; vector&lt;int&gt; postorderTraversalIterative(const TreeNode* root) &#123; vector&lt;int&gt; ret; if (root == nullptr) &#123; return ret; &#125; // swap preorder's left and right and reverse ret makes this postorderTraversal stack&lt;const TreeNode*&gt; stc; auto ptr = root; while (ptr != nullptr || !stc.empty()) &#123; if (ptr == nullptr) &#123; ptr = stc.top(); stc.pop(); &#125; ret.push_back(ptr-&gt;val); if (ptr-&gt;left != nullptr) &#123; stc.push(ptr-&gt;left); &#125; ptr = ptr-&gt;right; &#125; reverse(ret.begin(), ret.end()); return ret; &#125;&#125;; Java123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); if (root == null) &#123; return ret; &#125; // swap preorder's left and right and reverse ret makes this postorderTraversal TreeNode cursor = root; Stack&lt;TreeNode&gt; stc = new Stack&lt;&gt;(); while (cursor != null || !stc.empty()) &#123; if (cursor == null) &#123; cursor = stc.peek(); stc.pop(); &#125; ret.add(cursor.val); if (cursor.left != null) &#123; stc.push(cursor.left); &#125; cursor = cursor.right; &#125; Collections.reverse(ret); return ret; &#125;&#125; 152. Maximum Product Subarray Find the contiguous subarray within an array (containing at least one number) which has the largest product.For example, given the array [2,3,-2,4],the contiguous subarray [2,3] has the largest product = 6. Tags: Array, Dynamic Programming C++12345678910111213141516171819202122class Solution &#123;public: // num[i] is eithor end of last maxProduct or last minProduct // or start of new maxProduct or minProduct // cur_max = max(cur_max * nums[i], cur_min * nums[i], nums[i]) // cur_min = min(cur_max * nums[i], cur_min * nums[i], nums[i]) int maxProduct(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) &#123; return 0; &#125; int cur_max = nums[0]; int cur_min = nums[0]; int ret = cur_max; for (int i = 1; i &lt; static_cast&lt;int&gt;(nums.size()); ++i) &#123; int tmp = cur_max; cur_max = std::max(cur_max * nums[i], std::max(cur_min * nums[i], nums[i])); cur_min = std::min(tmp * nums[i], std::min(cur_min * nums[i], nums[i])); ret = std::max(cur_max, ret); &#125; return ret; &#125;&#125;; Java12345678910111213141516171819class Solution &#123; public int maxProduct(int[] nums) &#123; if (nums.length == 0) &#123; return 0; &#125; int ret = nums[0]; int cur_min = ret; int cur_max = ret; for (int i = 1; i &lt; nums.length; ++i) &#123; int tmp = cur_min; // num[i] is either part of cur_min sequnce or cur_max sequnce or start of new, // and the cur_min or cur_max would be flipped when encounter negtive number. cur_min = Math.min(Math.min(nums[i], cur_min * nums[i]), cur_max * nums[i]); cur_max = Math.max(Math.max(nums[i], cur_max * nums[i]), tmp * nums[i]); ret = Math.max(cur_max, ret); &#125; return ret; &#125;&#125; 173. Binary Search Tree Iterator mplement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.Calling next() will return the next smallest number in the BST.Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree. Tags: Tree C++123456789101112131415161718192021222324252627282930313233343536/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class BSTIterator &#123;public: BSTIterator(TreeNode *root) &#123; for ( ; root != nullptr; root = root-&gt;left) &#123; stc.push(root); &#125; &#125; /** @return whether we have a next smallest number */ bool hasNext() &#123; return !stc.empty(); &#125; /** @return the next smallest number */ int next() &#123; auto ret = stc.top()-&gt;val; auto ptr = stc.top()-&gt;right; stc.pop(); for ( ; ptr != nullptr; ptr = ptr-&gt;left) &#123; stc.push(ptr); &#125; return ret; &#125;private: stack&lt;TreeNode*&gt; stc;&#125;; Java123456789101112131415161718192021222324252627282930313233343536/** * Definition for binary tree * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class BSTIterator &#123; public BSTIterator(TreeNode root) &#123; for ( ; root != null; root = root.left) &#123; stc.push(root); &#125; &#125; /** @return whether we have a next smallest number */ public boolean hasNext() &#123; return !stc.empty(); &#125; /** @return the next smallest number */ public int next() &#123; int ret = stc.peek().val; TreeNode cursor = stc.peek().right; stc.pop(); for ( ; cursor != null; cursor = cursor.left) &#123; stc.push(cursor); &#125; return ret; &#125; private Stack&lt;TreeNode&gt; stc = new Stack&lt;&gt;();&#125; 236. Lowest Common Ancestor of a Binary TreeTags: Tree C++123456789101112131415161718192021class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if (root == nullptr || root == p || root == q) &#123; return root; &#125; // find lca node or at least one of (p, q) in left and right subtree auto left = lowestCommonAncestor(root-&gt;left, p, q); auto right = lowestCommonAncestor(root-&gt;right, p, q); // if both left and right are not null (p, q) must exist in left and right that root // is the lca; if left or right is null, lca is in another subtree (right or left). if (left == nullptr) &#123; return right; &#125; else if (right == nullptr) &#123; return left; &#125; else &#123; return root; &#125; &#125;&#125;; Java1234567891011121314151617181920class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if (root == null || root == p || root == q) &#123; return root; &#125; // find lca node or at least one of (p, q) in left and right subtree TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); // if both left and right are not null (p, q) must exist in left and right that root // is the lca; if left or right is null, lca is in another subtree (right or left). if (left == null) &#123; return right; &#125; else if (right == null) &#123; return left; &#125; else &#123; return root; &#125; &#125;&#125; 264. Ugly Number II Write a program to find the n-th ugly number.Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.Note that 1 is typically treated as an ugly number, and n does not exceed 1690. Tags: Array, Dynamic Programming C++123456789101112131415161718192021class Solution &#123;public: int nthUglyNumber(int n) &#123; std::array&lt;int, 3&gt; base&#123;2, 3, 5&#125;; std::array&lt;size_t, 3&gt; index&#123;1, 1, 1&#125;; std::vector&lt;int&gt; ret(n + 1, 1); for (size_t i = 2; i &lt;= n; ++i) &#123; auto cur_min = std::numeric_limits&lt;int&gt;::max(); for (size_t j = 0; j &lt; base.size(); ++j) &#123; cur_min = std::min(cur_min, base.at(j) * ret.at(index.at(j))); &#125; for (size_t j = 0; j &lt; base.size(); ++j) &#123; if (cur_min == base.at(j) * ret.at(index.at(j))) &#123; ++index[j]; &#125; &#125; ret[i] = cur_min; &#125; return ret.at(n); &#125;&#125;; Java1234567891011121314151617181920212223class Solution &#123; public int nthUglyNumber(int n) &#123; List&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); for (int i = 0; i &lt;= n; ++i) &#123; ret.add(1); &#125; int base[] = &#123;2, 3, 5&#125;; int index[] = &#123;1, 1, 1&#125;; for (int i = 2; i &lt;= n; ++i) &#123; int cur_min = Integer.MAX_VALUE; for (int j = 0; j &lt; 3; ++j) &#123; cur_min = Math.min(cur_min, base[j] * ret.get(index[j])); &#125; for (int j = 0; j &lt; 3; ++j) &#123; if (cur_min == base[j] * ret.get(index[j])) &#123; ++index[j]; &#125; &#125; ret.set(i, cur_min); &#125; return ret.get(n); &#125;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F11%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy Generate and Deploy1$ hexo g -d More info: Deployment Test Insert Image:]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
