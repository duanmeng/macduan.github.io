<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode using C++ and Java (keep updating ...)]]></title>
    <url>%2F2017%2F11%2F04%2FLeetCode%20with%20C%2B%2B%20and%20Java%20and%20little%20scala%2F</url>
    <content type="text"><![CDATA[Give C++ and Java solution and scala (immutable style) solution sometimes. 1. Two Sum Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution, and you may not use the same element twice. Example:Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. Tags: Array, HashTable C++123456789101112131415class Solution &#123; // (both index1 and index2) are not zero-based.public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, size_t&gt; umap; for (size_t i = 0; i &lt; nums.size(); ++i) &#123; auto item = nums[i]; if (umap.find(target - item) == umap.end()) &#123; umap[item] = i; &#125; else &#123; return vector&lt;int&gt;&#123;umap[target - item], i&#125;; &#125; &#125; return vector&lt;int&gt;&#123;-1, -1&#125;; &#125;&#125;; Java1234567891011121314public class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; hm = new HashMap&lt;&gt;(); for (int i = 0; i != nums.length; ++i) &#123; int complement = target - nums[i]; if (hm.get(complement) != null) &#123; return new int[] &#123;hm.get(complement), i&#125;; &#125; else &#123; hm.put(nums[i], i); &#125; &#125; return null; &#125;&#125; Scala1234567891011121314object Solution &#123; def twoSum(nums: Array[Int], target: Int): Array[Int] = &#123; var ht = collection.mutable.Map.empty[Int, Int] for (i &lt;- 0 until nums.size) &#123; val tmp = target - nums(i) if (ht.contains(tmp)) &#123; return Array(ht(tmp), i) &#125; else &#123; ht(nums(i)) = i &#125; &#125; Array(-1, -1) &#125;&#125; 2. Add Two Numbers You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself.Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 Tags: Linked List, Math C++12345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode dummy(-1); ListNode* ptr = &amp;dummy; int carry = 0; while (l1 != nullptr || l2 != nullptr) &#123; int a = 0; if (l1 != nullptr) &#123; a = l1-&gt;val; l1 = l1-&gt;next; &#125; int b = 0; if (l2 != nullptr) &#123; b = l2-&gt;val; l2 = l2-&gt;next; &#125; int sum = a + b + carry; carry = sum / 10; ptr-&gt;next = new ListNode(sum % 10); ptr = ptr-&gt;next; &#125; if (carry &gt; 0) &#123; ptr-&gt;next = new ListNode(carry); &#125; return dummy.next; &#125;&#125;; Java123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; int carrier = 0; ListNode dummy = new ListNode(0); ListNode cur = dummy; while (l1 != null || l2 != null) &#123; int x = l1 == null ? 0 : l1.val; int y = l2 == null ? 0 : l2.val; int val = x + y + carrier; carrier = val / 10; cur.next = new ListNode(val % 10); cur = cur.next; if (l1 != null) &#123; l1 = l1.next; &#125; if (l2 != null) &#123; l2 = l2.next; &#125; &#125; if (carrier &gt; 0) &#123; cur.next = new ListNode(carrier); &#125; return dummy.next; &#125;&#125; Scala123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * class ListNode(var _x: Int = 0) &#123; * var next: ListNode = null * var x: Int = _x * &#125; */object Solution &#123; def addTwoNumbers(l1: ListNode, l2: ListNode): ListNode = &#123; var dummyNode = new ListNode(0) var cur = dummyNode var carry = 0 def addInternal(l1: ListNode, l2: ListNode): Unit = &#123; if (l1 != null || l2 != null) &#123; var a = if (l1 != null) l1.x else 0 var b = if (l2 != null) l2.x else 0 var sum = a + b + carry cur.next = new ListNode(sum % 10) cur = cur.next carry = sum / 10 addInternal(if (l1 != null) l1.next else null, if(l2 != null) l2.next else null) &#125; &#125; addInternal(l1, l2) if (carry &gt; 0) &#123; cur.next = new ListNode(carry) &#125; dummyNode.next &#125;&#125; 3. Longest Substring Without Repeating Characters Given a string, find the length of the longest substring without repeating characters. Examples:Given “abcabcbb”, the answer is “abc”, which the length is 3.Given “bbbbb”, the answer is “b”, with the length of 1.Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring. Tags: Hash Table, Two Pointers, String C++123456789101112131415161718class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int ret = 0; vector&lt;int&gt; ht(256, -1); int i = 0; for (int j = 0; j &lt; s.size(); ++j) &#123; auto k = ht[s[j]]; if (k &gt;= i) &#123; i = k + 1; &#125; else &#123; ret = std::max(ret, j - i + 1); &#125; ht[s[j]] = j; &#125; return ret; &#125;&#125;; Java1234567891011121314151617public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int ret = 0; Map&lt;Character, Integer&gt; hm = new HashMap&lt;&gt;(); int i = 0; for (int j = 0; j &lt; s.length(); ++j) &#123; int k = hm.getOrDefault(s.charAt(j), -1); if (k &gt;= i) &#123; i = k + 1; &#125; else &#123; ret = Math.max(ret, j - i + 1); &#125; hm.put(s.charAt(j), j); &#125; return ret; &#125;&#125; 4. Median of Two Sorted Arrays There are two sorted arrays nums1 and nums2 of size m and n respectively.Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). Example 1:nums1 = [1, 3]nums2 = [2]The median is 2.0 Example 2:nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 Tags: Divide and Conquer, Binary Search, Array C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; auto sz = nums1.size() + nums2.size(); if (sz &amp; 0x01) &#123; auto ret = findKthElement(begin(nums1), nums1.size(), begin(nums2), nums2.size(), sz / 2 + 1); //auto ret = findKthElement(nums1.data(), nums1.size(), nums2.data(), nums2.size(), sz / 2 + 1); return static_cast&lt;double&gt;(ret); &#125; else &#123; auto ret1 = findKthElement(begin(nums1), nums1.size(), begin(nums2), nums2.size(), sz / 2); auto ret2 = findKthElement(begin(nums1), nums1.size(), begin(nums2), nums2.size(), sz / 2 + 1); //auto ret1 = findKthElement(nums1.data(), nums1.size(), nums2.data(), nums2.size(), sz / 2); //auto ret2 = findKthElement(nums1.data(), nums1.size(), nums2.data(), nums2.size(), sz / 2 + 1); return (static_cast&lt;double&gt;(ret1) + static_cast&lt;double&gt;(ret2)) / 2.0; &#125; &#125; private: int findKthElement(const int* nums1, size_t len1, const int* nums2, size_t len2, size_t k) &#123; if (len1 &gt; len2) &#123; return findKthElement(nums2, len2, nums1, len1, k); &#125; if (len1 == 0) &#123; return nums2[k - 1]; &#125; if (k == 1) &#123; return min(nums1[k - 1], nums2[k - 1]); &#125; auto dis1 = min(k / 2, len1); auto dis2 = k - dis1; if (nums1[dis1 - 1] &lt; nums2[dis2 - 1]) &#123; return findKthElement(nums1 + dis1, len1 - dis1, nums2, len2, k - dis1); &#125; else if (nums1[dis1 - 1] &gt; nums2[dis2 - 1]) &#123; return findKthElement(nums1, len1, nums2 + dis2, len2 - dis2, k - dis2); &#125; else &#123; return nums1[dis1 - 1]; &#125; return -1; &#125; int findKthElement(vector&lt;int&gt;::const_iterator begin_1, size_t len_1, vector&lt;int&gt;::const_iterator begin_2, size_t len_2, size_t k) &#123; if (len_1 &gt; len_2) &#123; return findKthElement(begin_2, len_2, begin_1, len_1, k); &#125; if (len_1 == 0) &#123; return *(begin_2 + k - 1); &#125; if (k == 1) &#123; return std::min(*begin_1, *begin_2); &#125; auto dis_1 = std::min(k / 2, len_1); auto dis_2 = k - dis_1; if (*(begin_1 + dis_1 - 1) &lt; *(begin_2 + dis_2 - 1)) &#123; return findKthElement(begin_1 + dis_1, len_1 - dis_1, begin_2, len_2, k - dis_1); &#125; else if (*(begin_1 + dis_1 - 1) &gt; *(begin_2 + dis_2 - 1)) &#123; return findKthElement(begin_1, len_1, begin_2 + dis_2, len_2 - dis_2, k - dis_2); &#125; else &#123; return *(begin_1 + dis_1 - 1); &#125; return -1; &#125;&#125;; Java123456789101112131415161718192021222324252627282930313233public class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int len = nums1.length + nums2.length; if ((len &amp; 0x01) == 0x01) &#123; return findKthElement(nums1, 0, nums2, 0, len / 2 + 1); &#125; else &#123; double left = findKthElement(nums1, 0, nums2, 0, len / 2); double right = findKthElement(nums1, 0, nums2, 0, len / 2 + 1); return (left + right) / 2.0; &#125; &#125; private double findKthElement(int[] nums1, int start1, int[] nums2, int start2, int k) &#123; if ((nums1.length - start1) &gt; (nums2.length - start2)) &#123; return findKthElement(nums2, start2, nums1, start1, k); &#125; if ((nums1.length - start1) &lt;= 0) &#123; return (double) nums2[start2 + k - 1]; &#125; if (k == 1) &#123; return Math.min((double) nums1[start1], (double) nums2[start2]); &#125; int dis1 = Math.min(k / 2, nums1.length - start1); int dis2 = k - dis1; if (nums1[start1 + dis1 - 1] &lt; nums2[start2 + dis2 - 1]) &#123; return findKthElement(nums1, start1 + dis1, nums2, start2, k - dis1); &#125; else if (nums1[start1 + dis1 - 1] &gt; nums2[start2 + dis2 - 1]) &#123; return findKthElement(nums1, start1, nums2, start2 + dis2, k - dis2); &#125; else &#123; return (double) nums1[start1 + dis1 - 1]; &#125; &#125;&#125; 5. Longest Palindromic Substring Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example:Input: “babad”Output: “bab”Note: “aba” is also a valid answer. Example:Input: “cbbd”Output: “bb” Tags String 注意C++的substr和Java的substring的区别 C++1234567891011121314151617181920212223242526272829class Solution &#123;public: string longestPalindrome(string s) &#123; int start = 0; int len = 1; for (int i = 0; i &lt; s.length(); ++i) &#123; auto cur = _getLongestPalindromeLength(s, i); if (cur &gt; len) &#123; len = cur; start = i - (len - 1) / 2; &#125; &#125; return s.substr(start, len); &#125; private: inline int _getLongestPalindromeLength(const string &amp;s, int i) &#123; return max(_getLongestPalindromeLength(s, i, i), _getLongestPalindromeLength(s, i, i + 1)); &#125; inline int _getLongestPalindromeLength(const string &amp;s, int left, int right) &#123; while (left &gt;= 0 &amp;&amp; right &lt; static_cast&lt;int&gt;(s.length()) &amp;&amp; s[left] == s[right]) &#123; --left; ++right; &#125; return right - left - 1; &#125; &#125;; Java1234567891011121314151617181920212223242526public class Solution &#123; public String longestPalindrome(String s) &#123; int len = 1; int start = 0; for (int i = 0; i &lt; s.length(); ++i) &#123; int cur = getLongestPalindromeLength(s, i); if (cur &gt; len) &#123; len = cur; start = i - (len - 1) / 2; &#125; &#125; return s.substring(start, start + len); &#125; private int getLongestPalindromeLength(String s, int i) &#123; return Math.max(getLongestPalindromeLength(s, i, i), getLongestPalindromeLength(s, i, i + 1)); &#125; private int getLongestPalindromeLength(String s, int left, int right) &#123; while (left &gt;= 0 &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123; --left; ++right; &#125; return right - left - 1; &#125;&#125; 6. ZigZag Conversion The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)P A H NA P L S I I GY I RAnd then read line by line: “PAHNAPLSIIGYIR”Write the code that will take a string and make this conversion given a number of rows:string convert(string text, int nRows);convert(“PAYPALISHIRING”, 3) should return “PAHNAPLSIIGYIR”. Tags: string C++123456789101112131415161718192021222324class Solution &#123;public: string convert(string s, int numRows) &#123; if (numRows &lt;= 1 || numRows &gt;= static_cast&lt;int&gt;(s.size())) &#123; return s; &#125; vector&lt;string&gt; ret(numRows, ""); int row_cursor = 0; int step = 0; for (size_t idx = 0; idx != s.size(); ++idx) &#123; ret[row_cursor].push_back(s[idx]); if (row_cursor == 0) &#123; step = 1; &#125; else if (row_cursor == numRows - 1) &#123; step = -1; &#125; row_cursor += step; // update row_cursor &#125; string result; result.reserve(numRows); for_each(ret.begin(), ret.end(), [&amp;result](string&amp; item) &#123; result += std::move(item); &#125;); return result; &#125;&#125;; Java1234567891011121314151617181920212223242526public class Solution &#123; public String convert(String s, int numRows) &#123; if (s.isEmpty() || numRows ==1 || numRows &gt;= s.length()) &#123; return s; &#125; ArrayList&lt;StringBuilder&gt; ret = new ArrayList&lt;&gt;(Collections.nCopies(numRows, null)); int idx = 0; int step = 0; for (int i = 0; i &lt; s.length(); ++i) &#123; if (ret.get(idx) == null) &#123; ret.set(idx, new StringBuilder()); &#125; ret.get(idx).append(s.charAt(i)); if (idx == numRows - 1) &#123; step = -1; &#125; else if (idx == 0) &#123; step = 1; &#125; idx += step; &#125; for (int i = 1; i &lt; ret.size(); ++i) &#123; ret.get(0).append(ret.get(i)); &#125; return ret.get(0).toString(); &#125;&#125; 7. Reverse Integer Reverse digits of an integer.Example1: x = 123, return 321Example2: x = -123, return -321 Tags: Math C++1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int reverse(int x) &#123; int ret = 0; for ( ; x != 0; x /= 10) &#123; int tail = x % 10; int tmp = ret * 10 + tail; if ((tmp - tail) / 10 != ret) &#123; // overflow return 0; &#125; ret = tmp; &#125; return ret; &#125;&#125;;class Solution &#123;public: int reverse(int x) &#123; int flag = x &lt; 0 ? -1 : 1; int ret = 0; while (x != 0) &#123; int cur = (x % 10) * flag; if (ret &gt; INT_MAX / 10 || (ret == INT_MAX / 10 &amp;&amp; cur &gt; INT_MAX % 10)) &#123; return 0; &#125; ret = 10 * ret + cur; x /= 10; &#125; return flag * ret; &#125;&#125;; Java123456789101112131415161718192021222324252627282930public class Solution &#123; public int reverse(int x) &#123; int ret = 0; for ( ; x != 0; x /= 10) &#123; int tail = x % 10; int tmp = ret * 10 + tail; if ((tmp - tail) / 10 != ret) &#123; return 0; &#125; ret = tmp; &#125; return ret; &#125;&#125;public class Solution &#123; public int reverse(int x) &#123; int ret = 0; int flag = x &lt; 0 ? -1 : 1; while (x != 0) &#123; int cur = (x % 10) * flag; if (ret &gt; Integer.MAX_VALUE / 10 || (ret == Integer.MAX_VALUE / 10 &amp;&amp; cur &gt; Integer.MAX_VALUE % 10)) &#123; return 0; &#125; ret = 10 * ret + cur; x /= 10; &#125; return flag * ret; &#125;&#125; 8. String to Integer (atoi) Implement atoi to convert a string to an integer.Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases. Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. Tags: Math, String C++123456789101112131415161718192021222324252627class Solution &#123;public: int myAtoi(string str) &#123; int ret = 0; auto int_max = std::numeric_limits&lt;int&gt;::max(); auto int_min = std::numeric_limits&lt;int&gt;::min(); auto iter = std::begin(str); while (*iter == ' ') &#123; ++iter; &#125; bool negative = false; if (*iter == '-' || *iter == '+') &#123; if(*iter == '-') &#123; negative = true; &#125; ++iter; &#125; for ( ; iter != std::end(str) &amp;&amp; std::isdigit(*iter); ++iter) &#123; int cur = *iter - '0'; if (ret &gt; int_max / 10 || (ret == int_max / 10 &amp;&amp; cur &gt; int_max % 10)) &#123; return negative ? int_min : int_max; &#125; ret = ret * 10 + cur; &#125; return negative ? -ret : ret; &#125;&#125;; Java123456789101112131415161718192021222324252627282930public class Solution &#123; public int myAtoi(String str) &#123; int ret = 0; boolean negative = false; int idx = 0; // deal empty string which not the same as C++ and String is iteratable (java Collections) if (str.isEmpty()) &#123; return ret; &#125; // remove leading space for ( ; str.charAt(idx) == ' '; ++idx) &#123;&#125; // get flag if (str.charAt(idx) == '+' || str.charAt(idx) == '-') &#123; negative = (str.charAt(idx) == '-' ? true : false); ++idx; &#125; // parsing digit chars for ( ; idx &lt; str.length(); ++idx) &#123; int cur = str.charAt(idx) - '0'; if (cur &lt; 0 || cur &gt; 9) &#123; break; &#125; if (ret &gt; Integer.MAX_VALUE / 10 || (ret == Integer.MAX_VALUE / 10 &amp;&amp; Integer.MAX_VALUE % 10 &lt; cur)) &#123; return negative ? Integer.MIN_VALUE : Integer.MAX_VALUE; &#125; ret = ret * 10 + cur; &#125; return negative ? -ret : ret; &#125;&#125; 9. Palindrome NumberTags: String Cpp123456789class Solution &#123;public: bool isPalindrome(int x) &#123; string s1 = std::move(std::to_string(x)); string s2(s1); reverse(s1.begin(), s1.end()); return s1 == s2; &#125;&#125;; Java1234567public class Solution &#123; public boolean isPalindrome(int x) &#123; String a = String.valueOf(x); String b = (new StringBuilder(a)).reverse().toString(); return a.equals(b); &#125;&#125; 10. Regular Expression Matching Implement regular expression matching with support for ‘.’ and ‘*‘.‘.’ Matches any single character.‘*‘ Matches zero or more of the preceding element.The matching should cover the entire input string (not partial).The function prototype should be:bool isMatch(const char s, const char p) Some examples:isMatch(“aa”,”a”) ? falseisMatch(“aa”,”aa”) ? trueisMatch(“aaa”,”aa”) ? falseisMatch(“aa”, “a“) ? trueisMatch(“aa”, “.“) ? trueisMatch(“ab”, “.“) ? trueisMatch(“aab”, “ca*b”) ? true Tag: String, Dynamic Programming, Backtracking Use Dynamic ProgrammingCpp12345678910111213141516171819202122232425262728293031class Solution &#123;public: bool isMatch(string s, string p) &#123; // last char is the key postion, which may be '*' or not // match[i][j] record the s[0 : i - 1] matched p[0 : j - 1] so // match[0][0] = true, match[1 : ][0] = false, match[0][1 : ] = (j &gt; 1 &amp;&amp; match[0][j - 2] &amp;&amp; p[j - 1] == '*') // match[i][j] = p[j - 1] != '*' &amp;&amp; (match[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == '.')) // match[i][j] = p[j - 1] == '*' &amp;&amp; (match[i][j - 2] || (match[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 1] == '.'))) vector&lt;vector&lt;bool&gt;&gt; match(s.length() + 1, vector&lt;bool&gt;(p.length() + 1, false)); match[0][0] = true; for (size_t i = 1; i &lt; match.size(); ++i) &#123; match[i][0] = false; &#125; for (size_t j = 1; j &lt; match[0].size(); ++j) &#123; match[0][j] = (j &gt; 1) &amp;&amp; match[0][j - 2] &amp;&amp; (p[j - 1] == '*'); &#125; for (size_t i = 1; i &lt; match.size(); ++i) &#123; for (size_t j = 1; j &lt; match[0].size(); ++j) &#123; if (p[j - 1] != '*') &#123; match[i][j] = match[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == '.'); &#125; else &#123; // p[j - 1] is '*' so p[j - 2] must exist and match[i - 1][j] covers match[i - 1][j - 2] match[i][j] = match[i][j - 2] || (match[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 2] == '.')); &#125; &#125; &#125; return match.back().back(); &#125;&#125;; Java123456789101112131415161718192021222324252627282930public class Solution &#123; public boolean isMatch(String s, String p) &#123; // last char is the key postion, which may be '*' or not // match[i][j] record the s[0 : i - 1] matched p[0 : j - 1] so // match[0][0] = true, match[1 : ][0] = false, match[0][1 : ] = (j &gt; 1 &amp;&amp; match[0][j - 2] &amp;&amp; p[j - 1] == '*') // match[i][j] = p[j - 1] != '*' &amp;&amp; (match[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == '.')) // match[i][j] = p[j - 1] == '*' &amp;&amp; (match[i][j - 2] || (match[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 1] == '.'))) boolean[][] match = new boolean[s.length() + 1][p.length() + 1]; match[0][0] = true; for (int i = 1; i &lt; match.length; ++i) &#123; match[i][0] = false; &#125; for (int j = 1; j &lt; match[0].length; ++j) &#123; match[0][j] = (j &gt; 1) &amp;&amp; match[0][j - 2] &amp;&amp; p.charAt(j - 1) == '*'; &#125; for (int i = 1; i &lt; match.length; ++i) &#123; for (int j = 1; j &lt; match[0].length; ++j) &#123; if (p.charAt(j - 1) != '*') &#123; match[i][j] = match[i - 1][j - 1] &amp;&amp; (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.'); &#125; else &#123; // p[j - 1] is '*' so p[j - 2] must exist and match[i - 1][j] covers match[i - 1][j - 2] match[i][j] = match[i][j - 2] || (match[i - 1][j] &amp;&amp; (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.')); &#125; &#125; &#125; return match[s.length()][p.length()]; &#125;&#125; Use Backtracking123456789101112131415161718192021222324class Solution &#123;public: bool isMatch(string s, string p) &#123; return isMatch(s.c_str(), p.c_str()); &#125;private: // use c++ string's feature (end with '\0') to avoid some condition check in java inline bool charMatch(const char *s, const char *p) &#123; return (*s == *p || (*p == '.' &amp;&amp; *s != '\0')); &#125; bool isMatch(const char *s, const char *p) &#123; if (*p == '\0') &#123; return *s == '\0'; &#125; if (*(p + 1) != '*') &#123; return charMatch(s, p) &amp;&amp; isMatch(s + 1, p + 1); &#125; else if (charMatch(s, p)) &#123; return isMatch(s + 1, p) || isMatch(s, p + 2); &#125; else &#123; return isMatch(s, p + 2); &#125; &#125;&#125;; 11. Container With Most Water Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.Note: You may not slant the container and n is at least 2. Tags: two pointer Cpp12345678910111213141516class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int ret = 0; if (height.size() &lt; 2) &#123; return ret; &#125; size_t left = 0; size_t right = height.size() - 1; while (left &lt; right) &#123; ret = max(ret, min(height[left], height[right]) * static_cast&lt;int&gt;(right - left)); height[left] &lt; height[right] ? ++left : --right; &#125; return ret; &#125;&#125;; Java12345678910111213141516171819public class Solution &#123; public int maxArea(int[] height) &#123; int ret = 0; if (height.length &lt; 2) &#123; return ret; &#125; int left = 0; int right = height.length - 1; while (left &lt; right) &#123; ret = Math.max(ret, Math.min(height[left], height[right]) * (right - left)); if (height[left] &lt; height[right]) &#123; ++left; &#125; else &#123; --right; &#125; &#125; return ret; &#125;&#125; 12. Integer to RomanCpp123456789101112131415class Solution &#123;public: string intToRoman(int num) &#123; vector&lt;string&gt; symbol&#123;"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"&#125;; vector&lt;int&gt; value&#123;1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1&#125;; string ret; for (int i = 0; num &gt; 0; ++i) &#123; while (num &gt;= value[i]) &#123; num -= value[i]; ret += symbol[i]; &#125; &#125; return ret; &#125;&#125;; Java12345678910111213141516public class Solution &#123; public String intToRoman(int num) &#123; String ret = ""; ArrayList&lt;String&gt; symbol = new ArrayList( Arrays.asList("M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I")); ArrayList&lt;Integer&gt; value = new ArrayList( Arrays.asList(1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)); for (int i = 0; num &gt; 0; ++i) &#123; while (num &gt;= value.get(i)) &#123; num -= value.get(i); ret = ret + symbol.get(i); &#125; &#125; return ret; &#125;&#125; 13. Roman to IntegerCpp123456789101112131415161718192021class Solution &#123;public: int romanToInt(string s) &#123; int ret = 0; int pre = 0; unordered_map&lt;char, int&gt; umap &#123; make_pair('I', 1), make_pair('V', 5), make_pair('X', 10), \ make_pair('L', 50), make_pair('C', 100), make_pair('D', 500), \ make_pair('M', 1000)&#125;; for (const auto&amp; c : s) &#123; int cur = umap.at(c); if (cur &lt;= pre) &#123; ret += cur; &#125; else &#123; ret += cur - 2 * pre; // ret = ret - pre + cur - pre &#125; pre = cur; &#125; return ret; &#125;&#125;; Java123456789101112131415161718192021222324public class Solution &#123; public int romanToInt(String s) &#123; HashMap&lt;Character, Integer&gt; hmap = new HashMap&lt;&gt;(); hmap.put('I', 1); hmap.put('V', 5); hmap.put('X', 10); hmap.put('L', 50); hmap.put('C', 100); hmap.put('D', 500); hmap.put('M', 1000); int ret = 0; int pre = 0; for (int i = 0; i &lt; s.length(); ++i) &#123; int cur = hmap.get(s.charAt(i)); if (cur &lt;= pre) &#123; ret += cur; &#125; else &#123; ret = ret - 2 * pre + cur; &#125; pre = cur; &#125; return ret; &#125;&#125; 14. Longest Common PrefixCpp1234567891011121314151617class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if (strs.size() &lt; 1) &#123; return string(""); &#125; for (size_t cursor = 0; cursor &lt; strs[0].size(); ++cursor) &#123; auto cur = strs[0][cursor]; for (size_t i = 1; i &lt; strs.size(); ++i) &#123; if (cur != strs[i][cursor]) &#123; return strs[0].substr(0, cursor); &#125; &#125; &#125; return strs[0]; &#125;&#125;; Java12345678910111213141516public class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; if (strs.length &lt;= 0) &#123; return ""; &#125; for (int cursor = 0; cursor &lt; strs[0].length(); ++cursor) &#123; char pre = strs[0].charAt(cursor); for (int i = 1; i &lt; strs.length; ++i) &#123; if (cursor &gt;= strs[i].length() || strs[i].charAt(cursor) != pre) &#123; return strs[0].substring(0, cursor); &#125; &#125; &#125; return strs[0]; &#125;&#125; 15. 3SumCpp123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; ret; int len = static_cast&lt;int&gt;(nums.size()); std::sort(nums.begin(), nums.end()); for (int i = 0; i &lt; len - 2 &amp;&amp; nums[i] &lt;= 0; ++i) &#123; // remove possible duplicate results if (i &gt; 0 &amp;&amp; nums[i] == nums[i -1 ]) &#123; continue; &#125; int left = i + 1; int right = len - 1; while (left &lt; right) &#123; auto sum = nums[i] + nums[left] + nums[right]; if (sum == 0) &#123; ret.push_back(vector&lt;int&gt;&#123;nums[i], nums[left++], nums[right--]&#125;); // remove possible duplicate results while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) &#123; ++left; &#125; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) &#123; --right; &#125; &#125; else if (sum &gt; 0) &#123; --right; &#125; else &#123; ++left; &#125; &#125; &#125; return ret; &#125;&#125;; Java12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); int len = nums.length; Arrays.sort(nums); for (int i = 0; i &lt; len - 2 &amp;&amp; nums[i] &lt;= 0; ++i) &#123; // remove possible duplicate results if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; int left = i + 1; int right = len - 1; while (left &lt; right) &#123; int sum = nums[i] + nums[left] + nums[right]; if (sum == 0) &#123; ret.add(new ArrayList(Arrays.asList(nums[i], nums[left], nums[right]))); ++left; --right; // remove possible duplicate results while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) &#123; ++left; &#125; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) &#123; --right; &#125; &#125; else if (sum &gt; 0) &#123; --right; &#125; else &#123; ++left; &#125; &#125; &#125; return ret; &#125;&#125; 16. 3sum closetCpp1234567891011121314151617181920212223242526272829class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; int len = nums.size(); assert(len &gt;= 3); int min_diff = INT_MAX; std::sort(nums.begin(), nums.end()); for (int i = 0; i &lt; (len - 2); ++i) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; int left = i + 1; int right = len - 1; while (left &lt; right) &#123; int cur_diff = nums[i] + nums[left] + nums[right] - target; if (cur_diff == 0) &#123; return target; &#125; else if (cur_diff &gt; 0) &#123; right--; &#125; else &#123; left++; &#125; min_diff = abs(cur_diff) &lt; abs(min_diff) ? cur_diff : min_diff; &#125; &#125; return min_diff + target; &#125;&#125;; Java123456789101112131415161718192021222324252627282930public class Solution &#123; public int threeSumClosest(int[] nums, int target) &#123; int len = nums.length; int minDiff = Integer.MAX_VALUE; Arrays.sort(nums); for (int i = 0; i &lt; len - 2; ++i) &#123; // avoid duplicate calc if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; int left = i + 1; int right = len - 1; while (left &lt; right) &#123; int curDiff = nums[i] + nums[left] + nums[right] - target; if (curDiff == 0) &#123; return target; &#125; else if (curDiff &gt; 0) &#123; --right; &#125; else &#123; ++left; &#125; if (Math.abs(curDiff) &lt; Math.abs(minDiff)) &#123; minDiff = curDiff; &#125; &#125; &#125; return minDiff + target; &#125;&#125; 17. Letter Combinations of a Phone Number Given a digit string, return all possible letter combinations that the number could represent.A mapping of digit to letters (just like on the telephone buttons) is given below. Tags: backtracking, string Cpp12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; vector&lt;string&gt; ret; if (digits.empty()) &#123; return ret; &#125; vector&lt;string&gt; keyboard&#123;" ", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"&#125;; // return letterCombinationsIterative(digits, keyboard); letterCombinations(ret, "", 0, digits, keyboard); return ret; &#125;private: void letterCombinations(vector&lt;string&gt; &amp;ret, const string &amp;cur, size_t idx, const string &amp;digits, const vector&lt;string&gt; &amp;keyboard) &#123; if (idx &gt;= digits.size()) &#123; ret.push_back(cur); &#125; else &#123; for (auto c : keyboard[digits[idx] - '0']) &#123; letterCombinations(ret, cur + c, idx + 1, digits, keyboard); &#125; &#125; &#125; vector&lt;string&gt; letterCombinationsIterative(const string &amp;digits, const vector&lt;string&gt; &amp;keyboard) &#123; vector&lt;string&gt; ret&#123;""&#125;; for (auto d : digits) &#123; vector&lt;string&gt; tmp; for (auto r : ret) &#123; for (auto c : keyboard[d - '0']) &#123; tmp.push_back(r + c); &#125; &#125; ret.swap(tmp); &#125; return ret; &#125;&#125;; Java1234567891011121314151617181920212223242526272829303132333435363738394041public class Solution &#123; public List&lt;String&gt; letterCombinations(String digits) &#123; List&lt;String&gt; ret = new ArrayList&lt;&gt;(); if (digits.isEmpty()) &#123; return ret; &#125; ArrayList&lt;String&gt; keyboard = new ArrayList( Arrays.asList(" ", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz")); // return letterCombinationsIterative(digits, keyboard); letterCombinationsRecursive(ret, "", 0, digits, keyboard); return ret; &#125; private void letterCombinationsRecursive(List&lt;String&gt; ret, String cur, int idx, String digits, List&lt;String&gt; keyboard) &#123; if (idx &gt;= digits.length()) &#123; ret.add(cur); &#125; else &#123; String key = keyboard.get(digits.charAt(idx) - '0'); for (int i = 0; i &lt; key.length(); ++i) &#123; letterCombinationsRecursive(ret, cur + key.charAt(i), idx + 1, digits, keyboard); &#125; &#125; &#125; private List&lt;String&gt; letterCombinationsIterative(String digits, List&lt;String&gt; keyboard) &#123; List&lt;String&gt; ret = new ArrayList&lt;&gt;(); ret.add(""); for (int i = 0; i &lt; digits.length(); ++i) &#123; List&lt;String&gt; tmp = new ArrayList&lt;&gt;(); for (String r : ret) &#123; int cur = digits.charAt(i) - '0'; for (int j = 0; j &lt; keyboard.get(cur).length(); ++j) &#123; tmp.add(r + keyboard.get(cur).charAt(j)); &#125; &#125; ret = tmp; &#125; return ret; &#125;&#125; Scala12345678910111213141516171819202122232425262728object Solution &#123; def letterCombinations(digits: String): List[String] = &#123; val ret = List[String]() val keyboard = Array(" ", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz") digits.isEmpty match &#123; case true =&gt; ret case false =&gt; //letterCombinationsIterative(digits, keyboard) letterCombinationsRecursive(0, digits, keyboard) &#125; &#125; private def letterCombinationsRecursive(start: Int, digits: String, keyboard: Array[String]): List[String] = &#123; if (start &gt;= digits.size) &#123; List("") &#125; else &#123; val tmp = letterCombinationsRecursive(start + 1, digits, keyboard) (for &#123; k &lt;- keyboard(digits(start) - '0') t &lt;- tmp &#125; yield (k + t)).toList &#125; &#125; private def letterCombinationsIterative(digits: String, keyboard: Array[String]): List[String] = &#123; digits.foldLeft(List("")) &#123; (ret, d) =&gt; ret.flatMap &#123; r =&gt; keyboard(d - '0').map &#123; k =&gt; r + k &#125; &#125; &#125; &#125;&#125; 18. 4Sum Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.Note: The solution set must not contain duplicate quadruplets.For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] Tags: two pointer Cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;vector&lt;int&gt;&gt; ret; if (nums.size() &lt; 4) &#123; return ret; &#125; sort(nums.begin(), nums.end()); vector&lt;int&gt; cur; ksum(ret, 0, 4, cur, target, nums); return ret; &#125;private: void ksum(vector&lt;vector&lt;int&gt;&gt; &amp;ret, int start, int k, vector&lt;int&gt; &amp;cur, int target, const vector&lt;int&gt; &amp;nums) &#123; if (k * nums.front() &gt; target || k * nums.back() &lt; target) &#123; return; &#125; else if (k == 2) &#123; int left = start; int right = nums.size() - 1; while (left &lt; right) &#123; auto sum = nums[left] + nums[right] - target; if (sum == 0) &#123; auto tmp = cur; tmp.push_back(nums[left]); tmp.push_back(nums[right]); ret.push_back(tmp); ++left; --right; // avoid possible duplicates while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) &#123; ++left; &#125; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) &#123; --right; &#125; &#125; else if (sum &gt; 0) &#123; --right; &#125; else &#123; ++left; &#125; &#125; &#125; else &#123; for (int i = start; i &lt; nums.size() -k + 1; ++i) &#123; if (i &gt; start &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; cur.push_back(nums[i]); ksum(ret, i + 1, k - 1, cur, target - nums[i], nums); cur.pop_back(); &#125; &#125; &#125; &#125;; Java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); if (nums.length &lt; 4) &#123; return ret; &#125; Arrays.sort(nums); List&lt;Integer&gt; cur = new ArrayList&lt;&gt;(); ksum(ret, 0, 4, cur, target, nums); return ret; &#125; private void ksum(List&lt;List&lt;Integer&gt;&gt; ret, int start, int k, List&lt;Integer&gt; cur, int target, int[] nums) &#123; if (k * nums[0] &gt; target || k * nums[nums.length - 1] &lt; target) &#123; return; &#125; else if (k == 2) &#123; int left = start; int right = nums.length - 1; while (left &lt; right) &#123; int sum = nums[left] + nums[right] - target; if (sum == 0) &#123; List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(cur); tmp.add(nums[left]); tmp.add(nums[right]); ret.add(tmp); ++left; --right; // avoid possible duplicates while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) &#123; ++left; &#125; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) &#123; --right; &#125; &#125; else if (sum &gt; 0) &#123; --right; &#125; else &#123; ++left; &#125; &#125; &#125; else &#123; for (int i = start; i &lt; nums.length - k + 1; ++i) &#123; if (i &gt; start &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; cur.add(nums[i]); ksum(ret, i + 1, k - 1, cur, target - nums[i], nums); cur.remove(cur.size() - 1); &#125; &#125; &#125;&#125; Scala123456789101112131415161718192021222324252627282930313233343536373839object Solution &#123; def fourSum(nums: Array[Int], target: Int): List[List[Int]] = &#123; var ret: List[List[Int]] = List() if (nums.size &lt; 4) return ret val sortedNums = nums.sorted var cur: List[Int] = List() def ksum(start: Int, k: Int, target: Int): Unit = &#123; if (k == 2) &#123; var left = start; var right = sortedNums.size - 1 while (left &lt; right) &#123; var sum = sortedNums(left) + sortedNums(right) - target if (sum == 0) &#123; var tmp = cur ::: List(sortedNums(left), sortedNums(right)) ret = ret ::: List(tmp) left += 1 right -= 1 while (left &lt; right &amp;&amp; sortedNums(left) == sortedNums(left - 1)) left += 1 while (left &lt; right &amp;&amp; sortedNums(right) == sortedNums(right + 1)) right -= 1 &#125; else if (sum &gt; 0) &#123; right -= 1 &#125; else left += 1 &#125; &#125; else &#123; for (i &lt;- start until sortedNums.length - k + 1) &#123; if (i == start || sortedNums(i) != sortedNums(i - 1)) &#123; var tmp = cur cur = cur ::: List(sortedNums(i)) ksum(i + 1, k - 1, target - sortedNums(i)) cur = tmp &#125; &#125; &#125; &#125; ksum(0, 4, target) ret &#125;&#125; 19. Remove Nth Node From End of ListTags: List Cpp1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode dummy = ListNode(0); dummy.next = head; ListNode *first = &amp;dummy; for (int i = 0; i &lt; n; ++i) &#123; if (first == nullptr) &#123; return nullptr; &#125; else &#123; first = first-&gt;next; &#125; &#125; ListNode *pre = &amp;dummy; for (; first != nullptr &amp;&amp; first-&gt;next != nullptr; first = first-&gt;next) &#123; pre = pre-&gt;next; &#125; auto tmp = pre-&gt;next-&gt;next; delete pre-&gt;next; pre-&gt;next = tmp; return dummy.next; &#125;&#125;; Java123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode first = dummy; for (int i = 0; i &lt; n; ++i) &#123; if (first == null) &#123; return null; &#125; else &#123; first = first.next; &#125; &#125; ListNode ptr = dummy; for (; first != null &amp;&amp; first.next != null; first = first.next) &#123; ptr = ptr.next; &#125; ListNode tmp = ptr.next.next; ptr.next = null; ptr.next = tmp; return dummy.next; &#125;&#125; 20. Valid ParenthesesTags: Stack Cpp123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: bool isValid(string s) &#123; stack&lt;char&gt; stc; for (auto c : s) &#123; if (isLeft(c)) &#123; stc.push(c); &#125; else if (stc.empty()) &#123; return false; &#125; else if (isMatch(stc.top(), c)) &#123; stc.pop(); &#125; else &#123; return false; &#125; &#125; return stc.empty(); &#125; private: bool isLeft(char c) &#123; return (c == '(' || c == '&#123;' || c == '['); &#125; bool isMatch(char l, char r) &#123; if (l == '(') &#123; return r == ')'; &#125; else if (l == '&#123;') &#123; return r == '&#125;'; &#125; else if (l == '[') &#123; return r == ']'; &#125; else &#123; return false; &#125; &#125; &#125;; Java1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stc = new Stack&lt;&gt;(); for (int i = 0; i &lt; s.length(); ++i) &#123; char c = s.charAt(i); if (isLeft(c)) &#123; stc.push(c); &#125; else if (stc.empty()) &#123; return false; &#125; else if (isMatch(stc.peek(), c)) &#123; stc.pop(); &#125; else &#123; return false; &#125; &#125; return stc.empty(); &#125; private boolean isLeft(char c) &#123; return (c == '(' || c == '&#123;' || c == '['); &#125; private boolean isMatch(char l, char r) &#123; if (l == '(') &#123; return r == ')'; &#125; else if (l == '&#123;') &#123; return r == '&#125;'; &#125; else if (l == '[') &#123; return r == ']'; &#125; else &#123; return false; &#125; &#125; &#125;; Scala123456789101112131415object Solution &#123; def isValid(s: String): Boolean = &#123; val parenthesesMap = Map('(' -&gt; ')', '&#123;' -&gt; '&#125;', '[' -&gt; ']') val ret = s.foldLeft(List[Char]()) &#123; (stc, c) =&gt; c match &#123; case '(' | '&#123;' | '[' =&gt; c :: stc case ')' | '&#125;' | ']' =&gt; if (stc.isEmpty) return false else if (parenthesesMap.get(stc.head) != Some(c)) return false else stc.tail &#125; &#125; ret.isEmpty &#125;&#125; 21. Merge Two Sorted ListsCpp123456789101112131415161718192021222324/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if (l1 == nullptr) &#123; return l2; &#125; else if (l2 == nullptr) &#123; return l1; &#125; else if (l1-&gt;val &lt; l2-&gt;val) &#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125; else &#123; l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; &#125; &#125;&#125;; Java1234567891011121314151617181920212223/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) &#123; return l2; &#125; else if (l2 == null) &#123; return l1; &#125; else if (l1.val &lt; l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125; &#125;&#125; Scala1234567891011121314151617181920212223/** * Definition for singly-linked list. * class ListNode(var _x: Int = 0) &#123; * var next: ListNode = null * var x: Int = _x * &#125; */object Solution &#123; def mergeTwoLists(l1: ListNode, l2: ListNode): ListNode = &#123; (l1, l2) match &#123; case (null, _) =&gt; l2 case (_, null) =&gt; l1 case _ =&gt; (l1.x &lt; l2.x) match &#123; case true =&gt; l1.next = mergeTwoLists(l1.next, l2) l1 case false =&gt; l2.next = mergeTwoLists(l1, l2.next) l2 &#125; &#125; &#125;&#125; 22. Generate ParenthesesCpp123456789101112131415161718192021class Solution &#123;public: vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; ret; generateParenthesis(ret, "", n, n); return ret; &#125;private: void generateParenthesis(vector&lt;string&gt; &amp;ret, string cur, int curLeftNum, int curRightNum) &#123; if (curLeftNum == 0 &amp;&amp; curRightNum == 0) &#123; ret.push_back(cur); &#125; if (curLeftNum &gt; 0) &#123; generateParenthesis(ret, cur + '(', curLeftNum - 1, curRightNum); &#125; if (curRightNum &gt; curLeftNum) &#123; generateParenthesis(ret, cur + ')', curLeftNum, curRightNum - 1); &#125; &#125;&#125;; Java12345678910111213141516171819public class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; ret = new ArrayList&lt;&gt;(); generateParenthesis(ret, "", n, n); return ret; &#125; private void generateParenthesis(List&lt;String&gt; ret, String cur, int curLeftNum, int curRightNum) &#123; if (curLeftNum == 0 &amp;&amp; curRightNum == 0) &#123; ret.add(cur); &#125; if (curLeftNum &gt; 0) &#123; generateParenthesis(ret, cur + "(", curLeftNum - 1, curRightNum); &#125; if (curRightNum &gt; curLeftNum) &#123; generateParenthesis(ret, cur + ")", curLeftNum, curRightNum - 1); &#125; &#125;&#125; Scala12345678910111213141516171819202122232425object Solution &#123; def generateParenthesis(n: Int): List[String] = &#123; generateInternal(List[String](), "", n, n) &#125; private def generateInternal(ret: List[String], cur: String, curLeftNum: Int, curRightNum: Int): List[String] = &#123; if (curLeftNum == 0 &amp;&amp; curRightNum == 0) &#123; ret ::: List(cur) &#125; else &#123; val ret1 = &#123; if (curLeftNum &gt; 0) generateInternal(ret, cur + "(", curLeftNum - 1, curRightNum) else ret &#125; val ret2 = &#123; if (curRightNum &gt; curLeftNum) generateInternal(ret1, cur + ")", curLeftNum, curRightNum - 1) else ret1 &#125; ret2 &#125; &#125;&#125; 26. Remove Duplicates from Sorted ArrayCpp1234567891011121314class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int pre = -1; for (int cur = 0; cur &lt; static_cast&lt;int&gt;(nums.size()); ++cur) &#123; if (pre == -1) &#123; ++pre; &#125; else if (nums[cur] != nums[cur - 1]) &#123; nums[++pre] = nums[cur]; &#125; &#125; return pre + 1; &#125;&#125;; Java12345678910111213public class Solution &#123; public int removeDuplicates(int[] nums) &#123; int pre = -1; for (int cur = 0; cur &lt; nums.length; ++cur) &#123; if (pre == -1) &#123; ++pre; &#125; else if (nums[cur] != nums[cur - 1]) &#123; nums[++pre] = nums[cur]; &#125; &#125; return pre + 1; &#125;&#125; Scala1234567891011121314object Solution &#123; def removeDuplicates(nums: Array[Int]): Int = &#123; var pre = -1 for (cur &lt;- 0 until nums.length) &#123; if (pre == -1) &#123; pre += 1 &#125; else if (nums(cur) != nums(cur - 1)) &#123; pre += 1 nums(pre) = nums(cur) &#125; &#125; return pre + 1 &#125;&#125; 27. Remove ElementC++123456789101112class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int ret = 0; for (auto n : nums) &#123; if (n != val) &#123; nums[ret++] = n; &#125; &#125; return ret; &#125;&#125;; Java1234567891011class Solution &#123; public int removeElement(int[] nums, int val) &#123; int ret = 0; for (int i = 0; i &lt; nums.length; ++i) &#123; if (nums[i] != val) &#123; nums[ret++] = nums[i]; &#125; &#125; return ret; &#125;&#125; Scala123456789101112object Solution &#123; def removeElement(nums: Array[Int], v: Int): Int = &#123; var ret = 0 for (i &lt;- 0 until nums.size) &#123; if (nums(i) != v) &#123; nums(ret) = nums(i) ret += 1 &#125; &#125; return ret &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>C++</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F11%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
