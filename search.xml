<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[简明Kubernetes教程]]></title>
    <url>%2F2020%2F01%2F18%2Fbyte-of-kubernetes%2F</url>
    <content type="text"><![CDATA[[TOC] 前言该文档假定大家有一定的Docker基础，介绍了kubernetes的常用和重要的功能的简单使用方法，目的是为了让大家看完可以快速上手kubernetes，并且在遇到问题时或者想深入了解某方面的时候知道如何Google；该文档主要参考了https://kubernetes.io/docs/home/ 和 Kubernetes In Action。 Kubernetes简介kubernetes是什么kubernetes源自google内部的Borg和Omega的开源软件系统，允许在它上面部署和管理容器的应用。它将底层基础设施抽象，使得在大规模的服务器（VM或BM）节点上运行软件就像在单个节点上运行一样，简化了开发，部署和运维。 kubernetes提供了什么 服务发现与负载均衡 自动部署，扩容，回滚和自愈 存储编排（本地，云），配置和加密配置管理 自动装箱 kubernetes不提供什么 不能源码部署和应用构建 不提供应用层服务，比如Kafka，Spark，MySQL，Redis等 不提供应用的日志，监控和告警解决方案 不提供机器配置，维护，管理或自我修复系统 kubernetes对象Kubernetes Objects是Kubernetes系统中的持久化的实体（etcd中）。 Kubernetes使用这些实体来表示集群的状态： 在哪个节点上运行什么样的容器化应用 这些 应用能获取的资源 这些应用重启，升级和容错的策略 通过创建对象告知kubernetes系统想要达到的状态，然后系统会保证向这个状态收敛，比如副本数量。 基础对象 Pod，基础的执行，调度和部署单元 Service， 暴露一组Pods到网络的抽象 Volume，持久化存储和容器间共享存储的抽象 高级对象（控制器） ReplicaSet，一组Pods的副本 Deployment，为Pods和ReplicaSet提供声明式更新 Statefulset，管理有状态应用的workload API DaemonSet，保证每个node上都有一个pod的replica 架构与流程如下图所示，kubernetes集群包含两部分，控制面（或者叫Master）和工作节点（Workers）： 控制面 API服务器 控制器 调度器 etcd 工作节点 kubelet kube-proxy 容器运行时 用户将镜像推送到镜像仓库之后，通过控制面发送API服务器部署请求（或者命令行），控制器收到API服务器通知后创建服务部署的对象（Deployment，Pods的元数据存储在etcd中，后面会详细描述），最后API服务器向调度器发送通知，调度器选择合适的工作节点后，API服务器通知选中的节点通过kubelet创建Pod和其中的Containers。 操作指南PodPod是kubernetes的基本构建模块，它是一组并置的容器，但比较常见的是一个pod只包含一个容器，kubernetes集群中的所有pod都在同一个共享网络空间中（无NAT平坦网络），使用kubernetes的开发者面对的最底层的不再是VM或BM而且pod这个逻辑主机。 kubernetes都是通过YAML文件描述pod等对象，一个典型的pod的yaml文件如下所示，包含4个部分： apiVersion kind，这个yaml文件要描述的对象的类型 metadata，pod的名字，标签等 spec，在pod的yaml文件中spec是描述容器的部分 12345678apiVersion: v1kind: Podmetadata: name: pod-demo spec: containers: - image: nginx name: container-demo 1234567# 直接通过yaml文件创建pod[root@VM_2_15_centos ~/macduan/demo/pod]# kubectl create -f pod-nginx.yaml pod/pod-demo created# 查看pod会发现一个名字为pod-demo的pod正在运行[root@VM_2_15_centos ~]# kubectl get pod pod-demo -o wideNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODEpod-demo 1/1 Running 0 19h 192.168.0.34 10.1.2.6 &lt;none&gt; 会发现在10.1.2.15上创建的pod，最终被调度到10.1.2.6这个Node上，在10.1.2.2上起一个临时的pod，直接向pod-demo中的nginx服务发请求 12345678910111213141516171819# 在另一台Node上启一个临时的pod, 发送curl命令测试[root@VM_2_2_centos ~]# kubectl run -it curlutils --image=tutum/curl --generator=run-pod/v1 --rm --restart=Never -- curl http://192.168.0.34&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;......# 在10.1.2.6上观察可以看到临时curlutils pod被调度到10.1.2.15上, 经过了Pending, ContainerCreating和Terminating几个状态[root@VM_2_6_centos ~]# kubectl get pod -o wide --watchNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODEpod-demo 1/1 Running 0 19h 192.168.0.34 10.1.2.6 &lt;none&gt;curlutils 0/1 Pending 0 0s &lt;none&gt; &lt;none&gt; &lt;none&gt;curlutils 0/1 Pending 0 0s &lt;none&gt; 10.1.2.15 &lt;none&gt;curlutils 0/1 ContainerCreating 0 0s &lt;none&gt; 10.1.2.15 &lt;none&gt;curlutils 0/1 ContainerCreating 0 1s &lt;none&gt; 10.1.2.15 &lt;none&gt;curlutils 0/1 Completed 0 2s 192.168.2.53 10.1.2.15 &lt;none&gt;curlutils 0/1 Terminating 0 2s 192.168.2.53 10.1.2.15 &lt;none&gt;curlutils 0/1 Terminating 0 3s 192.168.2.53 10.1.2.15 &lt;none&gt; 通过kubectl get pod pod-demo -o yaml可以看到具体的pod的详细信息，同时也会发现多一个status部分描述了这个pod的状态，这就是前面kubernetes对象提到的对象期望的状态和kubernetes向这个期望收敛的情况。 12345678910111213141516171819202122232425262728293031[root@VM_2_15_centos ~/macduan/pod]# kubectl get pod pod-demo -o yamlapiVersion: v1kind: Podmetadata: ...spec: containers: - image: nginx imagePullPolicy: Always name: container-demo ... terminationGracePeriodSeconds: 30 volumes: - name: default-token-n6snk secret: defaultMode: 420 secretName: default-token-n6snkstatus: conditions: ... containerStatuses: - containerID: ... image: nginx:latest ... name: container-demo hostIP: 10.1.2.6 phase: Running podIP: 192.168.0.34 qosClass: BestEffort ... 需要注意的是Pod中的容器（应用实例）crash了只会原地重启，Pod本身不会被调度，只有由于Node的原因或者Pod被删除了Pod才会被重新调度，在某个节点重新被创建。Pod的详细介绍请参考这里。 Container restartPolicyPod可以通过PodSpec(yaml文件中的Pod.spec.restartPolicy)设置Pod中的所有的containers的重启策略： Always，默认设置，不管Container是成功退出(exit 0)，还是错误退出 OnFailure，只有非成功退出时才会重启 Never，从不重启 我们开发的绝大多数是一直运行的服务，所以推荐使用Always策略。 123456789101112[root@VM_2_15_centos ~/macduan/demo/pod]# cat pod-lifecycle.podapiVersion: v1kind: Podmetadata: name: pod-demo labels: app: demospec: containers: - image: nginx name: lc-demo command: ['sh', '-c', 'sleep 5'] 12345678910111213141516171819[root@VM_2_15_centos ~/macduan/demo/pod]# kubectl get pod pod-demo -o yamlapiVersion: v1kind: Podmetadata: ... labels: app: demo name: pod-demo ...spec: containers: ... image: nginx imagePullPolicy: Always name: lc-demo ... ... restartPolicy: Always ... 用上述yaml文件创建一个pod，该Pod中的Container运行5s会正常退出，kubectl get pod pod-demo -o yaml可以看出默认的restartPolicy是Always，kubectl get pod -o wide -l app=demo --watch可以看到Pod的状态的变化，第一次Container退出后处于Completed状态后马上重启处于running状态，之后每次Complete之后会先进入CrashLoopBackOff。 CrashLoopBackOff策略是第一次马上重启，第二在10s之后，第三次开始每次等待时间是20s，40s指数增长直到160s，最后稳定在等待300s重启一次。 123456789101112131415161718192021222324252627[root@VM_2_6_centos ~]# kubectl get pod -o wide -l app=demo --watchNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODEpod-demo 0/1 Pending 0 0s &lt;none&gt; &lt;none&gt; &lt;none&gt;pod-demo 0/1 Pending 0 0s &lt;none&gt; 10.1.2.15 &lt;none&gt;pod-demo 0/1 ContainerCreating 0 0s &lt;none&gt; 10.1.2.15 &lt;none&gt;pod-demo 0/1 ContainerCreating 0 1s &lt;none&gt; 10.1.2.15 &lt;none&gt;pod-demo 1/1 Running 0 5s 192.168.2.118 10.1.2.15 &lt;none&gt;pod-demo 0/1 Completed 0 10s 192.168.2.118 10.1.2.15 &lt;none&gt;pod-demo 1/1 Running 1 11s 192.168.2.118 10.1.2.15 &lt;none&gt;pod-demo 0/1 Completed 1 17s 192.168.2.118 10.1.2.15 &lt;none&gt;pod-demo 0/1 CrashLoopBackOff 1 30s 192.168.2.118 10.1.2.15 &lt;none&gt;pod-demo 1/1 Running 2 32s 192.168.2.118 10.1.2.15 &lt;none&gt;pod-demo 0/1 Completed 2 37s 192.168.2.118 10.1.2.15 &lt;none&gt;pod-demo 0/1 CrashLoopBackOff 2 50s 192.168.2.118 10.1.2.15 &lt;none&gt;pod-demo 1/1 Running 3 66s 192.168.2.118 10.1.2.15 &lt;none&gt;pod-demo 0/1 Completed 3 71s 192.168.2.118 10.1.2.15 &lt;none&gt;pod-demo 0/1 CrashLoopBackOff 3 82s 192.168.2.118 10.1.2.15 &lt;none&gt;pod-demo 1/1 Running 4 2m6s 192.168.2.118 10.1.2.15 &lt;none&gt;pod-demo 0/1 Completed 4 2m11s 192.168.2.118 10.1.2.15 &lt;none&gt;pod-demo 0/1 CrashLoopBackOff 4 2m26s 192.168.2.118 10.1.2.15 &lt;none&gt;pod-demo 1/1 Running 5 3m35s 192.168.2.118 10.1.2.15 &lt;none&gt;pod-demo 0/1 Completed 5 3m40s 192.168.2.118 10.1.2.15 &lt;none&gt;pod-demo 0/1 CrashLoopBackOff 5 3m54s 192.168.2.118 10.1.2.15 &lt;none&gt;pod-demo 1/1 Running 6 6m30s 192.168.2.118 10.1.2.15 &lt;none&gt;pod-demo 0/1 Completed 6 6m35s 192.168.2.118 10.1.2.15 &lt;none&gt;pod-demo 0/1 CrashLoopBackOff 6 6m47s 192.168.2.118 10.1.2.15 &lt;none&gt;pod-demo 1/1 Running 7 11m 192.168.2.118 10.1.2.15 &lt;none&gt; 如果设置重启策略为OnFailure就会发现Container退出后没有没有重启。 12345678910111213141516171819202122[root@VM_2_15_centos ~/macduan/demo/pod]# cat pod-lifecycle.pod apiVersion: v1kind: Podmetadata: name: pod-demo labels: app: demospec: containers: - image: nginx name: lc-demo command: ['sh', '-c', 'sleep 5'] restartPolicy: OnFailure[root@VM_2_6_centos ~]# kubectl get pod -o wide -l app=demo --watchNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODEpod-demo 0/1 Pending 0 0s &lt;none&gt; &lt;none&gt; &lt;none&gt;pod-demo 0/1 Pending 0 0s &lt;none&gt; 10.1.2.15 &lt;none&gt;pod-demo 0/1 ContainerCreating 0 0s &lt;none&gt; 10.1.2.15 &lt;none&gt;pod-demo 0/1 ContainerCreating 0 1s &lt;none&gt; 10.1.2.15 &lt;none&gt;pod-demo 1/1 Running 0 2s 192.168.2.119 10.1.2.15 &lt;none&gt;pod-demo 0/1 Completed 0 7s 192.168.2.119 10.1.2.15 &lt;none&gt; 如果修改yaml文件，让Container错误退出exit 1，会发现Pod的状态变化和前面Always`时很类似，只是Pod在Container错误退出后是进入Error状态。 123456789101112131415161718192021222324252627[root@VM_2_15_centos ~/macduan/demo/pod]# cat pod-lifecycle.pod apiVersion: v1kind: Podmetadata: name: pod-demo labels: app: demospec: containers: - image: nginx name: lc-demo command: ['sh', '-c', 'sleep 5 &amp;&amp; exit 1'] restartPolicy: OnFailure[root@VM_2_6_centos ~]# kubectl get pod -o wide -l app=demo --watchNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODEpod-demo 0/1 Pending 0 0s &lt;none&gt; &lt;none&gt; &lt;none&gt;pod-demo 0/1 Pending 0 0s &lt;none&gt; 10.1.2.2 &lt;none&gt;pod-demo 0/1 ContainerCreating 0 0s &lt;none&gt; 10.1.2.2 &lt;none&gt;pod-demo 0/1 ContainerCreating 0 0s &lt;none&gt; 10.1.2.2 &lt;none&gt;pod-demo 1/1 Running 0 2s 192.168.1.82 10.1.2.2 &lt;none&gt;pod-demo 0/1 Error 0 7s 192.168.1.82 10.1.2.2 &lt;none&gt;pod-demo 1/1 Running 1 8s 192.168.1.82 10.1.2.2 &lt;none&gt;pod-demo 0/1 Error 1 13s 192.168.1.82 10.1.2.2 &lt;none&gt;pod-demo 0/1 CrashLoopBackOff 1 28s 192.168.1.82 10.1.2.2 &lt;none&gt;pod-demo 1/1 Running 2 30s 192.168.1.82 10.1.2.2 &lt;none&gt;pod-demo 0/1 Error 2 35s 192.168.1.82 10.1.2.2 &lt;none&gt; Container ProbesProbe是通过Kubelet对容器进行的一种诊断，我们还可以对Container设置以下3种探针： livenessProbe，探测该容器是否存活，适用于服务未退出但是工作不正常的场景。 readinessProbe，探测该容器是否可以提供服务，适用于不希望初始化未成功（比如加载索引，配置）的容器提供服务的场景。 startupProbe，探测该容器是否启动成功，适用于对启动成功有限制条件的场景，如果设置了该探针，前两个探针会被disable直到该探针返回成功。 以上三个探针如果未设置默认返回都是成功，如果失败则受制于上一节描述的restartPolicy。Probe的设置方式有：ExecAction，TCPSocketAction和HTTPGetAction，详细的设置包括探测延迟，探测间隔等可以参考Configure Liveness, Readiness and Startup Probes，下面只给出使用HTTPGetAction方式的livenessProbe的例子：在PodSpec.containers.livenessProbe中故意使用一个无效的port，会发现Pod的状态的变化和上一节描述Always重启策略时很像。123456789101112131415161718192021222324252627282930313233343536373839[root@VM_2_15_centos ~/macduan/demo/pod]# cat pod-lifecycle.pod apiVersion: v1kind: Podmetadata: name: pod-demo labels: app: demospec: containers: - image: nginx name: lc-demo livenessProbe: httpGet: path: / port: 8090 initialDelaySeconds: 3 periodSeconds: 3 restartPolicy: Always [root@VM_2_6_centos ~]# kubectl get pod -o wide -l app=demo --watchNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODEpod-demo 0/1 Pending 0 0s &lt;none&gt; &lt;none&gt; &lt;none&gt;pod-demo 0/1 Pending 0 0s &lt;none&gt; 10.1.2.2 &lt;none&gt;pod-demo 0/1 ContainerCreating 0 0s &lt;none&gt; 10.1.2.2 &lt;none&gt;pod-demo 0/1 ContainerCreating 0 1s &lt;none&gt; 10.1.2.2 &lt;none&gt;pod-demo 1/1 Running 0 3s 192.168.1.83 10.1.2.2 &lt;none&gt;pod-demo 1/1 Running 1 13s 192.168.1.83 10.1.2.2 &lt;none&gt;pod-demo 1/1 Running 2 25s 192.168.1.83 10.1.2.2 &lt;none&gt;pod-demo 1/1 Running 3 37s 192.168.1.83 10.1.2.2 &lt;none&gt;pod-demo 0/1 CrashLoopBackOff 3 49s 192.168.1.83 10.1.2.2 &lt;none&gt;pod-demo 1/1 Running 4 73s 192.168.1.83 10.1.2.2 &lt;none&gt;pod-demo 0/1 CrashLoopBackOff 4 85s 192.168.1.83 10.1.2.2 &lt;none&gt;pod-demo 1/1 Running 5 2m17s 192.168.1.83 10.1.2.2 &lt;none&gt;pod-demo 0/1 CrashLoopBackOff 5 2m27s 192.168.1.83 10.1.2.2 &lt;none&gt;pod-demo 1/1 Running 6 3m49s 192.168.1.83 10.1.2.2 &lt;none&gt;pod-demo 0/1 CrashLoopBackOff 6 4m 192.168.1.83 10.1.2.2 &lt;none&gt;pod-demo 1/1 Running 7 6m50s 192.168.1.83 10.1.2.2 &lt;none&gt;pod-demo 0/1 CrashLoopBackOff 7 7m 192.168.1.83 10.1.2.2 &lt;none&gt;pod-demo 1/1 Running 8 12m 192.168.1.83 10.1.2.2 &lt;none&gt; ReplicaSetReplicaSet主要用于副本控制（比如，设置副本数为3，保证副本有且仅有3份）和Pod异常时重新调度，上一节提到的Pod被删除后会被重新调度就是ReplicaSet做的事情。 在ReplicaSet的yaml文件一样也有spec部分描述想要达到的状态，特别是副本数量；它的Pod的描述在template部分。 1234567891011121314151617apiVersion: apps/v1beta2kind: ReplicaSetmetadata: name: rs-demospec: replicas: 2 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: container-demo image: nginx 这里用kubectl apply而不是之前的kubectl create，是因为kubectl apply属于Declarative Management，kubectl create属于Imperative Management ，Declarative的方式可追踪的增量变更，两种方式不可混用不然会产生未定义行为。123456# 创建ReplicaSet[root@VM_2_15_centos ~/macduan/demo/rs]# kubectl apply -f rs-demo.yaml replicaset.apps/rs-demo created[root@VM_2_15_centos ~/macduan/demo/rs]# kubectl get rs rs-demo -o wideNAME DESIRED CURRENT READY AGE CONTAINERS IMAGES SELECTORrs-demo 2 0 0 10s container-demo nginx app=nginx 1234567891011121314# 发现创建了2个Pod, 名字都是yaml文件中设置的pod-demo开头, 被调度到另外2个节点上了[root@VM_2_15_centos ~/macduan/demo/rs]# kubectl get pod -l app=nginx -o wideNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODErs-demo-lk277 1/1 Running 0 23s 192.168.0.50 10.1.2.6 &lt;none&gt;rs-demo-p5q5p 1/1 Running 0 23s 192.168.1.43 10.1.2.2 &lt;none&gt;# 在2台不同的节点上可以看到Pod的container进程[root@VM_2_2_centos ~]# docker container ls -f name=containerCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMEScbc23e5b9f3c nginx "nginx -g 'daemon of…" About an hour ago Up About an hour k8s_container-demo_rs-demo-lk277_default_b1e17f82-d506-11e9-91dd-8a673d1f8ffc_0[root@VM_2_6_centos ~]# docker container ls -f name=containerCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES17e153df5c9f nginx "nginx -g 'daemon of…" About an hour ago Up About an hour k8s_container-demo_pod-demo_default_6c0b3042-d526-11e9-91dd-8a673d1f8ffc_0 ReplicaSet（rs-demo）设置了2个replica，所以上面可以看到有2个Pod，都是rs-demo后面加上随机字符串，如果删除其中一个pod，ReplicaSet会启动一个新的Pod，从下面代码可以看出，删除rs-demo-lk277后拉起了一个新的Pod（rs-demo-cj5p5），replica数量恢复到2个了。 12345678910111213141516[root@VM_2_6_centos ~]# kubectl delete pod rs-demo-lk277pod "rs-demo-lk277" deleted[root@VM_2_15_centos ~]# kubectl get pod -o wide -l app=nginx --watchNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODErs-demo-lk277 1/1 Running 0 5h53m 192.168.1.49 10.1.2.2 &lt;none&gt;rs-demo-p5q5p 1/1 Running 0 5h53m 192.168.2.69 10.1.2.15 &lt;none&gt;rs-demo-lk277 1/1 Terminating 0 5h54m 192.168.1.49 10.1.2.2 &lt;none&gt;rs-demo-cj5p5 0/1 Pending 0 0s &lt;none&gt; &lt;none&gt; &lt;none&gt;rs-demo-cj5p5 0/1 Pending 0 0s &lt;none&gt; 10.1.2.2 &lt;none&gt;rs-demo-cj5p5 0/1 ContainerCreating 0 0s &lt;none&gt; 10.1.2.2 &lt;none&gt;rs-demo-lk277 0/1 Terminating 0 5h54m 192.168.1.49 10.1.2.2 &lt;none&gt;rs-demo-cj5p5 0/1 ContainerCreating 0 1s &lt;none&gt; 10.1.2.2 &lt;none&gt;rs-demo-lk277 0/1 Terminating 0 5h54m 192.168.1.49 10.1.2.2 &lt;none&gt;rs-demo-lk277 0/1 Terminating 0 5h54m 192.168.1.49 10.1.2.2 &lt;none&gt;rs-demo-cj5p5 1/1 Running 0 5s 192.168.1.50 10.1.2.2 &lt;none&gt; 修改rs-demo的yaml文件中的replica参数为3后，执行kubectl apply会拉起一个新的Pod，rs-demo的状态也在变化。 123456789101112131415161718192021222324[root@VM_2_15_centos ~/macduan/demo/rs]# kubectl apply -f rs-demo.yaml replicaset.apps/rs-demo configured[root@VM_2_6_centos ~]# kubectl get pod -o wide -l app=nginx --watchNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODErs-demo-cj5p5 1/1 Running 0 4m24s 192.168.1.50 10.1.2.2 &lt;none&gt;rs-demo-p5q5p 1/1 Running 0 5h59m 192.168.2.69 10.1.2.15 &lt;none&gt;rs-demo-wxvkn 0/1 Pending 0 0s &lt;none&gt; &lt;none&gt; &lt;none&gt;rs-demo-wxvkn 0/1 Pending 0 0s &lt;none&gt; 10.1.2.6 &lt;none&gt;rs-demo-wxvkn 0/1 ContainerCreating 0 0s &lt;none&gt; 10.1.2.6 &lt;none&gt;rs-demo-wxvkn 0/1 ContainerCreating 0 1s &lt;none&gt; 10.1.2.6 &lt;none&gt;rs-demo-wxvkn 1/1 Running 0 5s 192.168.0.55 10.1.2.6 &lt;none&gt;[root@VM_2_6_centos ~]# kubectl get rs rs-demo -o wide --watchNAME DESIRED CURRENT READY AGE CONTAINERS IMAGES SELECTORrs-demo 2 2 2 5h59m container-demo nginx app=nginxrs-demo 3 2 2 5h59m container-demo nginx app=nginxrs-demo 3 2 2 5h59m container-demo nginx app=nginxrs-demo 3 3 2 5h59m container-demo nginx app=nginxrs-demo 3 3 3 5h59m container-demo nginx app=nginx# 可以直接kubectl delete rs rs-demo删除, 但是推荐用kubectl delete -f &lt;filename&gt;的方式删除对象,删除ReplicaSet之后,所有的Pods也自动被删除[root@VM_2_15_centos ~/macduan/demo/rs]# kubectl delete -f rs-demo.yaml replicaset.apps "rs-demo" deleted DaemonSet有时候需要在每个Node上正好运行一个Pod（比如监控），这时候就需要DaemonSet了，下面的yaml文件可以创一个DaemonSet。 1234567891011121314151617apiVersion: apps/v1beta2kind: DaemonSet metadata: name: ds-demospec: selector: matchLabels: app: nginx template: metadata: name: pod-demo labels: app: nginx spec: containers: - image: nginx:1.17.3 name: cont-demo 上面的yaml文件中没有指定，replica数量，但是创建成功之后发现在每个节点上都有spec.template部分描述的Pod被创建了。 12345678910[root@VM_2_15_centos ~/macduan/demo/daemonset]# kubectl apply -f demo-ds.yaml daemonset.apps/ds-demo created[root@VM_2_15_centos ~/macduan/demo/daemonset]# kubectl get daemonset ds-demo -o wideNAME DESIRED CURRENT READY UP-TO-DATE AVAILABLE NODE SELECTOR AGE CONTAINERS IMAGES SELECTORds-demo 3 3 3 3 3 &lt;none&gt; 13s cont-demo nginx:1.17.3 app=nginx[root@VM_2_15_centos ~/macduan/demo/daemonset]# kubectl get pod -l app=nginx -o wideNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODEds-demo-gsr4c 1/1 Running 0 23s 192.168.2.105 10.1.2.15 &lt;none&gt;ds-demo-lqptf 1/1 Running 0 23s 192.168.0.93 10.1.2.6 &lt;none&gt;ds-demo-qmdlt 1/1 Running 0 23s 192.168.1.67 10.1.2.2 &lt;none&gt; DeploymentDeployment是一种高阶资源，以声明的方式部署和升级应用，其底层是一个或多个ReplicaSet。使用下面的yaml文件创建一个Deployment时，会发现自动创建了一个ReplicaSet和2个Pod。而Pod命名是一个RS的名字加一个随机字符串，RS名字中的那个字符串65f7dfc8fb实际是yaml文件中Pod描述部分的哈希值。 123456789101112131415apiVersion: apps/v1beta1kind: Deploymentmetadata: name: dp-demospec: replicas: 2 template: metadata: name: pod-demo labels: app: nginx spec: containers: - image: nginx:1.16.1 name: cont-demo 1234567891011121314151617181920[root@VM_2_15_centos ~/macduan/demo/deployment]# kubectl apply -f demo-deploy.yaml deployment.apps/dp-demo created[root@VM_2_15_centos ~/macduan/demo/deployment]# kubectl get deployment -o wideNAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE CONTAINERS IMAGES SELECTORdp-demo 2 2 2 2 14s cont-demo nginx:1.16.1 app=nginx[root@VM_2_15_centos ~/macduan/demo/deployment]# kubectl get rs -l app=nginx -o wideNAME DESIRED CURRENT READY AGE CONTAINERS IMAGES SELECTORdp-demo-65f7dfc8fb 2 2 2 44s cont-demo nginx:1.16.1 app=nginx,pod-template-hash=65f7dfc8fb[root@VM_2_15_centos ~/macduan/demo/deployment]# kubectl get pod -l app=nginx -o wideNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODEdp-demo-65f7dfc8fb-6pn7p 1/1 Running 0 55s 192.168.2.72 10.1.2.15 &lt;none&gt;dp-demo-65f7dfc8fb-jlnmh 1/1 Running 0 55s 192.168.1.55 10.1.2.2 &lt;none&gt;[root@VM_2_15_centos ~/macduan/demo/deployment]# kubectl get pod -l app=nginx -o wideNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODEdp-demo-65f7dfc8fb-6pn7p 1/1 Running 0 3m37s 192.168.2.72 10.1.2.15 &lt;none&gt;dp-demo-65f7dfc8fb-jlnmh 1/1 Running 0 3m37s 192.168.1.55 10.1.2.2 &lt;none&gt;dp-demo-65f7dfc8fb-lkxq2 1/1 Running 0 3s 192.168.0.58 10.1.2.6 &lt;none&gt; 咋一看Deployment和RS区别不大，但是如果我们需要升级应用的时候（只有修改Pod的描述对Deployment来说才算升级），Deployment的作用就可以更好提现了。 我们将demo-deploy.yaml中的nginx版本从1.16.1改成1.17.1, 然后更新Deployment，更新完成之后发现新增了一个IMAGES为nginx:1.17.1的RS，老版本的RSnginx:1.16.1的Pod数量 变为0了。 123456789[root@VM_2_15_centos ~/macduan/demo/deployment]# kubectl apply -f demo-deploy.yaml --recorddeployment.apps/dp-demo configured[root@VM_2_6_centos ~]# kubectl get deployment -l app=nginx -o wideNAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE CONTAINERS IMAGES SELECTORdp-demo 2 2 2 2 109s cont-demo nginx:1.17.1 app=nginx[root@VM_2_2_centos ~]# kubectl get rs -l app=nginx -o wide NAME DESIRED CURRENT READY AGE CONTAINERS IMAGES SELECTORdp-demo-65f7dfc8fb 0 0 0 96s cont-demo nginx:1.16.1 app=nginx,pod-template-hash=65f7dfc8fbdp-demo-85b846dd4f 2 2 2 19s cont-demo nginx:1.17.1 app=nginx,pod-template-hash=85b846dd4f 前面提到过Deployment是更高级别的抽象，会管理多个版本，不仅可以滚动更新（默认模式，可以选择Recreate模式）还可以回滚或在各个版本之间切换。 123456789101112131415161718# 可以看到创建了两个版本[root@VM_2_15_centos ~/macduan/demo/deployment]# kubectl rollout history deployment dp-demodeployment.extensions/dp-demo REVISION CHANGE-CAUSE1 kubectl apply --filename=demo-deploy.yaml --record=true2 kubectl apply --filename=demo-deploy.yaml --record=true# 直接回滚[root@VM_2_15_centos ~/macduan/demo/deployment]# kubectl rollout undo deployment dp-demodeployment.extensions/dp-demo[root@VM_2_6_centos ~]# kubectl get deployment -l app=nginx -o wideNAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE CONTAINERS IMAGES SELECTORdp-demo 2 2 2 2 3m21s cont-demo nginx:1.16.1 app=nginx# 切换到指定版本[root@VM_2_15_centos ~/macduan/demo/deployment]# kubectl rollout undo deployment dp-demo --to-revision=2deployment.extensions/dp-demo[root@VM_2_6_centos ~]# kubectl get deployment -l app=nginx -o wideNAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE CONTAINERS IMAGES SELECTORdp-demo 2 2 2 2 4m8s cont-demo nginx:1.17.1 app=nginx Service服务暴露给集群内部客户端用如下yaml文件可以创建一个ClusterIP类型的服务，仅可以在集群内部访问。 12345678910apiVersion: v1kind: Servicemetadata: name: srv-demospec: ports: - port: 80 targetPort: 80 selector: app: nginx 创建完成之后发现，有一个TYPE为ClusterIP的service资源，分配了一个192.168.255.102的ip，其SELECTOR是app=nginx，service控制器会持续扫描找到label与这个service的selector一致的pod关联（上一节创建的Pod）。通过分配的虚拟ip，请求被转发到后面的某个Pod上的nginx服务。 12345678910111213141516[root@VM_2_15_centos ~/macduan/demo/service]# kubectl apply -f srv-demo.yaml service/srv-demo created[root@VM_2_15_centos ~/macduan/demo/service]# kubectl get svc srv-demo -o wideNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE SELECTORsrv-demo ClusterIP 192.168.255.102 &lt;none&gt; 80/TCP 104s app=nginx[root@VM_2_15_centos ~/macduan/demo/service]# kubectl run -it curlutils --image=tutum/curl --generator=run-pod/v1 --rm --restart=Never -- curl http://192.168.255.102&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;style&gt;...# 上文提到的关联实际是通过Endpoint[root@VM_2_15_centos ~/macduan/demo/service]# kubectl get endpoints srv-demoNAME ENDPOINTS AGEsrv-demo 192.168.0.76:80,192.168.1.61:80,192.168.2.81:80 3h28m 上面提到的Service与Pods关联，本质就是Service知道它背后支持它的Pods的ip和port，这是通过Endpoints实现的。 1234567891011121314151617[root@VM_2_15_centos ~/macduan/demo/service]# kubectl describe svc srv-demoName: srv-demoNamespace: defaultLabels: &lt;none&gt;Annotations: kubectl.kubernetes.io/last-applied-configuration: &#123;&quot;apiVersion&quot;:&quot;v1&quot;,&quot;kind&quot;:&quot;Service&quot;,&quot;metadata&quot;:&#123;&quot;annotations&quot;:&#123;&#125;,&quot;name&quot;:&quot;srv-demo&quot;,&quot;namespace&quot;:&quot;default&quot;&#125;,&quot;spec&quot;:&#123;&quot;ports&quot;:[&#123;&quot;port&quot;:80,&quot;tar...Selector: app=nginxType: ClusterIPIP: 192.168.255.102Port: &lt;unset&gt; 80/TCPTargetPort: 80/TCPEndpoints: 192.168.0.76:80,192.168.1.61:80,192.168.2.81:80Session Affinity: NoneEvents: &lt;none&gt;[root@VM_2_15_centos ~/macduan/demo/service]# kubectl get endpoints srv-demoNAME ENDPOINTS AGEsrv-demo 192.168.0.76:80,192.168.1.61:80,192.168.2.81:80 3h28m 服务发现看完上面的过程会发现一个问题，集群内部的客户端要访问这个服务必须知道192.168.255.102， 那如何获取呢？有两种方式： 环境变量，如果客户端Pod创建晚于这个Service，那么这个Pod就会有这个Service的IP和PORT的环境变量 12345678[root@VM_2_15_centos ~/macduan/demo/service]# kubectl exec dp-demo-56d95d4c95-xzzc7 env | grep SRV_DEMOSRV_DEMO_PORT_80_TCP=tcp://192.168.255.102:80SRV_DEMO_PORT_80_TCP_ADDR=192.168.255.102SRV_DEMO_SERVICE_HOST=192.168.255.102SRV_DEMO_SERVICE_PORT=80SRV_DEMO_PORT=tcp://192.168.255.102:80SRV_DEMO_PORT_80_TCP_PROTO=tcpSRV_DEMO_PORT_80_TCP_PORT=80 DNS，环境变量获取方式有其局限性，Kubernetes其内部DNS服务使客户端Pod可以通过FQDN来访问（前提是知道服务的名称），FQDN格式为service_name.[$namespace].[svc].[local]，但是Service的端口号如果不是标准的，客户端Pod必须提前知道 1234567891011[root@VM_2_15_centos ~/macduan/demo/service]# kubectl run -it curlutils --image=tutum/curl --generator=run-pod/v1 --rm --restart=Never -- curl http://srv-demo.default.svc.cluster.local&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;style&gt;...# curl http://srv-demo.default.svc.cluster.local# curl http://srv-demo.default# curl http://srv-demo# 上面这三种方式都可以 服务暴露给集群外部客户端有三种方式可以将服务暴露给集群外部客户端： NodePort，在所有Node上打开一个端口，客户端向其中任何一个Node的该端口发送的请求都会被Service重定向到其背后某个Pod的应用的端口上。 LoadBalance，是NodePort的扩展，会自动分配Node上的一个端口，创建CLB（腾讯云TKE会默认创建一个CLB），本质上是一个NodePort方式，只是端口是随机分配，CLB自动创建。 Ingress，使用一个公网IP公开多个服务，详细请见这里 下面这个manifest是创建一个NodePort服务 12345678910111213[root@VM_2_15_centos ~/macduan/demo/service]# cat svc-np-demo.yaml apiVersion: v1kind: Servicemetadata: name: svc-np-demospec: type: NodePort ports: - port: 80 targetPort: 80 nodePort: 31135 selector: app: nginx 创建完成之后发现，分配了一个Cluster-IP，通过这个ip或者FQDN访问该服务都ClusterIP类型的服务类似，这里多了一个NodePort 31135，虽然Pods只被调度到10.1.2.2和10.1.2.15两个Node上，但是在10.1.2.6上发现31135也是被打开了，在上面发送请求也会被Service重定向到10.1.2.2和10.1.2.15上的某个Pod上。 123456789101112131415[root@VM_2_15_centos ~/macduan/demo/service]# kubectl apply -f svc-np-demo.yaml service/svc-np-demo created[root@VM_2_15_centos ~/macduan/demo/service]# kubectl get svc svc-np-demo -o wideNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE SELECTORsvc-np-demo NodePort 192.168.255.96 &lt;none&gt; 80:31135/TCP 16s app=nginx[root@VM_2_15_centos ~/macduan/demo/service]# kubectl get pod -l app=nginx -o wideNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODEdp-demo-56d95d4c95-tss5j 1/1 Running 0 4h18m 192.168.1.61 10.1.2.2 &lt;none&gt;dp-demo-56d95d4c95-xzzc7 1/1 Running 0 4h18m 192.168.2.81 10.1.2.15 &lt;none&gt;[root@VM_2_6_centos ~]# curl localhost:31135&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;... 下面这个manifest创建一个LoadBalance类型服务 123456789101112[root@VM_2_15_centos ~/macduan/demo/service]# cat svc-lb-demo.yaml apiVersion: v1kind: Servicemetadata: name: svc-lb-demospec: type: LoadBalancer ports: - port: 80 targetPort: 80 selector: app: nginx 创建完成之后发现，自动创建了CLB并且分配了一个外网IP192.144.195.158，外部客户端也可以访问该服务了 123456789101112131415[root@VM_2_15_centos ~/macduan/demo/service]# kubectl apply -f svc-lb-demo.yaml service/svc-lb-demo created[root@VM_2_15_centos ~/macduan/demo/service]# kubectl get svc svc-lb-demo NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEsvc-lb-demo LoadBalancer 192.168.255.250 &lt;pending&gt; 80:31134/TCP 8s[root@VM_2_15_centos ~/macduan/demo/service]# kubectl get svc svc-lb-demoNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEsvc-lb-demo LoadBalancer 192.168.255.250 192.144.195.158 80:31134/TCP 2m45s[root@VM_9_103_centos~]$ curl http://192.144.195.158&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;... ConfigMap和Secret一般应用都会需要配置项，kubernetes提供了ConfigMap和Secret两种资源对象。ConfigMap可以通过字符串，文件或文件的方式创建，使用文件的方式创建的ConfigMap的key就是文件名，value就是文件内容，那么通过文件夹创建的就是批量文件创建方式。 创建一个文件，并通过文件方式创建一个ConfigMap 1234567891011121314[root@VM_2_15_centos ~/macduan/demo/configmap]# cat index.html &lt;h&gt;&quot;Hello World!&quot;&lt;/h&gt;[root@VM_2_15_centos ~/macduan/demo/configmap]# kubectl create configmap cfm-demo --from-file=index.html[root@VM_2_15_centos ~/macduan/demo/configmap]# kubectl get configmap cfm-demo -o yamlapiVersion: v1data: index.html: | &lt;h&gt;&quot;Hello World!&quot;&lt;/h&gt;kind: ConfigMapmetadata: ... name: cfm-demo namespace: default ... 我们可以修改Deployment的Pod模板部分，通过volumes和volumeMount使用创建的ConfigMap 1234567891011121314151617181920212223apiVersion: apps/v1beta1kind: Deploymentmetadata: name: dp-cfm-demospec: replicas: 2 template: metadata: name: pod-demo labels: app: nginx spec: containers: - image: nginx:1.17.3 name: cont-demo volumeMounts: - name: config mountPath: /usr/share/nginx/html readOnly: true volumes: - name: config configMap: name: cfm-demo 上述yaml文件中，将ConfigMap cfm-demo挂载（覆盖）了容器/usr/share/nginx/html目录，使用上面的yaml文件创建一个Deployment之后，发现向其中的Pod发送请求收到的内容变成生存cfm-demo的文件的内容了。 12345[root@VM_2_15_centos ~/macduan/demo/deployment]# kubectl get pod -l app=nginx -o wideNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODEdp-cfm-demo-8c4975c9b-54bvl 1/1 Running 0 14m 192.168.1.63 10.1.2.2 &lt;none&gt;dp-cfm-demo-8c4975c9b-jwrg7 1/1 Running 0 14m 192.168.2.90 10.1.2.15 &lt;none&gt;[root@VM_2_6_centos ~]# kubectl run -it curlutils --image=tutum/curl --generator=run-pod/v1 --rm --restart=Never -- curl http://192.168.1.63&lt;h&gt;"Hello World!"&lt;/h&gt; Secret本质上和ConfigMap是一样的，只是它的内容是加密的，用相同的文件创建一个secret，发现其内容用Base64编码了 123456789[root@VM_2_15_centos ~/macduan/demo/configmap]# kubectl create secret generic secret-demo --from-file=index.html secret/secret-demo created[root@VM_2_15_centos ~/macduan/demo/configmap]# kubectl get secret secret-demo -o yamlapiVersion: v1data: index.html: PGg+IkhlbGxvIFdvcmxkISI8L2g+Cg==kind: Secretmetadata: ... PV和PVC虽然kubernetes有Volumes，但是Volumes要求Pod的开发者了解集群中可用的真实的网络存储组件，这与kubernetes的向开发人员隐藏真实的基础设施的理念不符，所以引入了PV与PVC。 PV，由管理创建（或动态创建）的一块存储区域，它规定了存储空间大小，访问模式和存储介质类型。 PVC，声明了需要使用的PV的最低容量要求和访问模式，在Pod中被使用。创建一个PV，之后创建一个PVC会自动绑定满足条件的PV PV和PVC的yaml文件如下 123456789101112131415161718192021222324252627[root@VM_2_15_centos ~/macduan/demo/pv-pvc]# cat pv-demo.yaml apiVersion: v1kind: PersistentVolumemetadata: name: pv-demospec: capacity: storage: 5Mi accessModes: - ReadWriteOnce - ReadOnlyMany persistentVolumeReclaimPolicy: Retain hostPath: path: /root/macduan/demo/pv-pvc/tmp[root@VM_2_15_centos ~/macduan/demo/pv-pvc]# cat pvc-demo.yaml apiVersion: v1kind: PersistentVolumeClaimmetadata: name: pvc-demospec: resources: requests: storage: 5Mi accessModes: - ReadWriteOnce storageClassName: "" 创建PV之后发现其状态是Available，在创建PVC之后发现该PV满足其条件并绑定了，所以pv-demo的状态变成了Bound。 1234567891011121314[root@VM_2_15_centos ~/macduan/demo/pv-pvc]# kubectl apply -f pv-demo.yaml persistentvolume/pv-demo created[root@VM_2_15_centos ~/macduan/demo/pv-pvc]# kubectl get pv pv-demoNAME CAPACITY ACCESS MODES RECLAIM POLICY STATUS CLAIM STORAGECLASS REASON AGEpv-demo 5Mi RWO,ROX Retain Available 6s[root@VM_2_15_centos ~/macduan/demo/pv-pvc]# kubectl apply -f pvc-demo.yaml persistentvolumeclaim/pvc-demo created[root@VM_2_15_centos ~/macduan/demo/pv-pvc]# kubectl get pvc pvc-demo -o wideNAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS AGEpvc-demo Bound pv-demo 5Mi RWO,ROX 10s[root@VM_2_15_centos ~/macduan/demo/pv-pvc]# kubectl get pv pv-demo -o wideNAME CAPACITY ACCESS MODES RECLAIM POLICY STATUS CLAIM STORAGECLASS REASON AGEpv-demo 5Mi RWO,ROX Retain Bound default/pvc-demo 50s 12345678910111213141516[root@VM_2_15_centos ~/macduan/demo/pv-pvc]# cat pod-demo.yaml apiVersion: v1kind: Podmetadata: name: pod-demo spec: containers: - image: nginx name: container-demo volumeMounts: - name: index mountPath: /usr/share/nginx/html volumes: - name: index persistentVolumeClaim: claimName: pvc-demo 上面的PV使用hostPath模式，集群模式的kubernetes的PV不应该使用hostPath，因为不知道Pod会被调度到哪个节点上；这里为了demo方便所以使用hostPath模式，不过简单的workaround可以不影响demo；首先用上面的yaml文件创建一个Pod，发现它被调度到节点10.2.2.2上了，那么在该节点上创建目录PV的yaml文件中指定的hostPath/root/macduan/demo/pv-pvc/tmp，并创建一个index.html的文件，和上一节ConfigMap类似，PVC帮定的PV（pv-demo）挂载到nginx的/usr/share/nginx/html，其中的index.html被/root/macduan/demo/pv-pvc/tmp/index.html覆盖了。 123456789101112131415[root@VM_2_15_centos ~/macduan/demo/pv-pvc]# kubectl apply -f pod-demo.yaml pod/pod-demo created[root@VM_2_15_centos ~/macduan/demo/pv-pvc]# kubectl get pod pod-demoNAME READY STATUS RESTARTS AGEpod-demo 1/1 Running 0 6s[root@VM_2_15_centos ~/macduan/demo/pv-pvc]# kubectl get pod pod-demo -o wideNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODEpod-demo 1/1 Running 0 10s 192.168.1.64 10.1.2.2 &lt;none&gt;[root@VM_2_2_centos ~]# mkdir -p /root/macduan/demo/pv-pvc/tmp[root@VM_2_2_centos ~/macduan/demo/pv-pvc/tmp]# echo '&lt;h&gt;Hello World!&lt;/h&gt;' &gt; index.html[root@VM_2_15_centos ~/macduan/demo/pv-pvc]# kubectl run -it curlutils --image=tutum/curl --generator=run-pod/v1 --rm --restart=Never -- curl http://192.168.1.64&lt;h&gt;Hello World!&lt;/h&gt; StatefulSet前面讲到的Deployment还是Service都只适用无状态应用，对于有状态的应用，客户端需要每次访问到特定的Pod，每个Pod需要使用固定的存储数据，即使在Pod可能被删除后被拉起调度到别的节点。这里参考了kubernetes官网的StatefulSet Basic。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546apiVersion: v1kind: Servicemetadata: name: nginx labels: app: nginxspec: ports: - port: 80 name: web clusterIP: None selector: app: nginx---apiVersion: apps/v1kind: StatefulSetmetadata: name: webspec: serviceName: "nginx" replicas: 2 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx ports: - containerPort: 80 name: web volumeMounts: - name: www mountPath: /usr/share/nginx/html volumeClaimTemplates: - metadata: name: www spec: accessModes: [ "ReadWriteOnce" ] resources: requests: storage: 5Mi 上面的yaml文件包含了Service和StatefuSet的manifest，需要注意的是，Service部分的spec.clusterIP为None，这是因为StatefulSet的控制Service必须是headless模式，在StatefulSet部分的sepc.volumeClaimTemplates是PVC的模板，创建该StatefulSet的Pod时，会自动为每个Pod分配一个PVC。 12345678910111213141516171819# 创建一个StatefulSet服务[root@VM_2_15_centos ~/macduan/demo/statefulset]# kubectl apply -f ss-demo.yaml service/nginx createdstatefulset.apps/web created[root@VM_2_15_centos ~/macduan/demo/statefulset]# kubectl get svc nginx -o wideNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE SELECTORnginx ClusterIP None &lt;none&gt; 80/TCP 6m44s app=nginx[root@VM_2_15_centos ~/macduan/demo/statefulset]# kubectl get statefulset -o wideNAME DESIRED CURRENT AGE CONTAINERS IMAGESweb 2 2 6m57s nginx nginx[root@VM_2_15_centos ~/macduan/demo/statefulset]# kubectl get pod -l app=nginx -o wideNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODEweb-0 1/1 Running 0 8m2s 192.168.2.93 10.1.2.15 &lt;none&gt;web-1 1/1 Running 0 7m28s 192.168.1.65 10.1.2.2 &lt;none&gt;# Each Pod has a stable hostname based on its ordinal index. Use kubectl exec to execute the hostname command in each Pod.[root@VM_2_15_centos ~/macduan/demo/statefulset]# for i in 0 1; do kubectl exec web-$i -- sh -c 'hostname'; doneweb-0web-1 上面会发现Pod的名字不再是随机的了，而是有固定编号了，而且每个Pod有固定的hostname。 12345678910111213141516171819202122232425# 通过SRV记录发现该服务的两个Pod的FQDN[root@VM_2_15_centos ~/macduan/demo/statefulset]# kubectl run -it srvlookup --image=tutum/dnsutils --rm --restart=Never -- dig SRV nginx.default.svc.cluster.local...;; ADDITIONAL SECTION:web-1.nginx.default.svc.cluster.local. 5 IN A 192.168.1.65web-0.nginx.default.svc.cluster.local. 5 IN A 192.168.0.90...# 修改每个Pod的index.html（挂载到PV上了）[root@VM_2_15_centos ~/macduan/demo/statefulset]# for i in 0 1; do kubectl exec web-$i -- sh -c 'echo $(hostname) &gt; /usr/share/nginx/html/index.html'; done[root@VM_2_15_centos ~/macduan/demo/statefulset]# kubectl run -it curlutils --image=tutum/curl --generator=run-pod/v1 --rm --restart=Never -- curl http://web-0.nginxweb-0pod "curlutils" deleted[root@VM_2_15_centos ~/macduan/demo/statefulset]# kubectl run -it curlutils --image=tutum/curl --generator=run-pod/v1 --rm --restart=Never -- curl http://web-1.nginxweb-1[root@VM_2_15_centos ~/macduan/demo/statefulset]# kubectl delete pod web-0pod "web-0" deleted[root@VM_2_15_centos ~/macduan/demo/statefulset]# kubectl get pod -l app=nginx -o wideNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODEweb-0 1/1 Running 0 54s 192.168.0.90 10.1.2.6 &lt;none&gt;web-1 1/1 Running 0 3h42m 192.168.1.65 10.1.2.2 &lt;none&gt;[root@VM_2_15_centos ~/macduan/demo/statefulset]# kubectl run -it curlutils --image=tutum/curl --generator=run-pod/v1 --rm --restart=Never -- curl http://web-0.nginx.defaultweb-0 从上面的操作可以看出，修改了每个Pod的/usr/share/nginx/html/index.html（通过PV挂载了）的内容后，给不同的Pod发送请求会收到不同的结果，即使删除了web-0，它被拉起后调度到10.1.2.6了，对它的请求返回还是之前写入的内容。 12345678910111213141516171819# 修改副本数量为3[root@VM_2_15_centos ~/macduan/demo/statefulset]# kubectl apply -f ss-demo.yaml service/nginx unchangedstatefulset.apps/web configured[root@VM_2_15_centos ~/macduan/demo/statefulset]# kubectl get pod -l app=nginx -o wideNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODEweb-0 1/1 Running 0 49m 192.168.0.90 10.1.2.6 &lt;none&gt;web-1 1/1 Running 0 4h30m 192.168.1.65 10.1.2.2 &lt;none&gt;web-2 1/1 Running 0 52s 192.168.2.104 10.1.2.15 &lt;none&gt;[root@VM_2_15_centos ~/macduan/demo/statefulset]# kubectl run -it curlutils --image=tutum/curl --generator=run-pod/v1 --rm --restart=Never -- curl http://web-2.nginx.default&lt;html&gt;&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;/h1&gt;&lt;/center&gt;&lt;hr&gt;&lt;center&gt;nginx/1.17.3&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 修改副本数量为3之后，一个新的Pod web-2被创建了，编号是从0开始递增的，由于这里的PV是Dynamic Provision，内容是空的，所以向web-2发送的请求会出现上面的回复。 服务改造指南检索服务绝大部分的检索系统是包含基础召回服务和汇聚服务（一层或者两层），这里只讲如何改造基础召回服务，后面提到检索服务实际是指基础召回服务。简单讲检索服务的节点就是索引所在的节点，后面就叫qn（query node），它们接收请求根据索引数据返回检索结果，然后在汇聚层做聚合。由于索引数据往往很大，所以要做shard，为了保证可靠性也需要replica，抽象来看基础召回服务的拓扑结构就是一个N * M的矩阵，M列就是指shard数量，N行就是N份replica，每次检索请求会到所有的shard的某个replica上。检索服务，在Kubernetes上每个qn装在一个pod中，可以做成无状态的方式和有状态的方式: 无状态服务 每一列一个Deployment+Service，检索服务的每一列都是相同的索引，所以在每一列上是无状态的，这种方式比较简单，基本上就是参考操作指南章节的Deployment和Service部分就可以了。 有状态服务 每一行一个Statefulset+Service，检索服务每一行的每个qn之间的索引是不一样的，也就是有状态的索引需要用Statefulset。 这里假设检索服务拓扑结构是一个2*3的矩阵，所以需要两个Statefulset+Service，复用操作指南章节中的yaml，用nginx模拟qn假设其index.html是所以文件，代理层（聚合层）这里用简单的命令模拟。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546apiVersion: v1kind: Servicemetadata: name: retrieve-01 labels: app: retrieve-01spec: ports: - port: 80 name: qn-01 clusterIP: None selector: app: qn-01---apiVersion: apps/v1kind: StatefulSetmetadata: name: ss-01spec: serviceName: "retrieve-01" replicas: 3 selector: matchLabels: app: qn-01 template: metadata: labels: app: qn-01 spec: containers: - name: nginx image: nginx ports: - containerPort: 80 name: web volumeMounts: - name: www mountPath: /usr/share/nginx/html volumeClaimTemplates: - metadata: name: www spec: accessModes: [ "ReadWriteOnce" ] resources: requests: storage: 5Mi 12345678910111213141516171819202122232425262728293031323334353637383940414243444546apiVersion: v1kind: Servicemetadata: name: retrieve-02 labels: app: retrieve-02spec: ports: - port: 80 name: qn-02 clusterIP: None selector: app: qn-02---apiVersion: apps/v1kind: StatefulSetmetadata: name: ss-02spec: serviceName: "retrieve-02" replicas: 3 selector: matchLabels: app: qn-02 template: metadata: labels: app: qn-02 spec: containers: - name: nginx image: nginx ports: - containerPort: 80 name: web volumeMounts: - name: www mountPath: /usr/share/nginx/html volumeClaimTemplates: - metadata: name: www spec: accessModes: [ "ReadWriteOnce" ] resources: requests: storage: 5Mi 用上面的yaml文件创建两个有状态的服务，分布代表检索服务的两行。1234567891011121314151617# 第一行[root@VM_2_6_centos ~]# kubectl run -it srvlookup --image=tutum/dnsutils --rm --restart=Never -- dig SRV retrieve-01.default.svc.cluster.local ...;; ADDITIONAL SECTION:ss-01-0.retrieve-01.default.svc.cluster.local. 5 IN A 192.168.0.115ss-01-2.retrieve-01.default.svc.cluster.local. 5 IN A 192.168.1.101ss-01-1.retrieve-01.default.svc.cluster.local. 5 IN A 192.168.2.140 ... # 第二行[root@VM_2_6_centos ~]# kubectl run -it srvlookup --image=tutum/dnsutils --rm --restart=Never -- dig SRV retrieve-02.default.svc.cluster.local ...;; ADDITIONAL SECTION:ss-02-1.retrieve-02.default.svc.cluster.local. 5 IN A 192.168.1.104ss-02-2.retrieve-02.default.svc.cluster.local. 5 IN A 192.168.2.150ss-02-0.retrieve-02.default.svc.cluster.local. 5 IN A 192.168.0.120 ... 123456789101112131415上面创建的检索服务的拓扑结构如下ss-01-0 ss-01-1 ss-01-2 ---&gt; retrieve-01ss-02-0 ss-02-1 ss-02-2 ---&gt; retrieve-02用index.html模拟索引文件[root@VM_2_6_centos ~]# for i in 0 1 2;do kubectl exec ss-01-$i -- sh -c &quot;echo index-$i &gt; /usr/share/nginx/html/index.html&quot;;done[root@VM_2_6_centos ~]# for i in 0 1 2;do kubectl exec ss-02-$i -- sh -c &quot;echo index-$i &gt; /usr/share/nginx/html/index.html&quot;;donecur请求模拟检索请求，在某一行的服务中，可以指定到具体的qn进行检索（一般是所有的）[root@VM_2_6_centos ~]# kubectl run -it curlutils --image=tutum/curl --generator=run-pod/v1 --rm --restart=Never -- curl http://ss-01-0.retrieve-01index-0[root@VM_2_6_centos ~]# kubectl run -it curlutils --image=tutum/curl --generator=run-pod/v1 --rm --restart=Never -- curl http://ss-01-2.retrieve-01index-2[root@VM_2_6_centos ~]# kubectl run -it curlutils --image=tutum/curl --generator=run-pod/v1 --rm --restart=Never -- curl http://ss-02-0.retrieve-02index-0]]></content>
  </entry>
  <entry>
    <title><![CDATA[Flink Notes]]></title>
    <url>%2F2018%2F11%2F10%2FFlink-Notes%2F</url>
    <content type="text"><![CDATA[Flink是一种框架和分布式处理引擎，用于对无界和有界数据进行有状态计算。Flink被设计成可以在所有常见的集群环境中运行，以任意规模执行in-memory计算。 Flink搭建在Flink官方文档中的Quickstart中给了在Flink上运行经典的WordCount，通过动手搭建和运行来初步了Flink；在此基础上，我实验了源码编译和IDE运行。 Binary安装与运行 从官网上下载flink-1.6.2-bin-hadoop28-scala_2.11.tgz并解压到目标目录， 运行$YourFlinkFolder/bin/start-cluster.sh，这时可以在http://localhost:8081访问所启动的flink cluster的dashboard，详细请见官方文档，log在$YourFlinkFolder/log/flink--standalonesession-.log， 运行nc -l 9000，这个很关键，在运行WordCount Job的时候需要指定接收text的服务的hostname（默认localhost）和port，如果没有启动，运行时会连接异常， $YourFlinkFolder/bin/flink run examples/streaming/SocketWindowWordCount.jar –port 9000 在启动nc的terminal上输入句子，$YourFlinkFolder/log/flink--taskexecutor-.out会输出word，count。 IDE运行虽然上一节描述了如何运行一个WordCount，但是如果想要了解其内部机制最好是在IDE中调试一番，IDE理所当然的选Intellij IDEA啦： git clone https://github.com/apache/flink.git， mvn clean package -DskipTests， 在Intellij中打开flink目录，打开过程中（最好auto import），Intellij会自动找到pom通过mvn构建project， 为了要先执行步骤2呢，因为我在执行步骤3的时候会报找不到avro的错误 运行nc -l 9000 右击SocketWindowWordCount类 在启动nc的erminal上输入句子，Intellij的输出窗口上可以看到word，count。]]></content>
      <tags>
        <tag>flink</tag>
        <tag>distributed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译]Paxos Made Simple]]></title>
    <url>%2F2018%2F09%2F25%2Fpaxos-made-simple%2F</url>
    <content type="text"><![CDATA[“只有一种一致性协议，那就是Paxos” – Mike Burrows Google Chubby 作者 摘要Paxos算法，当用简单英文介绍时就非常简单了。 (The Paxos algorithm, when presented in plain English, is very simple.) 介绍用于实现容错分布式系统的Paxos算法被认为难以理解，可能是因为最初表述对于许多读者来说是希腊语[5]。实际上，它是最简单和最明显的分布式算法之一。 其核心是一致性算法，即[5]中的“synod”算法。下一节表明，这种一致性算法几乎不可避免地遵循我们希望它满足的性质。最后一节解释了完整的Paxos算法，该算法是通过直接应用一致性到状态机方法获得的，状态机方法是一种应该被广泛知晓的构建分布式系统的方法，是因为它是大概被引用次数最多的分布式系统理论论文的主题[4]。 一致性算法2.1 问题提议假设有一批可以提出值的进程。 一致性算法确保提议的值中只有一个被选中。 如果没有提出值，则没有值被选择。 如果已选择值，则进程应该能够获悉（learn）所选值。 达成一致的安全要求是： 只能选择已提出的值， 只选择一个值，并且 一个进程永远不会获悉一个被选中的值，除非它真的选中。 我们不会尝试指定精确的活跃的需求。 但是，目标是确保某个提议的值最终被选中，如果一个值被选中，那么进程可以最终获悉该值。 我们让共识算法中的三个角色由三类代理（agent）执行：提议者（proposers），接受者（acceptors）和学习者（learners）。在实现中，单个进程可以充当多个代理，但是代理到进程的映射在此我们不关心。 假设代理可以通过发送消息来相互通信。 我们使用通常的异步非拜占庭模型，其中： 代理以任意速度运行，可能因停止而故障，并可能重新启动。由于所有代理在选择值后可能故障然后重新启动，因此除非某些信息可以由失败并重新启动的代理记住，否则没有解决方案。 消息可以任意长时间传递，可以被复制，并且可以被丢失，但它们不会被破坏。 2.2 选择一个值选择值的最简单方法是使用单个接受者代理。提议者向接受者发送提议，接受者选择其收到的第一个提议值。这种解决方案虽然简单，但不可行，因为接受者故障会使整个过程无法继续进行。 那么，让我们尝试另一种选择值的方法。我们使用多个接受者代理而不是单个接受者。提议者将提议值发送给一组接受者。接受者可以接受提议值。当足够大的接受者集合接受它时选择该值。有多大才足够呢？为了确保只选择一个值，我们可以让任意大多数代理组成一个足够大的集合。因为任何两个多数代理至少有一个共同的接受者，如果接受者最多可以接受一个值（译者注：这个值可能是不同的提议者“妥协”的结果），这是有效的。 （明显从[3]开始，有大量的论文概述了这个大多数的观察。） 在没有失败或消息丢失的情况下，即使只有单个提议者仅提出一个值，我们也希望这个值被选择。这表明要求： P1. 接受者必须接受其收到的第一个提议。 但是这个要求引出了一个问题。不同的提议者几乎同时提出若干个值，导致每个接受者都接受了一个值，但是没有一个值被它们中的大多数接受。即使只有两个建议的值，如果每个值都被大约一半的接受者接受了，单个接受者的失败可能造成无法获悉选择了哪个值。 P1和一个值仅在大多数接受者接受时才会被选择的要求意味着必须允许接受者接受多个提议。我们通过为每个提议分配（自然）序号来跟踪接受者可能接受的不同提议，因此提议包含提议序号和值。为防止混淆，我们要求不同的提议具有不同的数字。我们现在只是这样假设，不考虑具体实现。当具有某个值的单个提议已被大多数接受者接受时，将选择这个值。在这种情况下，我们可以说已经选择了该提议（及其值）。 我们可以允许选择多个提议，但我们必须保证所有选定的提议具有相同的价值。通过对提议序号的归纳，足以保证： P2. 如果选择了值为v的提议，则每个被选择的序号较高的提议都有值v。 由于数字是完全有序的，因此条件P2保证了仅选择单个值的关键安全属性。要被选中，至少有一个接受者必须接受提议。 所以,我们通过满足以下条件来满足P2： P2a. 如果选择了值为v的提议，则所有被任何接受者接受的高序号提议都有值v。（译者注：这里很关键且难理解，因为不同提议者的值可能不一样，但是为了达成一致，哪怕序号高的提议发现有接受者接受了提议号低的不同值也会把自己的提议值改成一样的。） 我们仍然维护P1以确保选择一些提议被选择。由于通信是异步的，提议可能被一个从未收到过任何提议的接受者c选择。假设一个新的提议者“醒来”并发出一个具有不同值的更高序号的提议。 P1要求c接受此提议，违反P2a。 维持P1和P2a需要加强P2a： P2b. 如果一个值为v的提议被选择了，则由任意提议者提出的每个序号较高的提议的值为v。 由于提议必须在可以被接受者接受之前被提议者发布（issue），P2b意味着P2a，而P2a又意味着P2。 为了发现如何满足P2b，让我们考虑如何证明它是成立的。 我们假设选择了一些序号为m和值为v的提案，并表明任何以序号$n&gt; m$发出的提案也具有值v。我们可以通过在n上使用归纳法来使证明更容易，因此我们可以证明提议序号为n具有v值的额外假设是每个以$m :: (n - 1)$中的数字为序号发布的提议具有值v，其中$i :: j$表示从i到j的数字集。对于即将被选择序号为m的提议，必须有一些由大多数接受者组成的集合C，C中的每个接受者都接受它。 将此与归纳假设相结合，m被选择的假设意味着： C中的每个接受者都接受了一个序号在$m :: (n - 1)$的提案，并且任何接受者接受的序号在$m :: (n - 1)$的提案都具有值v。 由于任何大多数接受者组成的集合S至少包含一个C成员，我们可以通过确保以下不变式(invariant))推导出序号为n的提议具有值v： P2c. 对于任何v和n，如果具有值v和序号n的提议被发布（issued），则存在由大多数接受者组成的集合S，使得（a）S中的接受者没有接受任何序号小于n的提议，或者 （b）v是S中所有被接受者接受的，序号小于n的提议中，序号最高的提议的值。 因此我们可以通过维护P2c的不变式来满足P2b。 为了保持P2c的不变性，提议者想要发布序号为n的提议必须获悉序号小于n的提议中，序号最高的提议，如果有已经或将被某些大多数接受者中的每个接受者接受的提议。了解已经被接受的提议很容易;预测将被接受的提议很难。提议者不是试图预测未来，而是通过提取不存在任何此类接受的承诺来控制它。换句话说，提议者要求接受者不再接受任何编号小于n的提议。 这导致以下用于发布提议的算法。 提议者选择一个序号为n的新提议，并向某些接受者组的每个成员发送请求，要求其回复：（a）承诺永远不再接受编号小于n的提案，并且（b）如果有的话，序号小于n的提议中，序号最高的已经被接受。 我将这样的请求称为序号为n的预备请求（prepare request）。 如果提议者收到大多数接受者的请求回复，则它可以发布一个序号为n且值为v的提议，其中v是回复中序号最高的提议值，或者是提议者任意选择的值，如果响应者没有报告任何提议。]]></content>
      <tags>
        <tag>distributed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YouCompleteMe配置与我的vimrc备份]]></title>
    <url>%2F2018%2F02%2F14%2Fycm-vim-cfg%2F</url>
    <content type="text"><![CDATA[作为一个C++爱好者同时也是vi爱好者，我个人觉得vi就是写代码工具不是IDE所以只用少数几个插件，其中YouCompleteMe是我极力推荐的插件，YouCompleteMe主要是自动补全，还有跳转，类型显示等功能，与之前的基于规则补全插件不同的是YouCompleteMe是基于语义，从安装过程就可以看出来。 我用vundle安装和管理插件，YCM的官方安装文档也是推荐vundle，但是我配置好vimrc之后用执行vundle的PlugInstall时发现速度巨慢，其实这个过程本质就是在.vim/bundle中执行 1git clone https://github.com/Valloric/YouCompleteMe.git 之后可以在YouCompleteMe目录中执行 1git submodule update --init --recursive 后面的安装步骤非常简单， 1234sudo apt-get install build-essential cmake #Install development tools and CMakesudo apt-get install python-dev python3-dev #Make sure you have Python headers installedcd ~/.vim/bundle/YouCompleteMe./install.py --clang-completer #Compiling YCM with semantic support for C-family languages 如果很懒在确认安装build-essential，cmake和python-dev之后，执行下面脚本：1234567891011121314151617181920212223242526272829#!/bin/bashlog() &#123; echo "$(date +'%Y-%m-%dT%H:%M:%S%z') INFO $0 | $@"&#125;err() &#123; echo "$(date +'%Y-%m-%dT%H:%M:%S%z') ERROR $0 | $@" &gt;&amp;2&#125;execute() &#123; if (! $@); then err "Failt to $@" exit 1 fi&#125;log "Start to install YouCompleteMe"execute 'cd ~/.vim/bundle/'execute 'rm -rf YouCompleteMe'execute 'git clone https://github.com/Valloric/YouCompleteMe.git'execute 'cd YouCompleteMe'execute 'git submodule update --init --recursive'execute './install.py --clang-completer'log "Success to install YouCompleteMe"exit 0 我的环境是ubuntu-64bit，详细参考官方文档。需要注意的是YCM会默认往上级目录查找直到HOME目录去查找一个.ycm_extra_conf.py的文件（可以自己配置），在.vimrc中我指定了使用官方默认的，配置如下， 1let g:ycm_global_ycm_extra_conf='/home/macduan/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py' 在具体的项目中，在项目的根目录中放一个.ycm_extra_conf.py，并且加上头文件目录的配置，比如，12345678910111213141516171819202122232425flags = ['-Wall','-Wextra','-Werror','-Wno-long-long','-Wno-variadic-macros','-fexceptions','-DNDEBUG',...'-I','/home/macduan/work/opensource/brpc/src','-I','/home/macduan/work/opensource/brpc/src/brpc','-I','/home/macduan/work/opensource/brpc/src/bthread','-I','/home/macduan/work/opensource/brpc/src/butil','-I','/home/macduan/work/opensource/brpc/src/bvar','-I','/home/macduan/work/opensource/brpc/src/json2pb','-I','/home/macduan/work/opensource/brpc/src/mcpack2pb'] 附上我的.vimrc 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" =&gt; Vundle"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""set nocompatible " be iMproved, requiredfiletype off " required" set the runtime path to include Vundle and initializeset rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()" alternatively, pass a path where Vundle should install plugins"call vundle#begin('~/some/path/here')" let Vundle manage Vundle, requiredPlugin 'VundleVim/Vundle.vim'" The following are examples of different formats supported." Keep Plugin commands between vundle#begin/end." plugin on GitHub repoPlugin 'tpope/vim-fugitive'" PowerlinePlugin 'Lokaltog/vim-powerline'" plugin from http://vim-scripts.org/vim/scripts.html" Plugin 'L9'" Git plugin not hosted on GitHubPlugin 'git://git.wincent.com/command-t.git'" Powerline" Plugin 'powerline/powerline'Plugin 'vim-airline/vim-airline'Plugin 'vim-airline/vim-airline-themes'Plugin 'scrooloose/nerdtree'" color schemePlugin 'sickill/vim-monokai'Plugin 'junegunn/seoul256.vim'Plugin 'tomasr/molokai'"Cpp hightPlugin 'octol/vim-cpp-enhanced-highlight'" DoxygenPlugin 'vim-scripts/DoxygenToolkit.vim'" TaglistPlugin 'vim-scripts/taglist.vim'" YouCompleteMePlugin 'Valloric/YouCompleteMe' "git clone it from github is rather quicker than this" git repos on your local machine (i.e. when working on your own plugin)" Plugin 'file:///home/gmarik/path/to/plugin'" Install L9 and avoid a Naming conflict if you've already installed a" different version somewhere else." Plugin 'ascenator/L9', &#123;'name': 'newL9'&#125;" All of your Plugins must be added before the following linecall vundle#end() " requiredfiletype plugin indent on " required" To ignore plugin indent changes, instead use:"filetype plugin on"" Brief help" :PluginList - lists configured plugins" :PluginInstall - installs plugins; append `!` to update or just :PluginUpdate" :PluginSearch foo - searches for foo; append `!` to refresh local cache" :PluginClean - confirms removal of unused plugins; append `!` to auto-approve removal"" see :h vundle for more details or wiki for FAQ" Put your non-Plugin stuff after this line"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" Basic Configuration"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""set history=500 " Sets how many lines of history VIM has to remembersyntax on " Enable filetype plugins" Colorcolumnset cc=100hi Search guibg=peru guifg=wheat" Set to auto read when a file is changed from the outsideset autoread" With a map leader it's possible to do extra key combinations" like &lt;leader&gt;w saves the current filelet mapleader = ","let g:mapleader = ","" Smart way to move between windowsmap &lt;C-j&gt; &lt;C-W&gt;jmap &lt;C-k&gt; &lt;C-W&gt;kmap &lt;C-h&gt; &lt;C-W&gt;hmap &lt;C-l&gt; &lt;C-W&gt;l" color schemesyntax enable" colorscheme monokai" colo seoul256" let g:seoul256_srgb = 1colorscheme molokai" let g:rehash256 = 1let g:molokai_original = 1 " use original monokai" these part refer http://harttle.land/2013/11/08/vim-config.htmlset tabstop=4 " Number of spaces that a &lt;Tab&gt; in the file counts for. set shiftwidth=4 " Number of spaces to use for each step of (auto)indent. set expandtab " Use the appropriate number of spaces to insert a &lt;Tab&gt;. " Spaces are used in indents with the '&gt;' and '&lt;' commands " and when 'autoindent' is on. To insert a real tab when " 'expandtab' is on, use CTRL-V &lt;Tab&gt;.set softtabstop=4 set smarttab " When on, a &lt;Tab&gt; in front of a line inserts blanks " according to 'shiftwidth'. 'tabstop' is used in other " places. A &lt;BS&gt; will delete a 'shiftwidth' worth of space " at the start of the line. set showcmd " Show (partial) command in status line.set number " Show line numbers.set showmatch " When a bracket is inserted, briefly jump to the matching " one. The jump is only done if the match can be seen on the " screen. The time to show the match can be set with " 'matchtime'. set hlsearch " When there is a previous search pattern, highlight all " its matches. set incsearch " While typing a search command, show immediately where the " so far typed pattern matches. set ignorecase " Ignore case in search patterns. set smartcase " Override the 'ignorecase' option if the search pattern " contains upper case characters. set backspace=2 " Influences the working of &lt;BS&gt;, &lt;Del&gt;, CTRL-W " and CTRL-U in Insert mode. This is a list of items, " separated by commas. Each item allows a way to backspace " over something. set autoindent " Copy indent from current line when starting a new line " (typing &lt;CR&gt; in Insert mode or when using the "o" or "O" " command). set textwidth=100 " Maximum width of text that is being inserted. A longer " line will be broken after white space to get this width. set formatoptions=c,q,r,t " This is a sequence of letters which describes how " automatic formatting is to be done. " " letter meaning when present in 'formatoptions' " ------ --------------------------------------- " c Auto-wrap comments using textwidth, inserting " the current comment leader automatically. " q Allow formatting of comments with "gq". " r Automatically insert the current comment leader " after hitting &lt;Enter&gt; in Insert mode. " t Auto-wrap text using textwidth (does not apply " to comments) set ruler " Show the line and column number of the cursor position, " separated by a comma. set background=dark " When set to "dark", Vim will try to use colors that look " good on a dark background. When set to "light", Vim will " try to use colors that look good on a light background. " Any other value is illegal. set mouse=a " Enable the use of the mouse. filetype plugin indent onsyntax on""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" " vim-airline/vim-airline""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" "" These lines setup the environment to show graphics and colors correctly.set nocompatibleset t_Co=256" Always show the status lineset laststatus=2" Format the status line" set statusline=%F%m%r%h\ %w\ \ CWD:\ %r%&#123;getcwd()&#125;%h\ \ \ Line:\ %l\ \ Column:\ %clet g:airline#extensions#tabline#enabled = 1" let g:airline#extensions#tabline#left_sep = ' '" let g:airline#extensions#tabline#left_alt_sep = '&gt;'let g:cpp_class_scope_highlight = 1let g:cpp_member_variable_highlight = 1let g:cpp_class_decl_highlight = 1" NERDTreemap &lt;C-n&gt; :NERDTreeToggle&lt;CR&gt;"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" doxygen" Dox DoxAuthor DoxLic DoxUndoc"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""let g:DoxygenToolkit_briefTag_pre="@brief"let g:DoxygenToolkit_paramTag_pre="@Param "let g:DoxygenToolkit_returnTag="@Returns "let g:DoxygenToolkit_authorName="duanmeng@outlook.com"let g:DoxygenToolkit_licenseTag="@License I don't care"let g:DoxygenToolkit_commentType = "C++"let g:ycm_global_ycm_extra_conf='/home/macduan/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py'let g:ycm_collect_identifiers_from_tag_files=1let g:ycm_seed_identifiers_with_syntax=1let g:ycm_confirm_extra_conf=0let g:ycm_key_invoke_completion='&lt;C-/&gt;'let g:ycm_goto_buffer_command='new-or-existing-tab' "open new tabe when jump to definitionlet g:ycm_autoclose_preview_window_after_completion=1 " auto-close preview window after select a completion stringlet g:ycm_autoclose_preview_window_after_insertion=1 " close preview window after leaving insert modennoremap &lt;leader&gt;jd :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt;nnoremap &lt;leader&gt;jdf :YcmCompleter GoToDefinition&lt;CR&gt;nnoremap &lt;leader&gt;jdc :YcmCompleter GoToDeclaration&lt;CR&gt;nnoremap &lt;leader&gt;st :YcmCompleter GetType&lt;CR&gt;nnoremap &lt;F5&gt; :YcmForceCompileAndDiagnostics&lt;CR&gt;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>linux</tag>
        <tag>vi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Epoll的一些事情]]></title>
    <url>%2F2017%2F12%2F24%2Fepoll-notes%2F</url>
    <content type="text"><![CDATA[Epoll出现使得Linux平台上C10K迎刃而解。这里不说epoll的使用，man/google一下即可，只关注三个微小的方面:线程安全，触发机制以及客户端断开。 Epoll线程安全吗？这个网上居然搜到的资料不多，有个简短的说法（from gejun）, epoll_wait和epoll_ctl都是线程安全的, 前者带acquire语意, 后者带release语意, 换句话说, 如果epoll_wait后能拿到某个新fd的事件, 那么对应的epoll_ctl前发生的内存修改都可见. 其实从源码eventpoll.c的注释上一看就一目了然（主要是懒不想看源码）,详细请看注释和源码，epoll有3层锁，从上到下的顺序如下： epmutex(mutex) eventpoll_release_file()和ep_free()需要一个全局锁 ep-&gt;mtx(mutex) event loop中从内核空间拷贝数据到用户空间需要一个允许休眠的锁 ep-&gt;lock(spinlock) 从IRQ context调用的wake_up()需要操作poll callback中的对象，而在poll callback中不能休眠，所以用spinlock 边沿触发和水平触发区别和应用场景， 水平触发，只要fd可读/写（缓冲区不空/不满），就一直触发。 边沿触发，只有fd可读/写状态发送变化（翻转），才会触发。 再次引用gejun的观点： 在eventloop类型(包括各类fiber/coroutine)的程序中， 处理逻辑和epoll_wait都在一个线程， ET相比LT没有太大的差别。 反而由于LT醒的更频繁， 可能时效性更好些。 在老式的多线程RPC实现中， 消息的读取分割和epoll_wait在同一个线程中运行， 类似上面的原因， ET和LT的区别不大。但在更高并发的RPC实现中， 为了对大消息的反序列化也可以并行， 消息的读取和分割可能运行和epoll_wait不同的线程中，这时ET是必须的，否则在读完数据前，epoll_wait会不停地无谓醒来。 客户端断开某服务端的fd与客户端的连接断开会使得该fd状态变成可读，但是在read的时候会返回0即EOF，这时可以close并且将该fd从epoll events中移除(EPOLL_CTL_DEL)。]]></content>
      <tags>
        <tag>multithreading</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Cheat Sheet (keep updating ...)]]></title>
    <url>%2F2017%2F12%2F16%2FC-Notes%2F</url>
    <content type="text"><![CDATA[有一阵子没有关注C++了，随着年纪增长记忆力下降，感觉需要一个小抄记录些C++的知识可以随时查阅，碰到什么值得记录知识点就记录在这里，时不时更新下这个文档。 1 Lvalues &amp; Rvalues lvalue和rvalue继承自C语言，在C语言中是这样定义的：能在赋值操作左边的是lvalue而rvalue不能 但是在C++中则lvalue和rvalue的区别则复杂很多，大致说来就是一个对象被用作右值时，用的是对象的值（内容），一个对象被用作左值时，用的是对象的标识（内存中的位置） 对于运算符（赋值，取址等操作）来说，不同之处是运算符需要lvalue还是rvalue，返回的是lvalue还是rvalue；重要的一点就是可以在需要rvalue的地方使用lvalue）在需要lvalue的地方则不能使用rvalue（比如std::move） 赋值操作需要lvalue在赋值运算符左边（右边都可以），且产出的是一个左值 取址操作需要lvalue，且返回的是一个rvalue的指针， 解引用，下标操作（vector、 string等的[]运算符）和迭代器解引用使用lvalue和rvalue都可以，且都返回的是lvalue 迭代器自增减需要lvalue，且返回lvalue 参考： C++ Primer 5th Edition 4.1.1 P135 2 Named CastNamed cast背后的思想就是让程序员显示的表达转型（cast）的意愿1。 2.1 static_caststatic_cast可用于C风格的转型（int to double， double to int， char to int等），const类型到non-const类型的转换，相同层级类指针之间的转型，子类指针向基类指针转型，基类指针向子类指针转型（不安全，必须确认指向的对象是子类对象）。 2.2 const_castconst_cast用于去除const特性。 2.3 reinterpret_castreinterpret_cast用于不安全的指针之间转型和int到指针转型，必须清楚其带来的后果。 2.4 dynamic_castdynamic_cast用于运行时具有继承关系的类之间（子类到基类，基类到子类，兄弟类之间）的指针和引用的安全转型，如果失败指针转型返回空，引用转型抛出bad_cast异常。但是G和B家的C++编程规范都是禁止使用dynamic_cast；除非在UT代码中，比如测试工厂模式类创建的对象类型，或者管理对象与它们的mock之间的关系。为什么要禁止呢，主要是容易出错，会造成判断分支过多不易维护，可以用其它机制比如多态来代替。这里贴出G家编程规范对其缺点描述的原文： Cons Querying the type of an object at run-time frequently means a design problem. Needing to know the type of an object at runtime is often an indication that the design of your class hierarchy is flawed. Undisciplined use of RTTI makes code hard to maintain. It can lead to type-based decision trees or switch statements scattered throughout the code, all of which must be examined when making further changes. Decision RTTI has legitimate uses but is prone to abuse, so you must be careful when using it. You may use it freely in unittests, but avoid it when possible in other code. In particular, think twice before using RTTI in new code. If you find yourself needing to write code that behaves differently based on the class of an object, consider one of the following alternatives to querying the type: Virtual methods are the preferred way of executing different code paths depending on a specific subclass type. This puts the work within the object itself. If the work belongs outside the object and instead in some processing code, consider a double-dispatch solution, such as the Visitor design pattern. This allows a facility outside the object itself to determine the type of class using the built-in type system. 参考1 TC++PL 11.5.2. Named Casts2 https://google.github.io/styleguide/cppguide.html#Run-Time_Type_Information__RTTI_3 https://google.github.io/styleguide/cppguide.html#Casting 3 -pthread &amp; -lpthread -lpthread就是链接选项，告知编译器链接pthread库。 -pthread告诉编译器链接pthread库，同时告知编译器预处理时设置_REENTRANT宏，使得libc的头文件选择thread-safe的实现。 下面示例代码1很好的展示了区别 1234567$gcc -pthread -E -dM test.c &gt; dm.pthread.txt$gcc -E -dM test.c &gt; dm.nopthread.txt$diff dm.pthread.txt dm.nopthread.txt 152d151&lt; #define _REENTRANT 1208d206&lt; #define __USE_REENTRANT 1 为什么diff结果为什么有两个宏被设置了呢2 Defining _REENTRANT causes the compiler to use thread safe (i.e. re-entrant) versions of several functions in the C library. It simply defined _REENTRANT for the preprocessor. Somewhere in the associated code, you’ll probably find #ifdef _REENTRANT or #if defined(_REENTRANT) in at least a few places. Also note that the name “_REENTRANT: is in the implementer’s name space (any name starting with an underscore followed by another underscore or a capital letter is), so defining it means you’ve stepped outside what the standard defines (at least the C or C++ standards). 参考链接 1 https://stackoverflow.com/questions/23250863/difference-between-pthread-and-lpthread-while-compiling2 https://stackoverflow.com/questions/2601753/what-is-the-reentrant-flag 4 一个String类展示四种constructor12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstring&gt; // strlen, strcpy#include &lt;utility&gt; // move#include &lt;iostream&gt; // coutclass String final &#123;public: String() : _data(new char[1]) &#123; std::cout &lt;&lt; "Default Constructor\n"; &#125; explicit String(const char* src) : _data(new char[std::strlen(src) + 1]) &#123; std::cout &lt;&lt; "char* constructor\n"; std::strcpy(_data, src); &#125; ~String() &#123; delete []_data; &#125; String(const String&amp; rhs) : _data(new char[rhs.size() + 1]) &#123; std::cout &lt;&lt; "copy constructor\n"; std::strcpy(_data, rhs._data); &#125; String&amp; operator=(const String&amp; rhs) &#123; // copy &amp; swap idiom std::cout &lt;&lt; "assign constructor\n"; String tmp(rhs); std::swap(_data, tmp._data); return *this; &#125; String(String&amp;&amp; rhs) : _data(rhs._data) &#123; std::cout &lt;&lt; "move copy constructor\n"; rhs._data = nullptr; &#125; String&amp; operator=(String&amp;&amp; rhs) &#123; std::cout &lt;&lt; "move assign constructor\n"; std::swap(_data, rhs._data); return *this; &#125; size_t size() const &#123; return std::strlen(_data); &#125;private: char* _data;&#125;;int main(int, char**) &#123; String defaultConstructor; String charPointerConstructor("hello"); String copyConstructor1(charPointerConstructor); String copyConstructor2 = charPointerConstructor; defaultConstructor = copyConstructor1; // copy then assign constructor std::cout &lt;&lt; copyConstructor1.size() &lt;&lt; std::endl; String moveCopyConstructor(std::move(copyConstructor1)); moveCopyConstructor = String("hello"); // char pointer constructor then move assign constructor moveCopyConstructor = std::move(copyConstructor2); // move assign std::cout &lt;&lt; copyConstructor1.size() &lt;&lt; std::endl; return 0;&#125; $./a.outDefault Constructorchar constructorcopy constructorcopy constructorassign constructorcopy constructor5move copy constructorchar constructormove assign constructormove assign constructorSegmentation fault (core dumped)]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译]The Google File System]]></title>
    <url>%2F2017%2F12%2F07%2Fgfs-notes%2F</url>
    <content type="text"><![CDATA[据说The Google File System是google老三篇中最有诚意的一篇，包含了很多分布式理论知识点（primary-secondary，lease，replica，log，checkpoint等）本文是该论文1-5章的翻译（性能等章节就不翻译了），尽量基于中文阅读习惯和用短句的论文撰写习惯翻译，对于自己感觉翻译不太准确或者可能有歧义的地方会贴上英文原文。 摘要我们设计并实施了Google文件系统，一种用于大规模分布式数据密集型应用的，可扩展的分布式文件系统。它虽然运行在廉价普通机器上，但是提供容错和向海量客户交付了高集成性能（high aggregate performa）。 在与早期的分布式文件系统共享相同的设计目标的同时，我们的设计驱动于对我们应用工作负载和技术环境的观察，它无论是当前还是未来都反映了与早期文件系统显著的不同的假设。这导致我们重新审视传统选择，从根本上探索不同的设计要点。 这个文件系统已经成功满足了我们的存储需求。它作为存储平台被广泛部署在Google内部，用来存储被我们服务生成和处理的数据以及研究和开发工作需要的海量数据集。迄今为止最大的集群提供了数百T的存储（译者注：现在T级别的不算大，但在本文发表时还是很猛的），它们分布在超过一千台机器上的数千块磁盘上，并且被数百个客户端并发访问。 在本文中，我们提出（present）了文件系统接口扩展旨在支持分布式应用，讨论了我们设计的许多方面，以及来自微基准（micro-benchmarks）和真实使用的测试报告（report measurements）。 类别和主题描述分布式文件系统 通用术语设计，可靠性，性能，测量 关键词容错，可扩展性，数据存储，存储集群 1. 介绍我们设计并实施了Google文件系统来满足Google迅速增长的数据处理需求。GFS与早期的分布式文件系统共享许多相同的设计目标，比如性能，可扩展性，可靠性和可用性。然而，它的设计驱动于对我们应用工作负载和技术环境的关键观察，它无论是当前还是未来都与反映了与早期文件系统显著的不同的假设。我们重新审视了传统选择，从根本上探索不同的设计要点。 第一，组件故障是常态（the norm rather than the exception）。该文件系统由数百甚至数千台存由廉价普通（commodity）硬件组装的存储机器，并且被大量的客户机器访问。组件的数量和质量几乎保证了任何时间都有一些组件失效甚至有些无法从当前错误中恢复。我们见过由应用bugs，操作系统bugs和人为错误，还有硬盘错误，内存，连接器，网络和电源供应引起的问题。因此，持续监控，错误探测，容错和自动恢复必须集成到系统中。 第二，传统标准下文件都很大。GB级的文件很常见。每个文件通常包含许多应用对象，比如Web文档。当我们通常要处理快速增长数据集组成的数十亿的对象时，不适合用数十亿大约KB大小的文件去管理。因此，设计假设和参数，例如I/O操作，块大小（blocksize）必须被重新审视（revisited）。 第三，大部分文件是因追加数据被突变（mutated）而不是覆盖已有数据。某个文件里的随机写实践上不存在。一旦写入这些文件只会被读取而且经常是顺序读。多种数据都共有（share）这些特征。一些可能组成数据仓库（constitute large repositories）被数据分析程序扫描。一些可能是运行应用持续生成的数据流。一些可能是归档的数据。一些可能是一台机器产出在另一台机器同时或者后面适时（whether simultaneously or later in time）被处理的中间数据， 基于这种大文件访问模式，追加成为性能优化和原子性保证的关注点，与此同时客户端缓存数据块失去了吸引力。 第四，综合设计应用和文件系统API，通过增加灵活性，对整个系统有好处。例如，我们放松了（relaxed）GFS的一致性模型来极大的简化了该文件系统且没有对应用施加繁重的负担。我们还引入了一种原子追加操作，这样多个客户端可以对同一文件并发追加，而它们之间不需要额外的同步。本文后面会详细讨论这些。 多个GFS集群目前为不同的目的被部署了。最大的有1000个存储节点，将近300TB的磁盘存储，且被不同机器上的数百个客户端大量持续访问。 2. 设计概览2.1 假设在为我们需求设计文件系统时，我们被挑战与机会并存的假设指导。我们前面提到了一些关键观察，现在展示（lay out）我们假设的更多细节。 该系统由经常故障的廉价日用硬件组装（inexpensive commodity components）。它在日常工作中必须持续自我监控和探测，容错和及时从组件故障中恢复。 该系统存储了适当量的（a modest number of）大文件。我们预计百万个文件，每个一般100MB或者更大。多个GB大小的文件很常见，应该被有效管理。小文件必须被支持，但不需要专门优化。 工作负载主要由两类读组成：大量流式读和少量随机读。在大量流式读中，单个操作一般读数百KB，更常见的是1MB或者更多。来自同一客户端的成功操作经常读取一个文件的相邻区域。一次少量随机读一般在任意偏移上读取数KB。性能敏感的应用往往批量和排序它们的少量读来有规律读取文件而不是前后交叉（batch and sort their small reads rather than go back and forth）。 工作负载还包括很多大量顺序写，追加数据到文件中。通常操作的大小和读一样。任意位置随机写被支持，但是不必高效。 该系统必须高效的实现明确的语义来支持多个客户端并发追加数据到同一文件。我们的文件经常被用作生产消费者队列或者多路归并。数百个生产者，每个机器运行一个，将会并发追加一个文件。减少原子性中同步的开销是必要的。文件可能稍后被读取，或者一个消费者同时读取这个文件。 高可持续带宽比低延迟更重要。我们目标应用大部分都非常重视高速批处理数据，很少有对单次读写有及时响应的需求。 2.2 接口GFS虽然没有实现标准的API例如POSIX，但是提供了类似的文件系统接口。文件在目录中按层级组织，路径名字标识。我们支持常规操作来创建，删除，打开，关闭，读取和写入文件。此外，GFS支持了快照和记录追加操作。快照用低代价创建文件副本或者目录树。记录追加允许多个客户端并发追加数据到相同文件并且保证每个客户端追加的原子性。实现结果的多路归并和多个客户端同时追加的生产消费者队列且不需要额外锁非常有用。我们发现这类文件对于构建分布式应用非常有价值。快照和追加记录将分别在3.4和3.3节讨论。 2.3 架构图1 GFS架构 如图1所示，一个GFS集群由一个master和多个块服务器组成且被多个客户端访问。每个都是运行用户进程的普通Linux机器。只要机器资源允许，可以接受一个块服务器和一个客户端可以运行在同一台机器上和不稳定应用代码（flaky application code）引起的不稳定性。文件被分成固定大小的块。每个块在创建时master会分配一个不可变且全局唯一的64位块句柄（块 handle）来标识它。块服务器在本地磁盘以Linux文件形式存储块，通过块句柄和字节区间（块 handle and byte range）读写块数据。为了可靠性，每个块在多个块服务器上有副本（replica）。我们默认存储三个副本，但是用户可以为文件命名空间不同区域指定副本级别。 master维护了所有文件系统的运元数据（metadata）。它包括命名空间，访问控制信息，文件到块的映射和当前块的位置。master还控制系统范围的活动，例如块租约（chunk lease）管理，孤儿块（orphaned 块）垃圾回收和块在块服务器间迁移。master周期性地发送心跳消息来传递指令和收集状态。GFS客户端代码链接到每个分布式应用，它实现了文件系统API，并且根据应用程序行为与master和块服务器通信来读写数据。 客户端与master交互进行元数据操作，但是所有数据承载（data-bearing）通信直接与块服务器进行。我们不提供POSIX API，因此不需要深入到（hookin）linux vnode层。无论是客户端还是块服务器都不缓存数据。因为大部分应用流式读超大文件或者有太巨大而无法缓存的工作数据集，所以客户端缓存没有任何好处。没有了缓存通过消除缓存一致性问题（cache coherence）简化了客户端和系统整体。（然而，客户端的确会缓存元数据。）块服务器不需要缓存文件数据，因为块被存储为本地文件，所以Linux的缓冲区缓存在内存中已经保留了经常被访问的数据。 2.4 单Master只有一个Master极大地简化了我们的设计，使得Master能够使用全局信息进行复杂的块放置（块 placement）和副本决策（replica decision）。然而，我们必须最小化master对读写的参与使其不成为瓶颈。客户端从不通过master读写文件数据。相反，客户端询问master应该与哪个块服务器联系。它在有限时间内缓存这个信息并且直接许多后续操作都直接与块服务器交互。 让我们结合图1用一次简单的读来解释交互过程。首先，使用固定大小的块，客户端将应用指定文件名字和字节偏移翻译成文件中的块 index。然后，它向master发送一个包含文件名和块 index的请求。Master回复相应的块 handle和副本位置。客户端用文件名和块 index作为键（key）缓存这个信息。 客户端最后向其中一个副本，很有可能是最近的一个，发送请求。这个请求包含了块 handle和块内的字节区间。后续读取相同块不再需要client-master交互直到缓存信息过期或者文件被重新打开。事实上，客户端一次请求中一般请求多个块，master也可以在回复中包含紧跟着那些被请求的块的信息。这个额外的信息避免了一些未来的client-master交互，几乎没有额外代价。 2.5 块 Size块 size是关键设计因素之一。我们选择了64MB，它比常规文件系统block size大很多。每个块副本作为一个普通Linux文件存储在一台块服务器上，仅在需要的时候扩展。惰性空间分配避免了内部碎片造成的空间浪费，这可能是最大的反对大块 size的原因。 大块 size有一些重要优势。首先，它减少了客户端与master交互的需求，因为相同块上的读写只需要向master的一次初始请求获取块位置信息。这个减少对我们的工作负载至关重要，因为应用基本上顺序读写大文件。甚至对于小型随机读，客户端可以方便地缓存一个多TB（multi-TB）工作集的所有块位置信息。然后，因为对于一个大块客户端很可能对一个给定的块持续执行多次操作，它可以通过对一个块服务器在一定时间内保持一个持久的TCP连接来减少网络开销（network overhead）。最后，它减少了存储在master上的元数据大小。这使得我们可以把元数据存储在内存，这也带来了其它好处，我们将在2.6.1节讨论。 在另一个方面，大块 size即使有惰性空间分配还是有缺点的。一个小文件由少量块，可能一个块组成。如果许多客户端访问相同的文件（译者注：就是这些小文件），存储这些块的块服务器可能变成热点。在实践中，热点问题还不是主要问题，因为我们的应用大部分顺序读大mult-块文件。 然而，热点确实出现了，当GFS在一个批队列（batch-queue）系统中被第一次使用时：一个单块可执行文件被写入GFS，然后在几百台机器上同时启动。少数几个存储这个可执行文件的块服务器被几百个并发请求打爆了（overloaded）。我们通过增加这种文件的副本数量和错开batch-queue系统错开应用启动时间修复了这个问题。一个潜在的长期解决方案是允许客户端在这种情况下从其它客户端读取数据。 2.6 元数据Master存储了3种主要类型的元数据：文件和块命名空间（namespace），文件到块的映射和每个块副本的位置。所有元数据保存在master的内存中。前两种类型（namespaces和file-to-块 mapping）也会被通过记录突变（mutations）操作日志（by logging mutations to an operation log）存储在master本地磁盘和复制到远端机器。使用日志使得我们可以简单，可靠地更新master状态和在master崩溃时保持一致性。Master不持久化块位置信息。相反，它在启动时向每个块服务器询问块位置信息，和某个块服务器加入集群时询问。 2.6.1 内存数据结构（In-Memory Data Structure）因为元数据存储在内存中，master操作非常快。此外，master可以后台方便和高效地周期性扫描它的整个状态。周期性扫描被用于实现块垃圾回收，块服务器故障时副本重复制（re-replication），块迁移来均衡负载和跨块服务器磁盘空间。4.3和4.4节将会进一步讨论这些活动。 这种内存唯一（memory-only）方法的一个潜在担忧是块数量，因此整个系统容量受限于master的内存大小。这在实践中不是个严重问题。Master为每个64MB块维护不到64字节的元数据。大多数块是满的，因为大多数文件包含许多块，只有这些文件的最后一个块可能部分填充。类似的，文件命名空间数据一般需要不到64字节每个文件，因为它使用前缀压缩将文件名存储在一起。 如果必须支持更大规模的文件系统，相对于存储元数据在内存带来的简单性，可靠性，性能和灵活性，添加额外内存只是很小的代价。 2.6.2 块位置Master不持久保存给定块存储在哪个块服务器的记录。它启动时只是从块服务器获取这些信息。Master此后可以保持最新，因为它控制所有块的放置和通过周期性心态消息监控块服务器状态。 我们最初尝试保持块位置信息持久化在master，但是我们发现启动时和此后周期性从块服务器请求这些数据更加简单。这样解决了块服务器加入和离开集群，更改名字，故障，重启等带来的master与块服务器的同步问题。在几百个服务器组成的集群中，这些事件经常发生。 这种设计的另一种理解是意识到一个块服务器对于它有什么块有最终话语权。在master上维护这些信息的一致性视图毫无意义，因为块服务器上的错误可能导致块突然消失（例如，一个硬盘可能故障或者失效）或者运维人员可能重命名一个块服务器。 2.6.3 操作日志操作日志包含关键元数据改变的历史记录。它对于GFS至关重要（It is central to GFS）。它不仅是元数据唯一的持久记录而且还充当定义并发操作顺序的逻辑时间线。文件和块还有它们的版本（参见4.5节）都是被它们被创建时的逻辑时间唯一和永久标识。 由于操作日志非常重要，我们必须可靠的存储它，不能让变化对客户端可见直到元数据变化被持久化。否则，我们事实上失去了整个文件系统或者最近客户端操作即使这些块本身存在。因此，我们在多台远端机器上复制操作日志，且只有当相关日志记录刷入（flush）到本地和远端磁盘后才会回复客户端操作。Master将多条日志记录一起批量刷入从而减少刷入和复制对整个系统吞吐量的影响。 Master通过回放操作日志恢复它的文件系统状态。为了减少启动时间，我们必须保持日志小。每当日志增长到一定大小时Master设置检查点（checkpoint），这样它可以通过从磁盘加载最新检查点和回放检查点之后有限的日志记录来恢复。检查点是一种紧凑B树形式，可以直接映射到内存和被用于命名空间查找而不需要额外解析。这进一步加速了恢复和改善了可靠性。 因为建立一个检查点需要一些时间，所以master以这样的方式组织它的内部状态使得新检查点被创建时不会推迟到来的突变（mutations）。Master切换到新的log文件然后单独线程创建新检查点。新检查点包含了所有切换前的突变。在一个有几百万文件的集群里它可以在一分钟内被创建。完成后它会被写入本地和远端磁盘。 恢复只需要最近完成的检查点和后续日志文件。旧的检查点和日志文件可以随时删除，虽然我们会保留一些来容灾。设置检查点时的错误不影响正确性，因为恢复代码探测并且跳过不完整的检查点。 2.7 一致性模型GFS的宽松一致性模型支持我们的高度分布式的应用，但实现上仍然相对简单高效。我们现在讨论GFS的保证和它们对应用程序意味着什么。我们还突出GFS如何维护这些保证但是细节放到本文的其它部分。 2.7.1 GFS的保证文件命名空间突变（比如，文件创建）是原子的。它们只被master处理：命名空间锁保证原子性和正确性（4.1节）；master的操作日志定义全局操作顺序。 表1： 突变后文件区域状态 一次数据突变（mutation）后文件区域的状态依赖于突变的类型，无论成功或失败还是并发突变。表1总结了结果。文件区域是一致的如果所有客户端将会一直看到相同的数据，不管他们从哪个副本读取。文件数据突变后区域是定义的，如果它是一致的而且客户端将会看到突变对其整体的写入。当一次突变成功且没有被并发写干扰，受影响的区域是定义的（而且暗含一致性）：所有客户端将会看到突变写入了什么。并发成功突变使得区域未定义但是一致：所有客户端看到相同的数据，但是无法反映谁的突变被写入了。通常，它由多个突变产生的混合片段组成。一次失败的突变让区域不一致（因此也未定义）：不同的客户端可能在不同时间看到不同数据。我们下面描述我们的应用如何区分定义区域与未定义区域。应用不需要进一步的区分不同类型的未定义区域。 数据突变可能是写或者记录追加。一次写导致数据被写到应用定义的文件偏移。一次记录追加导致数据（记录 the “record”）被原子地追加至少一次甚至在并发突变发生时，但是是在GFS选择的偏移（3.3节）。（相反，一次常规的追加只不过是写到客户端认为的当前文件末尾。）偏移被返回给客户端并且标记在一个定义区域的开头，这个区域包含这个记录。另外，GFS可能插入填充（padding）或者在之间有重复记录。他们占用的区域被认为是非一致的，而且通常被用户数量所限制。 一系列的成功突变之后，突变文件区域被保证是定义的且包含最后一次突变写入的数据。这个的实现是通过（a）GFS通过在所有副本上按照相同顺序对块实施（3.1节），和(b)采用块版本号来探测任何因为块 server宕机（4.5节）造成副本变质（stale）。变质副本永远不会参与突变或者提供位置信息给向master查询的客户端。它们是最早被回收的垃圾。 因为客户端缓存块位置，它们可能会在该信息刷新之前从一个变质的副本读取数据。这个窗口被缓存条目的超时和下次打开该文件所限制，下次打开该文件会从cache为该文件清除所有的块信息。此外，因为绝大部分文件是只能追加的，一个变异副本通常会返回一个过早的块结尾而不是过期的数据。当一个读客户端重试和联系master，它将会立即拿到当前块的位置。 一次成功突变很久之后，组件失效依然可以腐化或者摧毁数据。GFS通过定期master与所有块服务器握手来标识失效的块服务器和通过校验和（checksumming 5.2节）来探测数据腐化（data corruption）。一旦问题发生，数据被尽快从有效的副本中恢复（4.3节）。一个块只有在它所有的副本在GFS反应，通常在几分钟内，之前都丢失才会不可逆的丢失。甚至在这种情况下，它变得不可达，但是没有腐化：应用接收到明确的错误而不是腐化的数据。 2.7.2 对应用的影响GFS应用可以配合一些技术适应宽松一致性模型，这些技术也被其它目的所需要：依靠追加而不是覆盖，检查点，以及编写自我验证，自我识别记录。 实际上，所有我们的应用通过追加而不是覆盖对文件进行修改。一个典型应用就是，一次写（writer）从头到尾生成一个文件。它在写完所有数据之后自动重命名这个文件成一个永久名字，或者周期性地标记（checkpoints）多少已经成功写入。检查点可能也会包含应用层校验和。读操作（readers）判定和处理只到检查点最后的文件区域，这些区域是已知处于定义状态。不考虑一致性和并发问题，这种方法效果很好（served us well）。追加远比随机写高效和灵活应对应用失效。检查点允许写操作（writers）增量重启（restart incrementally）和避免读操作（readers）处理成功写入但是从应用角度看仍然不完整的数据。 在其它典型应用中，许多写操作（writers）为一个归并结果并发追加一个文件或者作为一个生产消费者队列。记录追加至少追加一次（append-at-least-once）语义保留了每个写操作的输出。读操作处理偶尔填充和重复按照如下方式（as follows）。每条写操作（writer）准备的记录包含校验和等额外信息，这样它的有效性可以被验证。一个读操作（reader）可以通过校验和识别并丢弃额外的填充和记录碎片。如果它无法容忍偶尔的重复（例如，如果它们触发非幂等运算），它可以用记录中的唯一标识过滤它们，唯一标识符经常也会被用来命名相应的应用实体例如网页文档。这些为记录读写的功能（除了删除重复数据）在库代码里，被我们的应用程序共享，也可以被用于Google其它文件接口的实现。这样相同顺序记录，加上少量重复，总是被交付给记录读操作（reader）。 3. 系统交互我们设计的这个系统最小化了master在所有操作中的参与。在这个背景下，我们现在描述客户端，master和块服务器如何交互来实现数据突变，原子记录追加，和快照。 3.1 租约和突变顺序突变（mutation）是一次操作改变块的内如或者metadata，例如写或者追加操作。每次突变在所有块的副本上执行。我们用租约来维护副本上一致的突变顺序。Master授予给其中一个副本授予块租约，我们称之为首要（primary）。首要副本对每个块上所有突变采取连续顺序。所有副本在实施突变时采用这个顺序。因此，全局突变顺序由master选择的租约授予顺序和一次租约内首要副本（primary）指定的序列号定来定义。 租约机制是被设计用来减少master管理的开销。一次租约有初始化的60s超时。然而随着这个块持续被突变，首要副本可以请求并且通常不定期收到延长。这些延长请求和授予（消息)通过心跳包携带定期在master和所有块服务器上交互。Master可能有时尝试在超时前撤销租约（例如，master想制止正在被重命名文件的突变）。甚至如果master失去了与首要的联系，它可以在老的租约过期后安全地授予一个新的租约给另一个副本。 图2 写入控制与数据流 在图2中，我们通过跟随一次写的控制流的步骤解释这个过程。 客户端向master询问哪个块服务器握有这个块的租约和其它副本的位置。如果没有任何块有租约，master选择其中一个副本授予（未显示）。 Master回复首要副本的标识（identity）和其它副本的位置。客户端缓存这个数据用于未来的突变（mutations）。它只有当首要副本变得不可达或者回复说不再握有租约才需要再次联系master。 客户端把数据推到（push）所有的副本。这个操作客户端可以任意顺序。每个块服务器会将数据存储在内部的LRU缓冲缓存直到数据被使用或者老化。通过数据流与控制流解耦，我们可以通过基于网络拓扑调度繁重的数据流而不管哪个块服务器是首要的来改善性能。3.2节会进一步讨论这些。 一旦所有的副本确认收到数据，客户端发送写请求给primary。这个请求标识（identifies）了之前推送到所有副本的数据。Primary给所有收到的突变赋予连贯有序的序号，提供了必要的序列化。它序号应用突变到本地状态。 Primary转发了写请求给所有的二级副本（secondary replicas）。每个副本按照Primary分配的相同序号实施突变。 所有副本回复Primary操作已经完成。 Primary回复客户端。任何副本上的任何错误都会报告给客户端。如果出现错误，primary和任意二级副本子集可能已经被成功写入。（如果写操作在primary上就已经失败了，它就不会被分配序列号和转发。）客户端请求被认为失败了，修改的区域处于不一致状态。我们的客户端代码通过重试失败的突变来处理这样的错误。在重试整个写之前，它会重试步骤(3)到步骤(7)。 如果应用的写很大或者跨块边界，GFS客户端会将其分解成多个写操作。它们都遵循上面所述控制流，但是可能被其它客户端的并发操作交错（interleaved）或者重写（overwritten）。 因此，共享文件区域最终可能包含来自不同客户端的片段，虽然这些副本将会是一致的，因为各个操作是完全成功的且在所有副本上是相同顺序的。这使得文件区域处于2.7节所定义的一致但是未定义的状态（consistent but undefined）。 3.2 数据流我们将数据流与控制流解耦来有效利用网络。控制流从客户端到primary然后到所有的secondaries，数据沿着仔细（how?）挑选的块服务器链，以流水线的形式线性被推送。我们的目标是充分利用每一个机器的网络和带宽，避免网络瓶颈和高延迟链路，和减小延迟来推送所有数据。 为了充分利用每台机器的网络和带宽，数据沿着集群服务器的线性推送。而不是分布在其它拓扑（例如，树）中。因此，每个机器的全部出口带宽用于传输，数据尽可能快的传输，而不是分割成多个接收方。 为了尽可能地避免网络瓶颈和高延迟链路（例如，交换机之间的链路通常都是双工的），每个机器将数据转发到网络拓扑中“最接近”的，还未收到数据的机器中。假设客户端正在把数据从块服务器 S1推送到S4。它发送数据到最近的块服务器，如S1。S1转发给离他最近的，如S2，把数据从S2推送到S4。类似地，S2转发给离它更近的S3或者S4，如此类推传递。我们的网络拓扑足够简单，可以通过ip地址准确估算“距离”（译者: how？）。 最后，我们通过在TCP上以流水线的方式传输数据（piplelining the data）来最小化延迟。 一旦块服务器收到数据，它就立即开始转发。流水线的方式（pipelining）对我们的帮助特别大，因为我们使用全双工的交换网络链路（译者：WTF）。立即发送数据不会减小接受速率。没有网络拥塞的情况下，传输B bytes到R个副本的理想的时长是 $B / T + RL$，其中T是网络吞吐量，L是两台机器传输字节的延迟。我们的网络链路一般是100Mbps(T)，L远低于1ms。因此，1MB可以在大于80ms内被分发。 3.3 原子记录追加GFS提供了一个名为记录追加（record append）的原子追加操作。在传统的写入中，客户端指定数据写入的偏移量。 并发写入同一地区不可序列化：该地区末尾可能包含来自多个客户端的数据片段。然而，在一次记录追加中，客户端只指定数据。GFS至少原子地追加一次到文件（例如，一个连续的字节序列），其offset是由GFS选择并且返回给客户端。这和没有竞争条件下多个并发写入以O_APPEND的模式写入一个文件。 记录追加在分布式应用中被大量使用，其中许多不同机器上的客户端并发的追加相同的文件。如果他们通过传统方式写入的话，客户端们将需要额外的，复杂和昂贵的同步。在我们的工作负载中，这样的文件经常作为多生产者/单消费者队列或者包含来自许多不同客户端的归并的结果。 追加记录是一种遵循3.1节中控制流的突变，只在primary（primary-secondary）上需要一点额外的逻辑。客户端推送数据到所有文件末尾块的副本，然后发送请求到primary。primary检查如果追加记录是否超过最大限制（64MB）。如果是，它会填充块到最大，告诉secondaries采取相同操作，并且回复客户端表示这个操作会在下一个块上重试。（记录追加被限制在至少还有1/4最大尺寸的块上，使得最坏碎片情况在可接受水平。）如果记录没有超过最大尺寸，这个也是常见的，primary追加数据到它的副本，告知secondaries以完全相同的偏移写数据，最后回复客户端操作成功。 如果一个记录追加在任何一个副本失败了，客户端重试这个操作。因此相同块的副本中可能包含不同的数据，甚至有相同数据的全部或部分重复。GFS不保证所有副本字节相同。它只会保证数据作为原子单元被至少写入一次。这个特性很容易从简单的观察中得出，操作要成功，数据必须在某些块的所有副本上以相同的偏移被写入。此外，在此之后，所有副本至少到了记录尾部，因此任何未来记录的将会被分配一个更高的偏移或者不一样的块，即使某个不同的块在后面成为primary。就我们的一致性保证而言，记录成功追加操作已经写入数据的区域是定义的（因此是一致的），反之交叉区域是不一致（因此未定义).如我们在2.7.2节讨论的，我们的应用可以处理不一致的区域。 3.4 快照快照操作是瞬间对文件和目录树（the “source”）做一个拷贝，同时尽量减少正在进行的突变带来的干扰。我们的用户用它快速创建大量数据集分支拷贝（经常递归的拷贝这些拷贝），或者在尝试后面可以被轻松提交或者回滚的修改之前设置当前状态的检查点。 就像AFS[5]，我们用标准的写时拷贝（copy-on-write）技术来实现快照。当master（译者注：古今奇谈一些白左认为这个master/slave政治不正确），它首先撤销即将被快照的文件的块上的未到期的租约。这确保了对这些块的任何后续写入都需要与主机进行交互以找到租约持有者。这个将会给master机会去首先创建块的新拷贝。 租约被撤销或过期后，主机将操作日志落到磁盘。然后，通过复制源文件或目录树的元数据，将此日志记录应用到其内存状态。新创建的快照文件指向与源文件相同的块。 在快照操作之后，当客户机第一次希望写入块 C时，它向主服务器发送请求以找到当前租约持有者。主注意到块 C的引用计数大于1。它推迟了对客户端请求的应答，而是选择了一个新的块句柄C′。然后，它要求每个具有当前副本C的块服务器创建一个新的块称为C′。通过在相同块服务器上创建与原始块相同的新块，我们可以确保数据可以在本地复制，而不是通过网络（磁盘的速度大约是100Mb是以太网链路的三倍）。从这点上看，请求处理与任何块的处理没有什么不同：master正常授予新块 C’中一个副本租约，并回复给客户端，它可以正常写入块，而不知道它是从现有的块创建的。 4 Master操作Master执行所有命名空间操作。 此外，它还管理整个系统中的块复制：它进行放置决策，创建新块及其副本，并协调各种系统范围的活动以保持块完全复制，平衡所有块服务器的负载，并回收未使用的存储。 我们现在讨论这些主题。 4.1 命名空间管理和锁许多Master操作可能需要很长时间：例如，快照操作必须撤消快照覆盖的所有块上的块服务器租约。 我们不希望在运行时推迟其它Master操作。 因此，我们允许多个操作处于活动状态，并在命名空间的区域上使用锁定以确保正确的序列化。 与许多传统文件系统不同，GFS没有目录维度的数据结构列出该目录中所有文件。它也不支持同一文件或目录的别名（即Unix术语中的硬链接或符号链接）。 GFS逻辑上将其命名空间表示为将完整路径名映射到元数据的查找表。 通过前缀压缩，可以在内存中有效地表示此表。命名空间树中的每个节点（绝对文件名或绝对目录名）都具有关联的读写锁。 每个Master操作在运行之前获取一组锁。 通常，如果涉及/d1/d2/…/dn/leaf，它将获取目录名称/d1，/d1/d2，…，/d1/d2/…/dn上的读锁定 ，以及完整路径名/d1/d2/…/dn/leaf上的读锁定器写锁。 请注意，leaf可以是文件或目录，具体取决于操作。 我们现在说明当/home/user被快照到/save/user时，这种锁定机制如何防止创建文件/home/user/foo。 快照操作获取/home和/save上的读锁，/home/user和/save/user上的写锁。 文件创建获取/home和/home/user上的读锁，以及/home/user/foo上的写锁。 这两个操作将被正确序列化，因为它们试图在/home/user上获得冲突的锁。文件创建不需要父目录上的写锁定，因为没有“目录”或类似inode的数据结构可以防止修改。 名称上的读锁足以保护父目录不被删除。 这种锁定方案的一个很好的特性是它允许同一目录中的并发突变。例如，可以在同一目录中同时执行多个文件创建：每个文件创建获取目录名称的读锁定和文件名称的写锁定。目录名称上的读锁定足以阻止目录被删除，重命名或创建快照。 文件名序列化的写锁定尝试两次创建具有相同名称的文件。 由于命名空间可以有许多节点，因此读写锁定对象会被惰性分配，并且一旦不使用就会被删除。此外，以一致的总顺序获取锁以防止死锁：它们首先按名称空间树中的级别排序，在同一级别中按字典顺序排列。 4.2 副本放置GFS集群在多个层次上高度分布。它通常有数百个块服务器分布在许多机架上。这些大容量服务器依次被相同或不同机架的数百个客户机访问。在不同机架上的两台机器之间的通信可以跨越一个或多个网络交换机。此外，进入或退出机架的带宽可能小于机架内所有机器的总带宽。多级分布对分布式数据的可扩展性、可靠性和可用性提出了独特的挑战。 块副本放置策略有两个目的：最大限度地提高数据的可靠性和可用性，并最大化网络带宽利用率。对于两者而言，仅跨机器传播复制品是不够的，它只能防止磁盘或机器故障，并充分利用每台机器的网络带宽。我们还必须跨机架传播副本。这确保即使整个机架损坏或下线（例如，由于诸如网络交换机或电源电路之类的共享资源的故障），块的一些副本仍将存活并保持可用。这也意味着一个块的流量（尤其是读取）可以利用多个机架的聚合带宽。另一方面，写入流量必须流经多个机架，这是我们自愿做出的权衡。 4.3 创建，重新复制（Re-replication），重新平衡（Rebalancing）创建块副本有三个原因：块创建，重新复制和重新平衡。 当主服务器创建一个块时，它会选择放置最初为空的副本的位置。它考虑了几个因素。 （1）我们希望在具有低于平均磁盘空间利用率的块服务器上放置新的副本。随着时间的推移，这将平衡跨块服务器的磁盘利用率。（2）我们想限制每个块服务器上“最近”创建的数量。虽然创建本身不高，但它可靠地预测即将来临的大量写入流量，因为写入时需要创建块，而在我们的一次追加多次读取的工作负载中，一旦被完全写入，它们通常会变的实际上只读的。（3）如上所述，我们想要跨机架传播副本。 一旦可用副本的数量低于用户指定的目标，Master服务器就会重新复制一个数据块。这可能由于各种原因而发生：块服务器变得不可用，它报告其副本可能已损坏，其中一个磁盘因错误而被禁用，或复制目标增加。需要重新复制的每个块根据几个因素进行优先级排序。一个是它与复制目标的距离。例如，我们给丢失2个副本的块优先级高于丢失1个副本的块的优先级。此外，我们倾向于首先重新复制活动文件的块，而不是属于最近删除的文件的块（参见第4.4节）。最后，为了最大限度地减少故障对运行应用的影响，我们提高了任何阻塞客户端进度块的优先级。 主服务器选择最高优先级的块并通过指示某个块服务器直接从现有的有效副本复制块数据来“克隆”它。新副本与创建副本的放置目标相似：均衡磁盘空间利用率，限制任何单个块服务器上的活动克隆操作，并跨机架传播副本。为了保持克隆流量免受压倒性客户流量的影响，Master服务器限制了群集和每个块服务器的活动克隆操作数。此外，每个块服务器通过限制其对源块服务器的读取请求来限制它在每个克隆操作上花费的带宽量。 最后，主服务器定期重新平衡副本：它检查当前副本分发并移动副本以获得更好的磁盘速度和负载平衡。同样通过这个过程，Master逐渐填充一个新的块服务器，而不是立即用新的块和随之而来的大量写入流量来淹没它。新副本的放置标准与上面讨论的类似。此外，Master服务器还必须选择要删除的现有副本。通常，它更倾向于删除在低于平均可用空间的块服务器上的那些块，以便均衡磁盘空间的使用。 4.4 垃圾回收文件被删除后，GFS不会立即回收可用的物理存储。它只惰性地在文件和块级别的常规垃圾收集期间这样做。我们发现这个方法让系统更简单，更可靠。 4.4.1 机制当应用程序删除文件时，Master服务器会立即记录删除操作，就像其他更改一样。但是，不是立即回收资源，而是将文件重命名为包含删除时间戳的隐藏名称。在Master定期扫描文件系统命名空间期间，它将删除任何已存在超过三天（间隔可配置）的此类隐藏文件。在此之前，仍然可以使用新的特殊名称读取该文件，并且可以通过将其重命名为正常名字来取消删除。当从命名空间中删除隐藏文件时，其内存元数据将被删除。这有效地切断了其所有块的链接。 在块命名空间的类似常规扫描中，Master设备识别孤儿块（orphaned chunks，即，从任何文件不可到达的块）并擦除那些块的元数据。在与Master服务器定期交换的心跳消息中，每个块服务器报告它拥有的块的子集，主服务器回复主服务器元数据中不再存在的所有块的标识。块服务器就可以自由删除这些块的副本。 4.4.2 讨论虽然分布式垃圾收集是一个难题，需要在编程语言环境中使用复杂的解决方案，但在我们的案例中它非常简单。我们可以轻松识别对块的所有引用：它们位于由Master服务器专门维护的fileto-chunk映射中。我们还可以轻松识别所有块副本：它们是每个块服务器上指定目录下的Linux文件。任何对Master不可知的副本都是“垃圾”。 存储回收的垃圾收集方法与及时删除（eager deletion）相比具有多种优势。首先，它在组件故障很常见的大规模分布式系统中简单且可靠。块创建可能会在某些块服务器上成功，但在其他块服务器上不会成功，从而留下Master服务器不知道的副本。副本删除消息可能会丢失，并且Master服务器必须记住要在失败时重新发送他们，包括它自己和块服务器的失败。垃圾收集提供了一种统一且可靠的方法来清理任何未知的副本。其次，它将存储回收合并到Master服务器的常规后台活动中，例如命名空间的定期扫描和与块服务器的握手。因此，它是分批完成的，成本是摊销的。而且，只有当Master相对自由时才会这样做。使得Master可以更迅速地响应需要被及时关注的客户请求。第三，回收存储的延迟提供了防止意外，不可逆删除的安全网。 根据我们的经验，主要的缺点是延迟有时会妨碍用户在存储紧张时调优的努力。重复创建和删除临时文件的应用程序可能无法立即复用存储。如果再次显式删除已删除的文件，我们可以通过加快存储回收来解决这些问题。我们还允许用户对于命名空间不同的部分采用不同的复制和回收策略。例如，用户可以指定某些目录树中存储的文件中不需要副本，并且任何已删除的文件都会被立即且不可撤销地从文件系统状态中删除。 4.5 陈旧副本检测如果块服务器故障和在宕机时错过了对块的突变，则块副本可能变得陈旧。对于每个块，Master服务器维护一个块版本号以区分最新和过时的副本。 每当主服务器在块上授予新的租约时（译者注：primary的租约吗？），它会增加块版本号并通知最新的副本。主服务器和这些副本都将新版本号记录为持久状态。这发生在任何客户端被通之前，也就是它可以开始写入块之前。如果另一个副本当前不可用，则其块版本号将不会被提升。当块服务器重新启动并报告其块集及其关联的版本号时，Master服务器将检测到此块服务器具有过时的副本。如果Master服务器看到的版本号大于其记录中的版本号，则Master服务器会认为在授予租约时失败了，因此更高版本更新为最新版本（译者注：会重新发起租约授予吗？）。 Master服务器在其常规垃圾回收中删除过时的副本。在此之前，当它回复客户端对块信息的请求时，它实际上认为过时的副本根本不存在。作为另一种安全措施，当Master服务器通知客户端哪个块服务器在某个块上持有租约时，或者当它指示块服务器在克隆操作中从另一个块服务器读取块时，Master服务器包括块版本号。客户端或块服务器在执行操作时会验证版本号，这样它始终访问的是最新数据。 5 容错和诊断我们在设计系统时面临的最大挑战之一是处理频繁的组件故障。组件的质量和数量共同使这些问题成为常态而非异常：我们不能完全信任机器，也不能完全信任磁盘。组件故障可能导致系统不可用，或者更糟糕的是，数据损坏。我们将讨论如何应对这些挑战以及系统内置工具，以便在问题不可避免地发生时进行诊断。 5.1 高可靠性在GFS集群中的数百台服务器中，有些服务器在任何给定时间都必然不可用。我们通过两种简单而有效的策略保持整个系统的高可用性：快速恢复和复制。 5.1.1 快速恢复Master和块服务器都设计成无论它们怎样终止都要在几秒钟内恢复状态和启动。 事实上，我们不区分正常和异常终止; 通过终止进程来定期关闭服务器。 客户端和其他服务器因未完成的请求超时，重新连接到重启的服务器并重试，会遇到轻微的抖动（hiccup）。第6.2.2节报告了启动时间。 5.1.2 块复制如前所述，每个块都被复制在不同机架上的多个块服务器上。用户可以为文件命名空间的不同部分指定不同的复制级别。默认值为3。Master服务器根据需要克隆现有副本，以便在块服务器脱机或通过校验和验证检测损坏的副本时保持每个块完全复制（参见第5.2节）。虽然复制很有用，但我们正在探索其他形式的跨服务器冗余，例如奇偶校验或擦除代码，以满足我们日益增长的只读存储要求。 我们期望在我们非常松耦合的系统中实现这些更复杂的冗余方案是具有挑战性的，但是可控的，因为我们的流量主要是追加和读取而不是小的随机写入。 5.1.3 主副本Master状态被复制以确保可靠性。其操作日志和检查点在多台计算机上复制。只有在将日志记录刷到磁盘和所有Master副本后，才会认为状态突变已提交。为简单起见，一个Master进程仍然负责所有突变以及后台活动，例如内部改变系统的垃圾回收。当它失败时，几乎可以立即重启。如果其机器或磁盘故障，GFS外部的监视基础设施将在其它地方使用复制的操作日志启动新的Master进程。客户端仅使用Master服务器的规范名称（例如gfs-test），这是一个DNS别名，如果Master服务器迁移（relocated）到另一台机器上，则可以更改该别名。 此外，即使Primary Master服务宕机，“影子”Master们可以提供对文件系统的只读访问。它们是阴影，而不是镜像，因为它们可能略微滞后于Primary，通常不到一秒。它们增强了不被频繁修改的文件或者不介意获得稍微陈旧结果的应用程序的读可用性。实际上，由于是从块服务器读取文件内容，应用程序不会观察到过时的文件内容。短窗口中可能过时的是文件元数据，如目录内容或访问控制信息。 为了保证自身时效性，影子Master会读取不断增长的操作日志的副本，并将与primary完全相同的更改序列应用于其数据结构。与primary一样，它会在启动时轮询块服务器（之后很少），以查找块副本并与它们频繁交换握手消息以监控其状态。它取决于primary master，以便根据primary创建和删除副本的决定进行副本位置更新。 5.2 数据完整性每个块服务器使用校验和来检测存储数据的损坏。鉴于GFS集群通常在数百台计算机上拥有数千个磁盘，因此它经常会遇到磁盘故障导致数据损坏或读取和写入路径丢失。 （参阅第7节的一个原因。）我们可以使用其他块副本从损坏中恢复，但通过跨服务器副本来检测损坏是不切实际的。此外，不同的有差异的副本可能是合法的：GFS突变的语义，特别是前面讨论的的原子记录附加，并不保证相同的副本。因此，每个块服务器必须通过维护校验和来独立地验证其自身副本的完整性。 块（chunk）被分解为64KB的小块（block）。每个都有一个相应的32位校验和。与其他元数据一样，校验和保存在内存中，并与日志记录持久存储，与用户数据分开。 对于读取，在将任何数据返回给请求者之前（无论是客户端还是其他块服务器），块服务器会验证与读取范围重叠的数据块（block）的校验和。因此，块服务器不会将损坏传播到其它机器。如果块（block）与记录的校验和不匹配，则块服务器向请求者返回错误并向Master报告不匹配。作为响应，请求者将从其他副本读取，而Master将从另一个副本克隆该块。在有效的新副本到位后，Master会指示报告不匹配的块服务器删除其副本。 由于多种原因，校验和对读取性能几乎没有影响。由于我们的大多数读取跨越至少几个块（blocks），因此我们只需要读取和校验和相对少量的额外数据以进行验证。 GFS客户端代码通过尝试在校验和块边界处对齐读取来进一步减少此开销。此外，对块服务器的校验和查找和比较不需要任何I/O，并且校验和计算通常可以与I/O并行。 校验和计算针对追加到块末尾的写入（与覆盖现有数据的写入相反）进行了大量优化，因为它们在我们的工作负载中占主导地位。我们只是逐步更新最后一个部分校验和块的校验和，并为追加填充的任何全新校验和块计算新校验和。即使最后的部分校验和块已经损坏并且我们现在无法检测到它，新的校验和值也将与存储的数据不匹配，并且在下次读取块时将像往常一样检测到损坏。 相反，如果写入覆盖块的现有范围，我们必须读取并验证被覆盖的范围的第一个和最后一个块，然后执行写入，最后计算并记录新的校验和。如果我们在部分覆盖它们之前不验证第一个和最后一个块，则新的校验和可能会隐藏未被覆盖的区域中存在的损坏。 在空闲期间，块服务器可以扫描并验证非活动块的内容。这允许我们检测到很少读取的块中的损坏。检测到损坏后，master可以创建新的未损坏副本并删除损坏的副本。这可以防止不活动但损坏的块副本欺骗master，使其认为它具有足够的块的有效副本。 5.3 诊断工具广泛而详细的诊断日志已经在问题隔离，调试和性能分析方面提供了无可估量的帮助，同时只产生了最低成本。没有日志，很难理解机器之间的瞬态，不可重复的交互。 GFS服务器生成诊断日志，记录许多重要事件（例如块服务器启动和停止）以及所有RPC请求和回复。这些诊断日志可以被自由删除而不会影响系统的正确性。但是，在空间允许的情况下，我们会尽量保留这些日志。 RPC日志包括在线路上发送的确切请求和响应，但正在读取或写入的文件数据除外。通过将请求与回复匹配并整理不同的计算机上RPC记录，我们可以重建整个交互历史记录来诊断问题。日志还可用作负载测试和性能分析的跟踪。 日志记录的性能影响很小（远小于带来的收益），因为这些日志是按顺序和异步写入的。最近的事件也保存在内存中，可用于连续在线监控。]]></content>
      <tags>
        <tag>distributed</tag>
        <tag>google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式原理与工程 —— Quorum机制]]></title>
    <url>%2F2017%2F12%2F03%2FQuorum%2F</url>
    <content type="text"><![CDATA[Quorum机制是一种分布式系统中常用的，用来保证数据冗余和最终一致性的投票算法 其主要数学思想来源于鸽巢原理1。 Quorum机制定义我们普遍使用副本(Replication)技术来保证一致的性能和高可用性2，Quorum是一种简单有效的管理副本的机制，我们先建立如下定以（[2]中也有描述）： N = 存储数据副本的节点的数量W = 更新成功所需的副本更新成功的数量R = 一次数据对象读取要访问的副本的数量 更新时，只有至少W副本更新成功时才算更新操作成功；读取时，至少要读取R个副本的数据。这样当$W + R &gt; N$时，对于同一个数据对象，更新集合与读取集合一定有重叠，保证了读取的数据中一定有最近更新的值。 WARO (Write All Read One)WARO是Quorum机制的特例（GFS使用WARO），也就是更新时必须所有的副本都更新成功，而读取 时只需要读取一个副本的数据就可以。 Quorum机制与一致性Quorum本身无法保证强一致性，除非有一个获取最新成功提交的版本号的metadata服务；假设$N = 5, W = 3, R = 3$，数据V2提交成功但是只在三个副本真正更新了，副本中数据分布是[V2, V2, V2, V1, V1]，那么客户端可能读到[V2, V2, V1]，也可能读到[V2, V1, V1]；注意这里的版本V1，V2是数据本身的版本号不是最新成功提交的版本号，所以无法确认是V1还是V2；如果要保证强一致性必须继续读取副本，来确定最新至少写入的W个副本也就是提交成功的数据。 参考链接 https://zh.wikipedia.org/wiki/Quorum_(分布式系统) https://duanmeng.github.io/2017/11/19/Eventually-Consistent%20-%20Revisited/]]></content>
      <tags>
        <tag>distributed</tag>
        <tag>system design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[deeplearning.ai系列学习笔记]]></title>
    <url>%2F2017%2F11%2F26%2Fcoursera-ng-deeplearning-notes%2F</url>
    <content type="text"><![CDATA[吴恩达(Andrew Ng)离开老东家之后创立了一个创业公司叫deeplearing.ai，并且在Coursera（Ng也是cofounder）上开设一个5门课程组成deeplearning系列，我学习了前两门（完成了作业和实验拿到了证书，算是上班远坐地铁时间长的福利吧），难能可贵的是Ng考虑到国内的情况在网易云课堂上免费提供了该系列课程的学习视频和资料，所以我可以在笔记中引用课程资料，但是不会上传作业答案与实验代码。 1. Neural Networks and Deep Learning1.1 week01什么是神经网络以房价预测为例（Ng很喜欢这个例子）给出了一个非常简单的Neural Network，如下图所示，有输入层，隐藏层和输出层（输入层不算做NN的层数之中），输入层是简单的特征，隐藏层则是输入层简单特征组合成的更复杂的特征，那些圆圈是“激励”（activator）一般是ReLU）和Sigmoid这一类函数。 深度学习为什么兴起大数据驱动了深度学习的兴起（当然少不了Hinton大神的卓越贡献)，如下图可以看到随着数据量的增大，深度学习/神经网络与传统机器学习的效果差距越来越大。之前团队培训时一个策略高工说过业务 &gt; 数据 &gt; 模型，离开具体业务场景和数据支撑空谈模型是没有意义的。 该课程的术语与表示因为本系列课程都是用Python，为了优化会矩阵化，矩阵形状对比是一个很实用且重要的调试手段之一，比如输入X的形状是(nx, m)，m是训练用例的数量，nx则是输入特征的数量。 1.2 week02Logistic Regression （逻辑回归）LR虽然叫逻辑回归，但它实际是解决分类问题；它是一个线性回归在一个激励（ReLU, Sigmoid等）上的输出，本周以Sigmoid为例，其实就是神经网络图中的一个圆圈，用数学公式描述如下， Model: $a = \sigma(W^TX + b)$ where $\sigma(Z) = \frac{1}{1 + e^{-z}}$Train: $\lbrace(x^{(1), y^{(1)}}), … (x^{(i), y^{(i)}}) … , (x^{(m), y^{(m)}})\rbrace$ where $a^{(i)} \approx y^{(i)}$ Logistic Regression Cost Function度量Cost时很常见的一种方法就是square error（$\frac{(a - y)^2}{2}$），但是如果采用它会使得LR的cost function非凸，无法找到全局最优解（估计是sigmoid的特性造成的，数学原理我就不去深究了）；所以采用cross-entropy: $L(a, y) = -(ylog(a) + (1 - y)log(1 - a))$对此一个Ng给出了个感性的解释：由于$0 &lt; a, y &lt; 1$，当$y = 1$时$L(a, y) = -log(a)$，那么a无限接近1时L(a, y)最小；当$y = 0$时$L(a, y) = -log(1 - a)$，那么a无限接近0时$L(a, y)$最小。选择cross-entropy后cost function如下：$J(W, b) = \frac{1}{m}\sum^{m}_{i = 1}{L(a, y)^2}$ Gradient Descent （梯度下降）梯度下降是通过反复迭代找到使J最小的parameters（W和b），其中迭代次数和learning rate（$\alpha$）属于hyper parameters（后面会讲到）， $W := W - \alpha\frac{\nabla{J}}{\nabla{W}}$$d := d - \alpha\frac{\nabla{J}}{\nabla{b}}$ forward propagation与post propagation从梯度下降的公式可以看出迭代过程中需要知道$\frac{\nabla{J}}{\nabla{W}}$，这就是通过fp与pp推到出来的，以下面的LR过程为例： forward propagation:$[x_1, w_1, x_2, w_2, b]$ -&gt; $[z = w_1x_1 + w_2x_2 + b]$ -&gt; $[a = sigmoid(z)]$ -&gt; $[L(a, y)]$ 以推导dw1为例演示post propagation, 其中d(xx)代表$\frac{\nabla{J}}{\nabla{(xx)}}$: $[a = sigmoid(z)]$ &lt;- $[L(a, y)]$ =&gt; $da = \frac{\nabla{L}}{\nabla{a}} = -\frac{y}{a} + \frac{1 - y}{1 - a}$ $[z = w_1x_1 + w_2x_2 + b]$ &lt;- $[a = sigmoid(z)]$ =&gt; $dz = \frac{\nabla{L(a, y)}}{\nabla{z}} = \frac{\nabla{L}}{\nabla{a}}\frac{\nabla{a}}{\nabla{z}} = da\frac{\nabla{a}}{\nabla{z}} = a - y$ $[x_1, w_1, x_2, w_2, b]$ &lt;- $[z = w_1x_1 + w_2x_2 + b]$ =&gt; $dw_{1} = \frac{\nabla{L}}{\nabla{w_1}} = \frac{\nabla{L}}{\nabla{z}}\frac{\nabla{z}}{\nabla{w_1}} = x_1dz$ 这样$dw_1$就推导出来了，同理$dw_2 = x_2dz$，$db = dz$。 汇总用上面几节的结论以及python的向量化（主要是解决m个训练样本时避免for循环）汇总一个训练W，b的伪代码， 12345678for i in xrange(iterNum): Z = W.T * X + b A = sigmoid(Z) dZ = A - y dw = 1 / m * X * dZ.T db = 1 / m * sum(dZ) W = W - alpha * dW b = b - alpha * db]]></content>
      <tags>
        <tag>coursera</tag>
        <tag>deep learning</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++11 Memory Model]]></title>
    <url>%2F2017%2F11%2F24%2FC-11-Memory-Model%2F</url>
    <content type="text"><![CDATA[Herb Sutter在一次对C++11内存模型的演讲中提到C++11的内存模型，让C++有了标准独立于编译器和平台线程库和标准的多线程内存控制方式。 咋一看这个句话很奇怪，难道C++98/03及以前的内存模型不支持多线程吗， 用C++03的标准不照样写多线程程序。 其实我忽略了一个事实在B家同学们都是gcc &amp; linux，潜意识posix标准的pthread就是C++的线程库存，其实还有cl &amp; windows:) C++标准是基于一个抽象的机器制定的（大部分语言标准应该也是这样），它没有具体的CPU或编译器。 C++98/03标准没有对每次读写（loads and stores)以及执行顺序作出规定，所以无法写出完全可移植的多线程代码（能同时支持freebsd，linux和windows就很不错了）。C++11标准则在设计上引入了支持多线程的内存模型，它规定了在多线程环境中内存的读写的操作以及可能的执行顺序1。 在cppreference.com上可以看到load和store的原型如下, 12T load( std::memory_order order = std::memory_order_seq_cst ) const noexcept;void store( T desired, std::memory_order order = std::memory_order_seq_cst ) noexcept; 对于memory order多线程环境中（CPU也是乱序执行的）的几种规定如下下表， Value Explanation memory_order_relaxed 对其它读写操作没有同步，只保证本操作是原子的 memory_order_consume load操作，当前线程依赖该原子变量的访存操作不能reorder到该指令之前，对其他线程store操作(release)可见 memory_order_acquire load操作，当前线程所有访存操作不能reorder到该指令之前，对其他线程store操作(release)可见 memory_order_release store操作，当前线程所有访存操作不能reorder到该指令之后，对其他线程load操作(consume)可见 memory_order_acq_rel load/store操作，memory_order_acquire + memory_order_release memory_order_seq_cst memory_order_acq_rel + 顺序一致性(sequential consisten) 关于memory_order_seq_cst与memory_order_acq_rel，下面这段代码很直观的体现了， 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;thread&gt;#include &lt;atomic&gt;#include &lt;cassert&gt; std::atomic&lt;bool&gt; x = &#123;false&#125;;std::atomic&lt;bool&gt; y = &#123;false&#125;;std::atomic&lt;int&gt; z = &#123;0&#125;; void write_x()&#123; x.store(true, std::memory_order_seq_cst);&#125; void write_y()&#123; y.store(true, std::memory_order_seq_cst);&#125; void read_x_then_y()&#123; while (!x.load(std::memory_order_seq_cst)) ; if (y.load(std::memory_order_seq_cst)) &#123; ++z; &#125;&#125; void read_y_then_x()&#123; while (!y.load(std::memory_order_seq_cst)) ; if (x.load(std::memory_order_seq_cst)) &#123; ++z; &#125;&#125; int main()&#123; std::thread a(write_x); std::thread b(write_y); std::thread c(read_x_then_y); std::thread d(read_y_then_x); a.join(); b.join(); c.join(); d.join(); assert(z.load() != 0); // will never happen&#125; 知乎上有个G家的stephen w很认真的翻阅了经典计算机体系结构：量化研究方法给了不错的总结2, “SC要求所有内存操作表现为(appear)逐个执行（任一次的执行结果都像是所有处理器的操作都以某种次序执行），每个处理器中的操作都以其程序指定的次序执行。SC有两点要求：在每个处理器内，维护每个处理器的程序次序；在所有处理器间，维护单一的表征所有操作的次序。对于写操作W1, W2, 不能出现从处理器 P1 看来，执行次序为 W1-&gt;W2; 从处理器 P2 看来，执行次序却为 W2-&gt;W1 这种情况。 参考链接 https://stackoverflow.com/questions/6319146/c11-introduced-a-standardized-memory-model-what-does-it-mean-and-how-is-it-g https://www.zhihu.com/question/24301047/answer/83422523]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译]最终一致性 - 修订版(Eventually Consistent - Revisited)]]></title>
    <url>%2F2017%2F11%2F19%2FEventually-Consistent%20-%20Revisited%2F</url>
    <content type="text"><![CDATA[译者注：这是AWS CTO Werner Vogels写的一致性模型的经典文章在其博客All Things Distributed上亦有发布。 大约一年前，我发表了关于一致性模型文章的第一个版本，但是我对它一直不是很满意，因为它写的很匆忙，而且这个太重要值得更充分的研究。 ACM Queue让我修订一下发表在他们的杂志上，我利用这个机会改进了这篇文章。这篇是那篇的修订版。 最终一致性 - 在全球范围构建可靠的分布式系统需要在一致性和支撑Amazon云计算的基础服务，例如Amazon的S3(Simple Storage Service)，SimpleDB和EC2(Elastic Compute Cloud)提供构建互联网规模计算平台和各种应用所需的资源。放在这些基础服务的需求非常严格；它们需要在安全性、 可伸缩性、 可用性、 性能和成本效率方面都非常优秀，同时为全球数以百万计的客户持续提供服务。 这些服务底层是全球范围运行的大规模分布式系统。这样的规模带来了额外的挑战，因为当一个系统处理海量请求时，那些低概率事件就会变成必然事件，并且需要在系统设计和架构中预先列出。考虑到这些全球范围的系统，我们普遍使用副本(Replication)技术来保证一致的性能和高可用性。 虽然副本技术让我们更接近目标，但是它不能以完全透明的方式实现它们；在一些条件下，这些服务的用户将会面临使用副本技术带来的后果。 这些方面的表现方式之一就是提供的数据一致性类型，特别当底层的分布式系统为数据副本提供一种最终一致性模型。当在Amazon设计这些大规模系统时，我们用一组与大规模数据副本(data replication)相关的指导原则和抽象，并集中在高可用性与数据一致性的权衡上。 这篇文章我介绍了一些相关背景展示了我们交付需要在全球范围运行的可靠的分布式系统的方法。这篇文章的早期版本于2017年12月发表在网络博客All Things Distributed，并且在读者的帮助下改进了很多。 历史观点在理想世界中，只会有一种一致性模型：当更新完成，所有的观察者都会看到。 70年代末期，在数据系统中第一次发现这个模型难以实现。关于这个主题最好的历史文献是Bruce Lindsay等人的分布式数据库注释 5。 它阐述了数据库副本的基本原则，并讨论了一些找实现一致性的技术。 这些技术中许多试图实现分布式透明，就是对用户来说它似乎只在使用一个系统而不是多个协作系统。这段时期许多系统采用这种方法，即使让整个系统失效也不破坏透明性 2。 在90年代中期，随着大型互联网的兴起，这些方法被重新审视。 当时人们开始意识到对于这些系统而言可用性是最重要的属性，但是他们也在纠结牺牲什么来保证可用性。 Eric Brewer，加州伯克利的系统学教授，Inktomi的头，在2001年的PODC(Principles of Distributed Computing)会议的主题演讲上提出了一并提出了不同的取舍方案 1。 他演示CAP理论，指出共享数据系统的三大属性即数据一致性，系统可用性和网络分区容忍性，在任何时刻只能同时保证两个。 Seth Gilbert和Nancy Lynch在他们2002年的一篇论文 4中给出了正式确认。 不能容忍网络分区的系统可以同时实现数据一致性和可用性，这个通常是通过事务协议来实现。 为了实现这样的系统，客户端和存储系统必须在相同环境中； 他们在某些场景下会整体失效，只有这样客户端才无法感知分区。 一个重要发现是在大型分布式系统中，网络分区无法避免，因此，一致性和可用性无法同时实现。 这意味着有两个放弃的选项： 放宽一致性保证系统的可用性，或者保证一致性接受某些场景下系统不可用。 两个选项都需要客户端开发者清楚系统可以提供什么。 如果强调一致性，开发者需要面对系统可能不可用的现实，例如，一次写操作。 如果这次写操作因为系统不可用，客户端开发者需要处理数据无法写入。 如果系统强调可用性，它可能会一直接受写操作，但是一些条件下读操作无法返回最新写入的数据。 开发者需要决定客户端是否始终访问最新的更新。 有一批应用可以处理稍微陈旧的数据，它们在这个模型下可以很好的提供服务。 原则上事务系统的ACID（原子性，一致性，隔离线，持久性）中的一致性属性是一种不同的一致性保证。 在ACID中，一致性是指事务完成后数据库是处于一种一致状态；例如，一个账户转钱给另一个账户，两个账户总额不应该改变。 在ACID-based系统中，这样的一致性通常是编写事务的开发者的责任，但是可以由数据库管理完整性约束来辅助。 一致性 —— 客户端与服务端有两种视角看待一致性。 一种是开发者/客户端的视角：他们如何观察数据更新。 另一种是服务端视角：更新如何在系统中流通，以及系统能给这些更新的保证。 客户端一致性 客户端有以下部分： 一种存储系统。 我们先把它当作一个黑盒，但是要了解它底层是大规模分布式系统，为保证持久性和可用性而构建。 进程A。 这个进程读写存储系统。 进程B和进程C。 这两个进程独立于进程A且读写存储系统。这与他们是否真是进程或者同一进程中的线程无关；真正重要的是他们相互独立且需要通信共享信息。 客户端一致性需要处理如何和何时观察者们（这个例子中进程A，B或者C）看到数据对象在存储系统中更新。 接下来的例子演示了不同的类型的一致性，流程A对数据对象进行了更新： 强一致性。 更新完成后，任何后续访问（来自A，B或C）将会返回更新的值。 弱一致性。 系统不保证后续访问会得到更新的值。 获取更新值之前需要满足一些条件。 从更新到保证任何观察者将会一直看到更新值的时期被称为不一致窗口。 最终一致性。 这是弱一致性的一种特例； 存储系统保证如果对象没有新的更新，最终所以的访问将会返回最近更新的值。 如果没有失败发生，不一致窗口的大小由通信延迟，系统负载和复制方案的副本数量决定。 最广泛的最终一致性系统是DNS(Nomain Name System)。 一个域名的更新根据配置模式以及时间控制缓存被分布；最终，所以客户端将会看到更新。 最终一致性模型有一些重要的变种需要被考虑到： 因果一致性。 如果进程A通知进程B它更新了一项数据，后续进程B的访存会返回更新的值，并且保证写入将取代之前的写入。与过程A没有因果关系的进程C的访存是遵循一般的最终一致性规则。 读你所写一致性。 这是一种重要的模型，进程A更新一个数据项之后总会得到更新的值永远不会得到旧值。这是因果一致性的一种特例。 会话一致性。 这是上个模型的实践版本，其中是一个进程在一个会话上下文中访问存储系统。 只要这个会话存在，系统保证读你所写一致性。 如果会话因为一些特定场景失效，一个新的会话需要被创建且一致性保证不会跨会话。 单调读一致性。 如果一个进程读取到了一个对象的值，任何后续访问都不会得到之前的值。 单调写一致性。 在这种情况下，系统保证由相同的进程序列化写操作。系统不保证这样的一致性非常难以编程。 以上一致性特性中的一部分可以被组合。例如，单调读一致性可以和会话一致性组合。从实践角度来看，这两个特性（单调读和读你所写）是最终一致性系统中最需要的，但不是一直必须的。这两个特性让开发者更容易构建应用，同时允许存储系统放松一致性且提供高可用性。 从这些变化中可以看出，很多场景是可能的。相应的后果能否被接受取决于特定的应用程序。 最终一致性不是什么极限分布式系统的深奥特性。许多现代关系型数据库管理系统（RDBMSs），提供主备（primary-backup）可靠性，在同步和异步模式实现副本技术。在同步模式副本更新是事务的一部分。在异步模式会延迟到达副本，通常通过日志传输的方式。在异步模式如果主服务在log送达之前宕机，从切换的备份服务读取的将会是旧的，不一致的值。同时，为了支持更好大规模读性能，RDBMSs已经提供从备份服务读取的功能，这是一个经典的保证最终一致性的案例，其不一致性窗口取决于日志传送的周期。 服务端一致性在服务端我们需要更深入地理解更新在系统中执行的流程，从而理解是什么让开发者遇到不同模式。开始前，让我们先建立一些定义： N = 存储数据副本的节点的数量W = 更新成功所需的副本更新成功的数量 （译者注：如果副本更新没有达到这个数量就是更新失败）R = 一次数据对象读取要访问的副本的数量 如果$W + R &gt; N$，那么写集和读集会一直重叠，这样可以保证强一致性。在使用同步副本的主备RDBMSs场景中，$N = 2, W = 2, R = 1$。客户端无论从哪个副本读都会得到一致的结果。在异步模式且可从备份读取的场景中，$N = 2, W = 1, R = 1$，一致性不能被保证。 这些配置方案就是基本的仲裁协议（quorum protocols），当系统以为故障无法写入W个节点时，写操作失败，意味着系统的不可用。例如$N = 3, W = 3$且只有2个节点可用，系统的写操作失败。 在需要提供高性能和高可用性的分布式存储系统中，副本数量基本上要大于2。只关注容错的系统通常用$N = 3$且$W =2, R = 2$的配置。需要提供非常高的读负载的系统通常会使用超过关注容错系统的副本数量；N可以是几十甚至几百，R配置成1，这样读一次副本就可以返回结果。关注一致性的系统通常为更新设置W = N，这样就降低了写成功的可能性。关注容错而不是一致性的系统通常配置是$W = 1$，获取最小更新持久性（译者注：这是什么鬼）并通过惰性（lazy/epidemic，译者注：跟GFS的primary-secondary更新很像）更新机制去更新其他副本。 如何更新$N, W, R$，依赖于常见的操作是什么和哪个性能指标需要被优化。当$R = 1, N = W$时我们优化读操作，当$W = 1, R = N$我们优化快速写操作。当然对于后者持久性在发生异常时不被保证，如果$W &lt; (N + 1) / 2$，冲突写（译者注：比如，不同客户端发起的写操作）的集合可能不会重叠。 弱或最终一致性产生于$W + R &lt;= N$，意味着存在读写集没有重叠的可能性。如果不是刻意的配置或者基于容错用例，几乎没有任何理由设置R为1而不是其它值。这发生在两种场景中：第一个为了前面提到的读操作扩展的大规模副本；第二个是数据获取更复杂。在简单键值模型非常容易通过版本对比来决定最新写入系统的值，但是在返回对象集的系统中非常难决定最新正确的集合应该是哪个。在大多数写集合小于副本集合的系统中，有一种机制就是，用惰性更新的方式更新副本中剩余未更新的节点。所有副本更新之前的时间段被称为前面提到的不一致性窗口。如果$W + R &lt;= N$，那么系统容易从尚未更新的节点读取数据。 读你所写一致性，会话一致性和单调一致性能否实现，大体上依赖于客户端与对它们执行分布式协议服务端的“粘性”。如果每次都是相同的服务器，那么比较容易保证读你所写和单调一致性读。这样会让负载均衡和容错稍微难以管理，但是是一个简单解决方案。用粘性的会话，让这个显示和提供了一个客户端可以推断的暴露级别。（译者注：什么鬼） 有时候在客户端实现了读你所写和单调读。通过为写添加版本，客户端丢弃读取的版本号比上次所见低的数据。 当系统中一些节点与其它节点断开时分区发生了，但是这两批节点可以被一组客户端访问。如果使用经典的多数仲裁方法，那么当其它副本无法访问时，拥有W个节点的副本集依旧可以继续接受更新。读集合亦是如此。考虑到两个集合的重叠，根据定义，少数集合变得不可用。分区不会经常发生，但是他们的确发生在数据中心之间，以及数据中心内部。 在一些应用中任何分区的不可达都是不可接受的，重要的是能够访问该分区的客户端可以取得进展。在这种场景下两个分区都分配一组新的存储节点接收数据，并且在分区恢复后执行合并操作。例如，在亚马逊购物车就是使用这样的永远可写系统；这样即使发生分区，客户可以继续添加商品到购物车，即使原来的购物车位于其它分区。一旦分区恢复购物车应用（译者注：客户端？）会帮助购物车数据合并。 亚马逊的Dynamo亚马逊的Dynamo就是这样一个把所有这些特性显示控制的应用架构的系统，它是一个键值存储系统，跟AWS（Amazon’s Web Service）一样，它在内部被广泛用于构建亚马逊电子商务平台的服务。一个重要的设计目标就是让创建Dynamo存储系统（它通常分布在多个数据中心）实例的应用服务的拥有者能在一致性，持久性，可用性和性能之间在一定代价上作出权衡。3 总结在大规模可靠的分布式系统中，必须容忍数据不一致的原因有两个：在高并发条件下改善读写性能；处理分区场景中大部分模型让系统不可用，即使节点都在运行。 能否接受非一致性取决于客户端应用。在所有场景中，开发者需要意识到一致性保证由存储系统提供，需要在开发应用时考虑到。有许多对最终一致性模型实际的改进，比如会话一致性和单调读，它们提供了更好的工具给开发者。很多时候应用可以很好的处理存储系统的最终一致性。一个流行的用例就是网站，我们可以有用户感知一致性的概念。在这个场景下，不一致性窗口需要小于返回客户加载的下一页所需的时间。这个允许在下次读之前更新可以传播到整个系统。 这篇文章的目的就是引起运行在全球范围的工程系统复杂性的认识，这个系统需要仔细调优来保证它们可以交付应用所需要的持久性，可用性和性能。系统设计者拥有的一个工具之一就是一致性窗口的长度，在这个时间段内系统的客户端可能暴露在大规模工程系统的现实中。 参考文献 Brewer, E. A. 2000. Towards robust distributed systems (abstract). In Proceedings of the 19th Annual ACM Symposium on Principles of Distributed Computing (July 16-19, Portland, Oregon): 7 A Conversation with Bruce Lindsay. 2004. ACM Queue 2(8): 22-33. DeCandia, G., Hastorun, D., Jampani, M., Kakulapati, G., Lakshman, A., Pilchin, A., Sivasubramanian, S., Vosshall, P., Vogels, W. 2007. Dynamo: Amazon’s highly available key-value store. In Proceedings of the 21st ACM Symposium on Operating Systems Principles (Stevenson, Washington, October). Gilbert , S., Lynch, N. 2002. Brewer’s conjecture and the feasibility of consistent, available, partition-tolerant Web services. ACM SIGACT News 33(2). Lindsay, B. G., Selinger, P. G., et al. 1980. Notes on distributed databases. In Distributed Data Bases, ed. I. W. Draffan and F. Poole, 247-284. Cambridge: Cambridge University Press. Also available as IBM Research Report RJ2517, San Jose, California (July 1979).]]></content>
      <tags>
        <tag>distributed</tag>
        <tag>system design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Learning Design and Coding From LevelDB (keep updating ...)]]></title>
    <url>%2F2017%2F11%2F05%2FLearning-Design-and-Coding-From-LevelDB%2F</url>
    <content type="text"><![CDATA[LevelDB is a fast key-value storage library written at Google by Jeff Dean that provides an ordered mapping from string keys to string values. We could learn design and coding from the source code. 概述include/leveldb &amp; utilStatus include/leveldb/status.h util/status.cc Status是对每次操作结果的封装, 它只有一个成员变量char* state_来表示状态信息，它包含三个字段[length, code, message], length表示message的长度，code是返回码，message是状态信息：123456789101112131415161718192021222324252627// OK status has a NULL state_. Otherwise, state_ is a new[] array// of the following form:// state_[0..3] == length of message// state_[4] == code// state_[5..] == messageconst char* state_;enum Code &#123; kOk = 0, kNotFound = 1, kCorruption = 2, kNotSupported = 3, kInvalidArgument = 4, kIOError = 5&#125;;Code code() const &#123; return (state_ == NULL) ? kOk : static_cast&lt;Code&gt;(state_[4]);&#125;const char* Status::CopyState(const char* state) &#123; uint32_t size; memcpy(&amp;size, state, sizeof(size)); char* result = new char[size + 5]; memcpy(result, state, size + 5); return result;&#125; 这个类对字符串的操作非常精妙，比如上述代码通过memcpy获取message长度信息. Slice include/leveldb/slice.h 封装数据和其长度，便于直接通过指针操作, 并提供向std::String的转换.1234567class Slice &#123;...private: const char* data_; size_t size_; ...&#125; Cache include/leveldb/cache.h utils/cache.cc overviewCache一个接口类，提供了有淘汰机制KV的接口，客户代码可以自己定义具体的实现，也可以使用默认的LRUCache,从下面代码中的注释中可以看出设计思路。12345678910111213141516171819202122232425// A Cache is an interface that maps keys to values. It has internal// synchronization and may be safely accessed concurrently from// multiple threads. It may automatically evict entries to make room// for new entries. Values have a specified charge against the cache// capacity. For example, a cache where the values are variable// length strings, may use the length of the string as the charge for// the string.//// A builtin cache implementation with a least-recently-used eviction// policy is provided. Clients may use their own implementations if// they want something more sophisticated (like scan-resistance, a// custom eviction policy, variable cache sizing, etc.)// Create a new cache with a fixed size capacity. This implementation// of Cache uses a least-recently-used eviction policy.extern Cache* NewLRUCache(size_t capacity);class Cache &#123; public: // Opaque handle to an entry stored in the cache. struct Handle &#123; &#125;; virtual Handle* Insert(const Slice&amp; key, void* value, size_t charge, void (*deleter)(const Slice&amp; key, void* value)) = 0; virtual Handle* Lookup(const Slice&amp; key) = 0; ... ... 虽然其接口参数有明确，但是数据类型并没有明确而是留给具体实现代码，所以返回类型是12Handle*struct Handle &#123;&#125;; 这就是一个典型的Opaque data type的应用，wikipedia: opaque pointer, wikipedia: opaque data type, stackoverflow: What is an opaque value? 你会发现在cache.h中有一段extern声明,1extern Cache* NewLRUCache(size_t capacity); 在cache.cc中有它的一种实现,123Cache* NewLRUCache(size_t capacity) &#123; return new ShardedLRUCache(capacity);&#125; 通过extern声明(#include “cache.h”), 在链接的时候(链接cache.o)既可以选择cache.cc的默认实现即ShardedLRUCache, 也可以链接自己的实现。 ShardedLRUCachecache.cc中提供了一个默认的cache实现即ShardedLRUCache, 其组成是LRUCache并基于key进行shard.LRUCache依赖cache.c中的opaque数据抽象的具体实现LRUHandle和自己实现的一个哈希表HashHandle.总而言之ShardedLRUCache就是二级hashtable, 其节点就是多个LRUCache. ShardedLRUCache在bucket分配与key的shard时用一些非常有意思的位操作，代码如下12345678static const int kNumShardBits = 4;static const int kNumShards = 1 &lt;&lt; kNumShardBits;LRUCache shard_[kNumShards];static uint32_t Shard(uint32_t hash) &#123; return hash &gt;&gt; (32 - kNumShardBits);&#125; kNumShards = 2 ^ kNumShardBits 这个左移代替指数计算好理解，但是shard操作hash &gt;&gt; (32 - kNumShardBits)这个值得思考，一般会直接余除，但是这样效果会一样吗或者说会均匀分布在kNumShards个bucket中吗？假设我们考虑4个bit的uint4_t（虽然并没有这样的类型），当kNumShardBits = 1时，bucket数量也就是kNumShards为2,那么 4 - kNumShardBits = 3，每次Shard的时候右移动3个bit，这时会发现只有bit 3的那个bit右移没有消失（在bit 0），也就是说bit 3的那个bit决定了Shard的value(0 / 1)，正好均匀分布在2个bucket上了.同理对于32bit的uint32_t整型数，其bit分布如下 31 … (32 - kNumShardBits), (32 - kNumShardBits - 1) … 0 如果右移32 - kNumShardBits，只有第一部分kNumShardBits个高位的bit有效，那么正好有2 ^ kNumShardBits 种可能的值，均匀分布在index为0 - (2 ^ kNumShardBits - 1)的bucket上.一个简单的Shard对效率都这么苛刻(位操作避免除法)，由此可见作者对性能的要求. LRUCache &amp; LRUHandle &amp; HandleTableLRUCache由两个循环链表和一个HashTable组成（List+Hash的经典实现），一个链表是连接正在被使用的Node，一个链表连接不再被使用的Node，HashTable就是使用链表解决Hash碰撞，所以每个Node（即LURHandle包含三个pointer和一个ref），作者使用了经典的链表操作dummy node和二级指针Linus。Hash值的生成实现请见Hash &amp; Coding哪一章。 Hash &amp; Codingutil/hash.cc util/hash.hutil/coding.cc util/coding.hhash.cc提供了一个默认的类似murmurhash的hash值计算的实现，coding.cc中提供了32/64整型数和Slice/String的转换. env &amp; env_posixutil/env.cc include/leveldb/env.hutil/env_posix.cc envenv中的接口类Env（虚基类）提供了文件操作的抽象，比如目录操作，日志，文件顺序/随机读取，在Option中可以配置Env使用的实现, leveldb提供了默认的posix标准的实现（具体见下一节）.SequentialFile/RandomAccessFile封装了文件顺序/随机Read和Skip，WritableFile封装了文件的Append/Close/Flush/Sync操作，Loger则封装了类似变长参数的logv接口（类似vprintf）. env_posixenv_posix是leveldb对Env接口类提供的默认implementation.Limiter类通过基于RAII的Scope互斥锁和原子操作提供线程安全的计数操作，避免资源过度消耗，比如fd, mmap file数量.PosixSequentialFile是SequentialFile的子类实现了其Read和Seek接口, 本质就是对fread和seek的wrapper.PosixRandomAccessFile是RandomAccessFile的子类, 实际是pread() based random-access, 同时包含了Limiter, 不知道为什么Random Accesss为什么需要Limiter.PosixMmapReadableFile是MmapReadableFile的子类, 实际是mmap() based random-access.]]></content>
      <tags>
        <tag>C++</tag>
        <tag>leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode using C++ and Java (keep updating ...)]]></title>
    <url>%2F2017%2F11%2F04%2FLeetCode%20with%20C%2B%2B%20and%20Java%20and%20little%20scala%2F</url>
    <content type="text"><![CDATA[LeetCode的题目非常是碎片化时间来做，而且可以尝试最新的C++标准和多种语言， 正好要学习Java，就C++和Java两种语言来做题，如果碰到可以用immutable方式的题目就再用Scala做一下。 1. Two Sum Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution, and you may not use the same element twice. Example:Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. Tags: Array, HashTable C++123456789101112131415class Solution &#123; // (both index1 and index2) are not zero-based.public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, size_t&gt; umap; for (size_t i = 0; i &lt; nums.size(); ++i) &#123; auto item = nums[i]; if (umap.find(target - item) == umap.end()) &#123; umap[item] = i; &#125; else &#123; return vector&lt;int&gt;&#123;umap[target - item], i&#125;; &#125; &#125; return vector&lt;int&gt;&#123;-1, -1&#125;; &#125;&#125;; Java1234567891011121314public class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; hm = new HashMap&lt;&gt;(); for (int i = 0; i != nums.length; ++i) &#123; int complement = target - nums[i]; if (hm.get(complement) != null) &#123; return new int[] &#123;hm.get(complement), i&#125;; &#125; else &#123; hm.put(nums[i], i); &#125; &#125; return null; &#125;&#125; Scala1234567891011121314object Solution &#123; def twoSum(nums: Array[Int], target: Int): Array[Int] = &#123; var ht = collection.mutable.Map.empty[Int, Int] for (i &lt;- 0 until nums.size) &#123; val tmp = target - nums(i) if (ht.contains(tmp)) &#123; return Array(ht(tmp), i) &#125; else &#123; ht(nums(i)) = i &#125; &#125; Array(-1, -1) &#125;&#125; 2. Add Two Numbers You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself.Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 Tags: Linked List, Math C++12345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode dummy(-1); ListNode* ptr = &amp;dummy; int carry = 0; while (l1 != nullptr || l2 != nullptr) &#123; int a = 0; if (l1 != nullptr) &#123; a = l1-&gt;val; l1 = l1-&gt;next; &#125; int b = 0; if (l2 != nullptr) &#123; b = l2-&gt;val; l2 = l2-&gt;next; &#125; int sum = a + b + carry; carry = sum / 10; ptr-&gt;next = new ListNode(sum % 10); ptr = ptr-&gt;next; &#125; if (carry &gt; 0) &#123; ptr-&gt;next = new ListNode(carry); &#125; return dummy.next; &#125;&#125;; Java123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; int carrier = 0; ListNode dummy = new ListNode(0); ListNode cur = dummy; while (l1 != null || l2 != null) &#123; int x = l1 == null ? 0 : l1.val; int y = l2 == null ? 0 : l2.val; int val = x + y + carrier; carrier = val / 10; cur.next = new ListNode(val % 10); cur = cur.next; if (l1 != null) &#123; l1 = l1.next; &#125; if (l2 != null) &#123; l2 = l2.next; &#125; &#125; if (carrier &gt; 0) &#123; cur.next = new ListNode(carrier); &#125; return dummy.next; &#125;&#125; Scala123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * class ListNode(var _x: Int = 0) &#123; * var next: ListNode = null * var x: Int = _x * &#125; */object Solution &#123; def addTwoNumbers(l1: ListNode, l2: ListNode): ListNode = &#123; var dummyNode = new ListNode(0) var cur = dummyNode var carry = 0 def addInternal(l1: ListNode, l2: ListNode): Unit = &#123; if (l1 != null || l2 != null) &#123; var a = if (l1 != null) l1.x else 0 var b = if (l2 != null) l2.x else 0 var sum = a + b + carry cur.next = new ListNode(sum % 10) cur = cur.next carry = sum / 10 addInternal(if (l1 != null) l1.next else null, if(l2 != null) l2.next else null) &#125; &#125; addInternal(l1, l2) if (carry &gt; 0) &#123; cur.next = new ListNode(carry) &#125; dummyNode.next &#125;&#125; 3. Longest Substring Without Repeating Characters Given a string, find the length of the longest substring without repeating characters. Examples:Given “abcabcbb”, the answer is “abc”, which the length is 3.Given “bbbbb”, the answer is “b”, with the length of 1.Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring. Tags: Hash Table, Two Pointers, String C++123456789101112131415161718class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int ret = 0; vector&lt;int&gt; ht(256, -1); int i = 0; for (int j = 0; j &lt; s.size(); ++j) &#123; auto k = ht[s[j]]; if (k &gt;= i) &#123; i = k + 1; &#125; else &#123; ret = std::max(ret, j - i + 1); &#125; ht[s[j]] = j; &#125; return ret; &#125;&#125;; Java1234567891011121314151617public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int ret = 0; Map&lt;Character, Integer&gt; hm = new HashMap&lt;&gt;(); int i = 0; for (int j = 0; j &lt; s.length(); ++j) &#123; int k = hm.getOrDefault(s.charAt(j), -1); if (k &gt;= i) &#123; i = k + 1; &#125; else &#123; ret = Math.max(ret, j - i + 1); &#125; hm.put(s.charAt(j), j); &#125; return ret; &#125;&#125; 4. Median of Two Sorted Arrays There are two sorted arrays nums1 and nums2 of size m and n respectively.Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). Example 1:nums1 = [1, 3]nums2 = [2]The median is 2.0 Example 2:nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 Tags: Divide and Conquer, Binary Search, Array C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; auto sz = nums1.size() + nums2.size(); if (sz &amp; 0x01) &#123; auto ret = findKthElement(begin(nums1), nums1.size(), begin(nums2), nums2.size(), sz / 2 + 1); //auto ret = findKthElement(nums1.data(), nums1.size(), nums2.data(), nums2.size(), sz / 2 + 1); return static_cast&lt;double&gt;(ret); &#125; else &#123; auto ret1 = findKthElement(begin(nums1), nums1.size(), begin(nums2), nums2.size(), sz / 2); auto ret2 = findKthElement(begin(nums1), nums1.size(), begin(nums2), nums2.size(), sz / 2 + 1); //auto ret1 = findKthElement(nums1.data(), nums1.size(), nums2.data(), nums2.size(), sz / 2); //auto ret2 = findKthElement(nums1.data(), nums1.size(), nums2.data(), nums2.size(), sz / 2 + 1); return (static_cast&lt;double&gt;(ret1) + static_cast&lt;double&gt;(ret2)) / 2.0; &#125; &#125; private: int findKthElement(const int* nums1, size_t len1, const int* nums2, size_t len2, size_t k) &#123; if (len1 &gt; len2) &#123; return findKthElement(nums2, len2, nums1, len1, k); &#125; if (len1 == 0) &#123; return nums2[k - 1]; &#125; if (k == 1) &#123; return min(nums1[k - 1], nums2[k - 1]); &#125; auto dis1 = min(k / 2, len1); auto dis2 = k - dis1; if (nums1[dis1 - 1] &lt; nums2[dis2 - 1]) &#123; return findKthElement(nums1 + dis1, len1 - dis1, nums2, len2, k - dis1); &#125; else if (nums1[dis1 - 1] &gt; nums2[dis2 - 1]) &#123; return findKthElement(nums1, len1, nums2 + dis2, len2 - dis2, k - dis2); &#125; else &#123; return nums1[dis1 - 1]; &#125; return -1; &#125; int findKthElement(vector&lt;int&gt;::const_iterator begin_1, size_t len_1, vector&lt;int&gt;::const_iterator begin_2, size_t len_2, size_t k) &#123; if (len_1 &gt; len_2) &#123; return findKthElement(begin_2, len_2, begin_1, len_1, k); &#125; if (len_1 == 0) &#123; return *(begin_2 + k - 1); &#125; if (k == 1) &#123; return std::min(*begin_1, *begin_2); &#125; auto dis_1 = std::min(k / 2, len_1); auto dis_2 = k - dis_1; if (*(begin_1 + dis_1 - 1) &lt; *(begin_2 + dis_2 - 1)) &#123; return findKthElement(begin_1 + dis_1, len_1 - dis_1, begin_2, len_2, k - dis_1); &#125; else if (*(begin_1 + dis_1 - 1) &gt; *(begin_2 + dis_2 - 1)) &#123; return findKthElement(begin_1, len_1, begin_2 + dis_2, len_2 - dis_2, k - dis_2); &#125; else &#123; return *(begin_1 + dis_1 - 1); &#125; return -1; &#125;&#125;; Java123456789101112131415161718192021222324252627282930313233public class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int len = nums1.length + nums2.length; if ((len &amp; 0x01) == 0x01) &#123; return findKthElement(nums1, 0, nums2, 0, len / 2 + 1); &#125; else &#123; double left = findKthElement(nums1, 0, nums2, 0, len / 2); double right = findKthElement(nums1, 0, nums2, 0, len / 2 + 1); return (left + right) / 2.0; &#125; &#125; private double findKthElement(int[] nums1, int start1, int[] nums2, int start2, int k) &#123; if ((nums1.length - start1) &gt; (nums2.length - start2)) &#123; return findKthElement(nums2, start2, nums1, start1, k); &#125; if ((nums1.length - start1) &lt;= 0) &#123; return (double) nums2[start2 + k - 1]; &#125; if (k == 1) &#123; return Math.min((double) nums1[start1], (double) nums2[start2]); &#125; int dis1 = Math.min(k / 2, nums1.length - start1); int dis2 = k - dis1; if (nums1[start1 + dis1 - 1] &lt; nums2[start2 + dis2 - 1]) &#123; return findKthElement(nums1, start1 + dis1, nums2, start2, k - dis1); &#125; else if (nums1[start1 + dis1 - 1] &gt; nums2[start2 + dis2 - 1]) &#123; return findKthElement(nums1, start1, nums2, start2 + dis2, k - dis2); &#125; else &#123; return (double) nums1[start1 + dis1 - 1]; &#125; &#125;&#125; 5. Longest Palindromic Substring Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example:Input: “babad”Output: “bab”Note: “aba” is also a valid answer. Example:Input: “cbbd”Output: “bb” Tags String 注意C++的substr和Java的substring的区别 C++1234567891011121314151617181920212223242526272829class Solution &#123;public: string longestPalindrome(string s) &#123; int start = 0; int len = 1; for (int i = 0; i &lt; s.length(); ++i) &#123; auto cur = _getLongestPalindromeLength(s, i); if (cur &gt; len) &#123; len = cur; start = i - (len - 1) / 2; &#125; &#125; return s.substr(start, len); &#125; private: inline int _getLongestPalindromeLength(const string &amp;s, int i) &#123; return max(_getLongestPalindromeLength(s, i, i), _getLongestPalindromeLength(s, i, i + 1)); &#125; inline int _getLongestPalindromeLength(const string &amp;s, int left, int right) &#123; while (left &gt;= 0 &amp;&amp; right &lt; static_cast&lt;int&gt;(s.length()) &amp;&amp; s[left] == s[right]) &#123; --left; ++right; &#125; return right - left - 1; &#125; &#125;; Java1234567891011121314151617181920212223242526public class Solution &#123; public String longestPalindrome(String s) &#123; int len = 1; int start = 0; for (int i = 0; i &lt; s.length(); ++i) &#123; int cur = getLongestPalindromeLength(s, i); if (cur &gt; len) &#123; len = cur; start = i - (len - 1) / 2; &#125; &#125; return s.substring(start, start + len); &#125; private int getLongestPalindromeLength(String s, int i) &#123; return Math.max(getLongestPalindromeLength(s, i, i), getLongestPalindromeLength(s, i, i + 1)); &#125; private int getLongestPalindromeLength(String s, int left, int right) &#123; while (left &gt;= 0 &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123; --left; ++right; &#125; return right - left - 1; &#125;&#125; 6. ZigZag Conversion The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)P A H NA P L S I I GY I RAnd then read line by line: “PAHNAPLSIIGYIR”Write the code that will take a string and make this conversion given a number of rows:string convert(string text, int nRows);convert(“PAYPALISHIRING”, 3) should return “PAHNAPLSIIGYIR”. Tags: string C++123456789101112131415161718192021222324class Solution &#123;public: string convert(string s, int numRows) &#123; if (numRows &lt;= 1 || numRows &gt;= static_cast&lt;int&gt;(s.size())) &#123; return s; &#125; vector&lt;string&gt; ret(numRows, ""); int row_cursor = 0; int step = 0; for (size_t idx = 0; idx != s.size(); ++idx) &#123; ret[row_cursor].push_back(s[idx]); if (row_cursor == 0) &#123; step = 1; &#125; else if (row_cursor == numRows - 1) &#123; step = -1; &#125; row_cursor += step; // update row_cursor &#125; string result; result.reserve(numRows); for_each(ret.begin(), ret.end(), [&amp;result](string&amp; item) &#123; result += std::move(item); &#125;); return result; &#125;&#125;; Java1234567891011121314151617181920212223242526public class Solution &#123; public String convert(String s, int numRows) &#123; if (s.isEmpty() || numRows ==1 || numRows &gt;= s.length()) &#123; return s; &#125; ArrayList&lt;StringBuilder&gt; ret = new ArrayList&lt;&gt;(Collections.nCopies(numRows, null)); int idx = 0; int step = 0; for (int i = 0; i &lt; s.length(); ++i) &#123; if (ret.get(idx) == null) &#123; ret.set(idx, new StringBuilder()); &#125; ret.get(idx).append(s.charAt(i)); if (idx == numRows - 1) &#123; step = -1; &#125; else if (idx == 0) &#123; step = 1; &#125; idx += step; &#125; for (int i = 1; i &lt; ret.size(); ++i) &#123; ret.get(0).append(ret.get(i)); &#125; return ret.get(0).toString(); &#125;&#125; 7. Reverse Integer Reverse digits of an integer.Example1: x = 123, return 321Example2: x = -123, return -321 Tags: Math C++1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int reverse(int x) &#123; int ret = 0; for ( ; x != 0; x /= 10) &#123; int tail = x % 10; int tmp = ret * 10 + tail; if ((tmp - tail) / 10 != ret) &#123; // overflow return 0; &#125; ret = tmp; &#125; return ret; &#125;&#125;;class Solution &#123;public: int reverse(int x) &#123; int flag = x &lt; 0 ? -1 : 1; int ret = 0; while (x != 0) &#123; int cur = (x % 10) * flag; if (ret &gt; INT_MAX / 10 || (ret == INT_MAX / 10 &amp;&amp; cur &gt; INT_MAX % 10)) &#123; return 0; &#125; ret = 10 * ret + cur; x /= 10; &#125; return flag * ret; &#125;&#125;; Java123456789101112131415161718192021222324252627282930public class Solution &#123; public int reverse(int x) &#123; int ret = 0; for ( ; x != 0; x /= 10) &#123; int tail = x % 10; int tmp = ret * 10 + tail; if ((tmp - tail) / 10 != ret) &#123; return 0; &#125; ret = tmp; &#125; return ret; &#125;&#125;public class Solution &#123; public int reverse(int x) &#123; int ret = 0; int flag = x &lt; 0 ? -1 : 1; while (x != 0) &#123; int cur = (x % 10) * flag; if (ret &gt; Integer.MAX_VALUE / 10 || (ret == Integer.MAX_VALUE / 10 &amp;&amp; cur &gt; Integer.MAX_VALUE % 10)) &#123; return 0; &#125; ret = 10 * ret + cur; x /= 10; &#125; return flag * ret; &#125;&#125; 8. String to Integer (atoi) Implement atoi to convert a string to an integer.Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases. Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. Tags: Math, String C++123456789101112131415161718192021222324252627class Solution &#123;public: int myAtoi(string str) &#123; int ret = 0; auto int_max = std::numeric_limits&lt;int&gt;::max(); auto int_min = std::numeric_limits&lt;int&gt;::min(); auto iter = std::begin(str); while (*iter == ' ') &#123; ++iter; &#125; bool negative = false; if (*iter == '-' || *iter == '+') &#123; if(*iter == '-') &#123; negative = true; &#125; ++iter; &#125; for ( ; iter != std::end(str) &amp;&amp; std::isdigit(*iter); ++iter) &#123; int cur = *iter - '0'; if (ret &gt; int_max / 10 || (ret == int_max / 10 &amp;&amp; cur &gt; int_max % 10)) &#123; return negative ? int_min : int_max; &#125; ret = ret * 10 + cur; &#125; return negative ? -ret : ret; &#125;&#125;; Java123456789101112131415161718192021222324252627282930public class Solution &#123; public int myAtoi(String str) &#123; int ret = 0; boolean negative = false; int idx = 0; // deal empty string which not the same as C++ and String is iteratable (java Collections) if (str.isEmpty()) &#123; return ret; &#125; // remove leading space for ( ; str.charAt(idx) == ' '; ++idx) &#123;&#125; // get flag if (str.charAt(idx) == '+' || str.charAt(idx) == '-') &#123; negative = (str.charAt(idx) == '-' ? true : false); ++idx; &#125; // parsing digit chars for ( ; idx &lt; str.length(); ++idx) &#123; int cur = str.charAt(idx) - '0'; if (cur &lt; 0 || cur &gt; 9) &#123; break; &#125; if (ret &gt; Integer.MAX_VALUE / 10 || (ret == Integer.MAX_VALUE / 10 &amp;&amp; Integer.MAX_VALUE % 10 &lt; cur)) &#123; return negative ? Integer.MIN_VALUE : Integer.MAX_VALUE; &#125; ret = ret * 10 + cur; &#125; return negative ? -ret : ret; &#125;&#125; 9. Palindrome NumberTags: String Cpp123456789class Solution &#123;public: bool isPalindrome(int x) &#123; string s1 = std::move(std::to_string(x)); string s2(s1); reverse(s1.begin(), s1.end()); return s1 == s2; &#125;&#125;; Java1234567public class Solution &#123; public boolean isPalindrome(int x) &#123; String a = String.valueOf(x); String b = (new StringBuilder(a)).reverse().toString(); return a.equals(b); &#125;&#125; 10. Regular Expression Matching Implement regular expression matching with support for ‘.’ and ‘*‘.‘.’ Matches any single character.‘*‘ Matches zero or more of the preceding element.The matching should cover the entire input string (not partial).The function prototype should be:bool isMatch(const char s, const char p) Some examples:isMatch(“aa”,”a”) ? falseisMatch(“aa”,”aa”) ? trueisMatch(“aaa”,”aa”) ? falseisMatch(“aa”, “a“) ? trueisMatch(“aa”, “.“) ? trueisMatch(“ab”, “.“) ? trueisMatch(“aab”, “ca*b”) ? true Tag: String, Dynamic Programming, Backtracking Use Dynamic ProgrammingCpp12345678910111213141516171819202122232425262728293031class Solution &#123;public: bool isMatch(string s, string p) &#123; // last char is the key postion, which may be '*' or not // match[i][j] record the s[0 : i - 1] matched p[0 : j - 1] so // match[0][0] = true, match[1 : ][0] = false, match[0][1 : ] = (j &gt; 1 &amp;&amp; match[0][j - 2] &amp;&amp; p[j - 1] == '*') // match[i][j] = p[j - 1] != '*' &amp;&amp; (match[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == '.')) // match[i][j] = p[j - 1] == '*' &amp;&amp; (match[i][j - 2] || (match[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 1] == '.'))) vector&lt;vector&lt;bool&gt;&gt; match(s.length() + 1, vector&lt;bool&gt;(p.length() + 1, false)); match[0][0] = true; for (size_t i = 1; i &lt; match.size(); ++i) &#123; match[i][0] = false; &#125; for (size_t j = 1; j &lt; match[0].size(); ++j) &#123; match[0][j] = (j &gt; 1) &amp;&amp; match[0][j - 2] &amp;&amp; (p[j - 1] == '*'); &#125; for (size_t i = 1; i &lt; match.size(); ++i) &#123; for (size_t j = 1; j &lt; match[0].size(); ++j) &#123; if (p[j - 1] != '*') &#123; match[i][j] = match[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == '.'); &#125; else &#123; // p[j - 1] is '*' so p[j - 2] must exist and match[i - 1][j] covers match[i - 1][j - 2] match[i][j] = match[i][j - 2] || (match[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 2] == '.')); &#125; &#125; &#125; return match.back().back(); &#125;&#125;; Java123456789101112131415161718192021222324252627282930public class Solution &#123; public boolean isMatch(String s, String p) &#123; // last char is the key postion, which may be '*' or not // match[i][j] record the s[0 : i - 1] matched p[0 : j - 1] so // match[0][0] = true, match[1 : ][0] = false, match[0][1 : ] = (j &gt; 1 &amp;&amp; match[0][j - 2] &amp;&amp; p[j - 1] == '*') // match[i][j] = p[j - 1] != '*' &amp;&amp; (match[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == '.')) // match[i][j] = p[j - 1] == '*' &amp;&amp; (match[i][j - 2] || (match[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 1] == '.'))) boolean[][] match = new boolean[s.length() + 1][p.length() + 1]; match[0][0] = true; for (int i = 1; i &lt; match.length; ++i) &#123; match[i][0] = false; &#125; for (int j = 1; j &lt; match[0].length; ++j) &#123; match[0][j] = (j &gt; 1) &amp;&amp; match[0][j - 2] &amp;&amp; p.charAt(j - 1) == '*'; &#125; for (int i = 1; i &lt; match.length; ++i) &#123; for (int j = 1; j &lt; match[0].length; ++j) &#123; if (p.charAt(j - 1) != '*') &#123; match[i][j] = match[i - 1][j - 1] &amp;&amp; (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.'); &#125; else &#123; // p[j - 1] is '*' so p[j - 2] must exist and match[i - 1][j] covers match[i - 1][j - 2] match[i][j] = match[i][j - 2] || (match[i - 1][j] &amp;&amp; (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.')); &#125; &#125; &#125; return match[s.length()][p.length()]; &#125;&#125; Use Backtracking123456789101112131415161718192021222324class Solution &#123;public: bool isMatch(string s, string p) &#123; return isMatch(s.c_str(), p.c_str()); &#125;private: // use c++ string's feature (end with '\0') to avoid some condition check in java inline bool charMatch(const char *s, const char *p) &#123; return (*s == *p || (*p == '.' &amp;&amp; *s != '\0')); &#125; bool isMatch(const char *s, const char *p) &#123; if (*p == '\0') &#123; return *s == '\0'; &#125; if (*(p + 1) != '*') &#123; return charMatch(s, p) &amp;&amp; isMatch(s + 1, p + 1); &#125; else if (charMatch(s, p)) &#123; return isMatch(s + 1, p) || isMatch(s, p + 2); &#125; else &#123; return isMatch(s, p + 2); &#125; &#125;&#125;; 11. Container With Most Water Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.Note: You may not slant the container and n is at least 2. Tags: two pointer Cpp12345678910111213141516class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int ret = 0; if (height.size() &lt; 2) &#123; return ret; &#125; size_t left = 0; size_t right = height.size() - 1; while (left &lt; right) &#123; ret = max(ret, min(height[left], height[right]) * static_cast&lt;int&gt;(right - left)); height[left] &lt; height[right] ? ++left : --right; &#125; return ret; &#125;&#125;; Java12345678910111213141516171819public class Solution &#123; public int maxArea(int[] height) &#123; int ret = 0; if (height.length &lt; 2) &#123; return ret; &#125; int left = 0; int right = height.length - 1; while (left &lt; right) &#123; ret = Math.max(ret, Math.min(height[left], height[right]) * (right - left)); if (height[left] &lt; height[right]) &#123; ++left; &#125; else &#123; --right; &#125; &#125; return ret; &#125;&#125; 12. Integer to RomanCpp123456789101112131415class Solution &#123;public: string intToRoman(int num) &#123; vector&lt;string&gt; symbol&#123;"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"&#125;; vector&lt;int&gt; value&#123;1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1&#125;; string ret; for (int i = 0; num &gt; 0; ++i) &#123; while (num &gt;= value[i]) &#123; num -= value[i]; ret += symbol[i]; &#125; &#125; return ret; &#125;&#125;; Java12345678910111213141516public class Solution &#123; public String intToRoman(int num) &#123; String ret = ""; ArrayList&lt;String&gt; symbol = new ArrayList( Arrays.asList("M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I")); ArrayList&lt;Integer&gt; value = new ArrayList( Arrays.asList(1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)); for (int i = 0; num &gt; 0; ++i) &#123; while (num &gt;= value.get(i)) &#123; num -= value.get(i); ret = ret + symbol.get(i); &#125; &#125; return ret; &#125;&#125; 13. Roman to IntegerCpp123456789101112131415161718192021class Solution &#123;public: int romanToInt(string s) &#123; int ret = 0; int pre = 0; unordered_map&lt;char, int&gt; umap &#123; make_pair('I', 1), make_pair('V', 5), make_pair('X', 10), \ make_pair('L', 50), make_pair('C', 100), make_pair('D', 500), \ make_pair('M', 1000)&#125;; for (const auto&amp; c : s) &#123; int cur = umap.at(c); if (cur &lt;= pre) &#123; ret += cur; &#125; else &#123; ret += cur - 2 * pre; // ret = ret - pre + cur - pre &#125; pre = cur; &#125; return ret; &#125;&#125;; Java123456789101112131415161718192021222324public class Solution &#123; public int romanToInt(String s) &#123; HashMap&lt;Character, Integer&gt; hmap = new HashMap&lt;&gt;(); hmap.put('I', 1); hmap.put('V', 5); hmap.put('X', 10); hmap.put('L', 50); hmap.put('C', 100); hmap.put('D', 500); hmap.put('M', 1000); int ret = 0; int pre = 0; for (int i = 0; i &lt; s.length(); ++i) &#123; int cur = hmap.get(s.charAt(i)); if (cur &lt;= pre) &#123; ret += cur; &#125; else &#123; ret = ret - 2 * pre + cur; &#125; pre = cur; &#125; return ret; &#125;&#125; 14. Longest Common PrefixCpp1234567891011121314151617class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if (strs.size() &lt; 1) &#123; return string(""); &#125; for (size_t cursor = 0; cursor &lt; strs[0].size(); ++cursor) &#123; auto cur = strs[0][cursor]; for (size_t i = 1; i &lt; strs.size(); ++i) &#123; if (cur != strs[i][cursor]) &#123; return strs[0].substr(0, cursor); &#125; &#125; &#125; return strs[0]; &#125;&#125;; Java12345678910111213141516public class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; if (strs.length &lt;= 0) &#123; return ""; &#125; for (int cursor = 0; cursor &lt; strs[0].length(); ++cursor) &#123; char pre = strs[0].charAt(cursor); for (int i = 1; i &lt; strs.length; ++i) &#123; if (cursor &gt;= strs[i].length() || strs[i].charAt(cursor) != pre) &#123; return strs[0].substring(0, cursor); &#125; &#125; &#125; return strs[0]; &#125;&#125; 15. 3SumCpp123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; ret; int len = static_cast&lt;int&gt;(nums.size()); std::sort(nums.begin(), nums.end()); for (int i = 0; i &lt; len - 2 &amp;&amp; nums[i] &lt;= 0; ++i) &#123; // remove possible duplicate results if (i &gt; 0 &amp;&amp; nums[i] == nums[i -1 ]) &#123; continue; &#125; int left = i + 1; int right = len - 1; while (left &lt; right) &#123; auto sum = nums[i] + nums[left] + nums[right]; if (sum == 0) &#123; ret.push_back(vector&lt;int&gt;&#123;nums[i], nums[left++], nums[right--]&#125;); // remove possible duplicate results while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) &#123; ++left; &#125; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) &#123; --right; &#125; &#125; else if (sum &gt; 0) &#123; --right; &#125; else &#123; ++left; &#125; &#125; &#125; return ret; &#125;&#125;; Java12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); int len = nums.length; Arrays.sort(nums); for (int i = 0; i &lt; len - 2 &amp;&amp; nums[i] &lt;= 0; ++i) &#123; // remove possible duplicate results if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; int left = i + 1; int right = len - 1; while (left &lt; right) &#123; int sum = nums[i] + nums[left] + nums[right]; if (sum == 0) &#123; ret.add(new ArrayList(Arrays.asList(nums[i], nums[left], nums[right]))); ++left; --right; // remove possible duplicate results while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) &#123; ++left; &#125; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) &#123; --right; &#125; &#125; else if (sum &gt; 0) &#123; --right; &#125; else &#123; ++left; &#125; &#125; &#125; return ret; &#125;&#125; 16. 3sum closetCpp1234567891011121314151617181920212223242526272829class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; int len = nums.size(); assert(len &gt;= 3); int min_diff = INT_MAX; std::sort(nums.begin(), nums.end()); for (int i = 0; i &lt; (len - 2); ++i) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; int left = i + 1; int right = len - 1; while (left &lt; right) &#123; int cur_diff = nums[i] + nums[left] + nums[right] - target; if (cur_diff == 0) &#123; return target; &#125; else if (cur_diff &gt; 0) &#123; right--; &#125; else &#123; left++; &#125; min_diff = abs(cur_diff) &lt; abs(min_diff) ? cur_diff : min_diff; &#125; &#125; return min_diff + target; &#125;&#125;; Java123456789101112131415161718192021222324252627282930public class Solution &#123; public int threeSumClosest(int[] nums, int target) &#123; int len = nums.length; int minDiff = Integer.MAX_VALUE; Arrays.sort(nums); for (int i = 0; i &lt; len - 2; ++i) &#123; // avoid duplicate calc if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; int left = i + 1; int right = len - 1; while (left &lt; right) &#123; int curDiff = nums[i] + nums[left] + nums[right] - target; if (curDiff == 0) &#123; return target; &#125; else if (curDiff &gt; 0) &#123; --right; &#125; else &#123; ++left; &#125; if (Math.abs(curDiff) &lt; Math.abs(minDiff)) &#123; minDiff = curDiff; &#125; &#125; &#125; return minDiff + target; &#125;&#125; 17. Letter Combinations of a Phone Number Given a digit string, return all possible letter combinations that the number could represent.A mapping of digit to letters (just like on the telephone buttons) is given below. Tags: backtracking, string Cpp12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; vector&lt;string&gt; ret; if (digits.empty()) &#123; return ret; &#125; vector&lt;string&gt; keyboard&#123;" ", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"&#125;; // return letterCombinationsIterative(digits, keyboard); letterCombinations(ret, "", 0, digits, keyboard); return ret; &#125;private: void letterCombinations(vector&lt;string&gt; &amp;ret, const string &amp;cur, size_t idx, const string &amp;digits, const vector&lt;string&gt; &amp;keyboard) &#123; if (idx &gt;= digits.size()) &#123; ret.push_back(cur); &#125; else &#123; for (auto c : keyboard[digits[idx] - '0']) &#123; letterCombinations(ret, cur + c, idx + 1, digits, keyboard); &#125; &#125; &#125; vector&lt;string&gt; letterCombinationsIterative(const string &amp;digits, const vector&lt;string&gt; &amp;keyboard) &#123; vector&lt;string&gt; ret&#123;""&#125;; for (auto d : digits) &#123; vector&lt;string&gt; tmp; for (auto r : ret) &#123; for (auto c : keyboard[d - '0']) &#123; tmp.push_back(r + c); &#125; &#125; ret.swap(tmp); &#125; return ret; &#125;&#125;; Java1234567891011121314151617181920212223242526272829303132333435363738394041public class Solution &#123; public List&lt;String&gt; letterCombinations(String digits) &#123; List&lt;String&gt; ret = new ArrayList&lt;&gt;(); if (digits.isEmpty()) &#123; return ret; &#125; ArrayList&lt;String&gt; keyboard = new ArrayList( Arrays.asList(" ", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz")); // return letterCombinationsIterative(digits, keyboard); letterCombinationsRecursive(ret, "", 0, digits, keyboard); return ret; &#125; private void letterCombinationsRecursive(List&lt;String&gt; ret, String cur, int idx, String digits, List&lt;String&gt; keyboard) &#123; if (idx &gt;= digits.length()) &#123; ret.add(cur); &#125; else &#123; String key = keyboard.get(digits.charAt(idx) - '0'); for (int i = 0; i &lt; key.length(); ++i) &#123; letterCombinationsRecursive(ret, cur + key.charAt(i), idx + 1, digits, keyboard); &#125; &#125; &#125; private List&lt;String&gt; letterCombinationsIterative(String digits, List&lt;String&gt; keyboard) &#123; List&lt;String&gt; ret = new ArrayList&lt;&gt;(); ret.add(""); for (int i = 0; i &lt; digits.length(); ++i) &#123; List&lt;String&gt; tmp = new ArrayList&lt;&gt;(); for (String r : ret) &#123; int cur = digits.charAt(i) - '0'; for (int j = 0; j &lt; keyboard.get(cur).length(); ++j) &#123; tmp.add(r + keyboard.get(cur).charAt(j)); &#125; &#125; ret = tmp; &#125; return ret; &#125;&#125; Scala12345678910111213141516171819202122232425262728object Solution &#123; def letterCombinations(digits: String): List[String] = &#123; val ret = List[String]() val keyboard = Array(" ", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz") digits.isEmpty match &#123; case true =&gt; ret case false =&gt; //letterCombinationsIterative(digits, keyboard) letterCombinationsRecursive(0, digits, keyboard) &#125; &#125; private def letterCombinationsRecursive(start: Int, digits: String, keyboard: Array[String]): List[String] = &#123; if (start &gt;= digits.size) &#123; List("") &#125; else &#123; val tmp = letterCombinationsRecursive(start + 1, digits, keyboard) (for &#123; k &lt;- keyboard(digits(start) - '0') t &lt;- tmp &#125; yield (k + t)).toList &#125; &#125; private def letterCombinationsIterative(digits: String, keyboard: Array[String]): List[String] = &#123; digits.foldLeft(List("")) &#123; (ret, d) =&gt; ret.flatMap &#123; r =&gt; keyboard(d - '0').map &#123; k =&gt; r + k &#125; &#125; &#125; &#125;&#125; 18. 4Sum Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.Note: The solution set must not contain duplicate quadruplets.For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] Tags: two pointer Cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;vector&lt;int&gt;&gt; ret; if (nums.size() &lt; 4) &#123; return ret; &#125; sort(nums.begin(), nums.end()); vector&lt;int&gt; cur; ksum(ret, 0, 4, cur, target, nums); return ret; &#125;private: void ksum(vector&lt;vector&lt;int&gt;&gt; &amp;ret, int start, int k, vector&lt;int&gt; &amp;cur, int target, const vector&lt;int&gt; &amp;nums) &#123; if (k * nums.front() &gt; target || k * nums.back() &lt; target) &#123; return; &#125; else if (k == 2) &#123; int left = start; int right = nums.size() - 1; while (left &lt; right) &#123; auto sum = nums[left] + nums[right] - target; if (sum == 0) &#123; auto tmp = cur; tmp.push_back(nums[left]); tmp.push_back(nums[right]); ret.push_back(tmp); ++left; --right; // avoid possible duplicates while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) &#123; ++left; &#125; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) &#123; --right; &#125; &#125; else if (sum &gt; 0) &#123; --right; &#125; else &#123; ++left; &#125; &#125; &#125; else &#123; for (int i = start; i &lt; nums.size() -k + 1; ++i) &#123; if (i &gt; start &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; cur.push_back(nums[i]); ksum(ret, i + 1, k - 1, cur, target - nums[i], nums); cur.pop_back(); &#125; &#125; &#125; &#125;; Java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); if (nums.length &lt; 4) &#123; return ret; &#125; Arrays.sort(nums); List&lt;Integer&gt; cur = new ArrayList&lt;&gt;(); ksum(ret, 0, 4, cur, target, nums); return ret; &#125; private void ksum(List&lt;List&lt;Integer&gt;&gt; ret, int start, int k, List&lt;Integer&gt; cur, int target, int[] nums) &#123; if (k * nums[0] &gt; target || k * nums[nums.length - 1] &lt; target) &#123; return; &#125; else if (k == 2) &#123; int left = start; int right = nums.length - 1; while (left &lt; right) &#123; int sum = nums[left] + nums[right] - target; if (sum == 0) &#123; List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(cur); tmp.add(nums[left]); tmp.add(nums[right]); ret.add(tmp); ++left; --right; // avoid possible duplicates while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) &#123; ++left; &#125; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) &#123; --right; &#125; &#125; else if (sum &gt; 0) &#123; --right; &#125; else &#123; ++left; &#125; &#125; &#125; else &#123; for (int i = start; i &lt; nums.length - k + 1; ++i) &#123; if (i &gt; start &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; cur.add(nums[i]); ksum(ret, i + 1, k - 1, cur, target - nums[i], nums); cur.remove(cur.size() - 1); &#125; &#125; &#125;&#125; Scala123456789101112131415161718192021222324252627282930313233343536373839object Solution &#123; def fourSum(nums: Array[Int], target: Int): List[List[Int]] = &#123; var ret: List[List[Int]] = List() if (nums.size &lt; 4) return ret val sortedNums = nums.sorted var cur: List[Int] = List() def ksum(start: Int, k: Int, target: Int): Unit = &#123; if (k == 2) &#123; var left = start; var right = sortedNums.size - 1 while (left &lt; right) &#123; var sum = sortedNums(left) + sortedNums(right) - target if (sum == 0) &#123; var tmp = cur ::: List(sortedNums(left), sortedNums(right)) ret = ret ::: List(tmp) left += 1 right -= 1 while (left &lt; right &amp;&amp; sortedNums(left) == sortedNums(left - 1)) left += 1 while (left &lt; right &amp;&amp; sortedNums(right) == sortedNums(right + 1)) right -= 1 &#125; else if (sum &gt; 0) &#123; right -= 1 &#125; else left += 1 &#125; &#125; else &#123; for (i &lt;- start until sortedNums.length - k + 1) &#123; if (i == start || sortedNums(i) != sortedNums(i - 1)) &#123; var tmp = cur cur = cur ::: List(sortedNums(i)) ksum(i + 1, k - 1, target - sortedNums(i)) cur = tmp &#125; &#125; &#125; &#125; ksum(0, 4, target) ret &#125;&#125; 19. Remove Nth Node From End of ListTags: List Cpp1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode dummy = ListNode(0); dummy.next = head; ListNode *first = &amp;dummy; for (int i = 0; i &lt; n; ++i) &#123; if (first == nullptr) &#123; return nullptr; &#125; else &#123; first = first-&gt;next; &#125; &#125; ListNode *pre = &amp;dummy; for (; first != nullptr &amp;&amp; first-&gt;next != nullptr; first = first-&gt;next) &#123; pre = pre-&gt;next; &#125; auto tmp = pre-&gt;next-&gt;next; delete pre-&gt;next; pre-&gt;next = tmp; return dummy.next; &#125;&#125;; Java123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode first = dummy; for (int i = 0; i &lt; n; ++i) &#123; if (first == null) &#123; return null; &#125; else &#123; first = first.next; &#125; &#125; ListNode ptr = dummy; for (; first != null &amp;&amp; first.next != null; first = first.next) &#123; ptr = ptr.next; &#125; ListNode tmp = ptr.next.next; ptr.next = null; ptr.next = tmp; return dummy.next; &#125;&#125; 20. Valid ParenthesesTags: Stack Cpp123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: bool isValid(string s) &#123; stack&lt;char&gt; stc; for (auto c : s) &#123; if (isLeft(c)) &#123; stc.push(c); &#125; else if (stc.empty()) &#123; return false; &#125; else if (isMatch(stc.top(), c)) &#123; stc.pop(); &#125; else &#123; return false; &#125; &#125; return stc.empty(); &#125; private: bool isLeft(char c) &#123; return (c == '(' || c == '&#123;' || c == '['); &#125; bool isMatch(char l, char r) &#123; if (l == '(') &#123; return r == ')'; &#125; else if (l == '&#123;') &#123; return r == '&#125;'; &#125; else if (l == '[') &#123; return r == ']'; &#125; else &#123; return false; &#125; &#125; &#125;; Java1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stc = new Stack&lt;&gt;(); for (int i = 0; i &lt; s.length(); ++i) &#123; char c = s.charAt(i); if (isLeft(c)) &#123; stc.push(c); &#125; else if (stc.empty()) &#123; return false; &#125; else if (isMatch(stc.peek(), c)) &#123; stc.pop(); &#125; else &#123; return false; &#125; &#125; return stc.empty(); &#125; private boolean isLeft(char c) &#123; return (c == '(' || c == '&#123;' || c == '['); &#125; private boolean isMatch(char l, char r) &#123; if (l == '(') &#123; return r == ')'; &#125; else if (l == '&#123;') &#123; return r == '&#125;'; &#125; else if (l == '[') &#123; return r == ']'; &#125; else &#123; return false; &#125; &#125; &#125;; Scala123456789101112131415object Solution &#123; def isValid(s: String): Boolean = &#123; val parenthesesMap = Map('(' -&gt; ')', '&#123;' -&gt; '&#125;', '[' -&gt; ']') val ret = s.foldLeft(List[Char]()) &#123; (stc, c) =&gt; c match &#123; case '(' | '&#123;' | '[' =&gt; c :: stc case ')' | '&#125;' | ']' =&gt; if (stc.isEmpty) return false else if (parenthesesMap.get(stc.head) != Some(c)) return false else stc.tail &#125; &#125; ret.isEmpty &#125;&#125; 21. Merge Two Sorted ListsCpp123456789101112131415161718192021222324/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if (l1 == nullptr) &#123; return l2; &#125; else if (l2 == nullptr) &#123; return l1; &#125; else if (l1-&gt;val &lt; l2-&gt;val) &#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125; else &#123; l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; &#125; &#125;&#125;; Java1234567891011121314151617181920212223/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) &#123; return l2; &#125; else if (l2 == null) &#123; return l1; &#125; else if (l1.val &lt; l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125; &#125;&#125; Scala1234567891011121314151617181920212223/** * Definition for singly-linked list. * class ListNode(var _x: Int = 0) &#123; * var next: ListNode = null * var x: Int = _x * &#125; */object Solution &#123; def mergeTwoLists(l1: ListNode, l2: ListNode): ListNode = &#123; (l1, l2) match &#123; case (null, _) =&gt; l2 case (_, null) =&gt; l1 case _ =&gt; (l1.x &lt; l2.x) match &#123; case true =&gt; l1.next = mergeTwoLists(l1.next, l2) l1 case false =&gt; l2.next = mergeTwoLists(l1, l2.next) l2 &#125; &#125; &#125;&#125; 22. Generate ParenthesesCpp123456789101112131415161718192021class Solution &#123;public: vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; ret; generateParenthesis(ret, "", n, n); return ret; &#125;private: void generateParenthesis(vector&lt;string&gt; &amp;ret, string cur, int curLeftNum, int curRightNum) &#123; if (curLeftNum == 0 &amp;&amp; curRightNum == 0) &#123; ret.push_back(cur); &#125; if (curLeftNum &gt; 0) &#123; generateParenthesis(ret, cur + '(', curLeftNum - 1, curRightNum); &#125; if (curRightNum &gt; curLeftNum) &#123; generateParenthesis(ret, cur + ')', curLeftNum, curRightNum - 1); &#125; &#125;&#125;; Java12345678910111213141516171819public class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; ret = new ArrayList&lt;&gt;(); generateParenthesis(ret, "", n, n); return ret; &#125; private void generateParenthesis(List&lt;String&gt; ret, String cur, int curLeftNum, int curRightNum) &#123; if (curLeftNum == 0 &amp;&amp; curRightNum == 0) &#123; ret.add(cur); &#125; if (curLeftNum &gt; 0) &#123; generateParenthesis(ret, cur + "(", curLeftNum - 1, curRightNum); &#125; if (curRightNum &gt; curLeftNum) &#123; generateParenthesis(ret, cur + ")", curLeftNum, curRightNum - 1); &#125; &#125;&#125; Scala12345678910111213141516171819202122232425object Solution &#123; def generateParenthesis(n: Int): List[String] = &#123; generateInternal(List[String](), "", n, n) &#125; private def generateInternal(ret: List[String], cur: String, curLeftNum: Int, curRightNum: Int): List[String] = &#123; if (curLeftNum == 0 &amp;&amp; curRightNum == 0) &#123; ret ::: List(cur) &#125; else &#123; val ret1 = &#123; if (curLeftNum &gt; 0) generateInternal(ret, cur + "(", curLeftNum - 1, curRightNum) else ret &#125; val ret2 = &#123; if (curRightNum &gt; curLeftNum) generateInternal(ret1, cur + ")", curLeftNum, curRightNum - 1) else ret1 &#125; ret2 &#125; &#125;&#125; 23. Merge k Sorted Lists Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. Tags: Linked List, Divide and Conquer, Heap C++123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; if (lists.empty()) &#123; return nullptr; &#125; for (int sz = static_cast&lt;int&gt;(lists.size()); sz &gt; 1; ) &#123; int offset = (sz + 1) / 2; for (int i = 0; i &lt; sz / 2; ++i) &#123; lists[i] = mergeTwoLists(lists[i], lists[i + offset]); &#125; sz = offset; &#125; return lists.front(); &#125; private: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if (l1 == nullptr) &#123; return l2; &#125; else if (l2 == nullptr) &#123; return l1; &#125; else if (l1-&gt;val &lt; l2-&gt;val) &#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125; else &#123; l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; &#125; &#125;&#125;; Java12345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; if (lists.length == 0) &#123; return null; &#125; for (int sz = lists.length; sz &gt; 1; ) &#123; int offset = (sz + 1) / 2; for (int i = 0; i &lt; sz / 2; ++i) &#123; lists[i] = mergeTwoLists(lists[i], lists[i + offset]); &#125; sz = offset; &#125; return lists[0]; &#125; private ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) &#123; return l2; &#125; else if (l2 == null) &#123; return l1; &#125; else if (l1.val &lt; l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125; &#125;&#125; 24. Swap Nodes in Pairs Given a linked list, swap every two adjacent nodes and return its head.For example,Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. Tags: LinkedList C++123456789101112131415161718192021222324/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; ListNode dummy(1); dummy.next = head; auto pre = &amp;dummy; for (auto cur = head; cur != nullptr &amp;&amp; cur-&gt;next != nullptr; cur = cur-&gt;next) &#123; auto tmp = cur-&gt;next; cur-&gt;next = tmp-&gt;next; tmp-&gt;next = cur; pre-&gt;next = tmp; pre = cur; &#125; return dummy.next; &#125;&#125;; Java1234567891011121314151617181920212223/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode swapPairs(ListNode head) &#123; ListNode dummy = new ListNode(1); dummy.next = head; ListNode pre = dummy; for (ListNode cur = head; cur != null &amp;&amp; cur.next != null; cur = cur.next) &#123; ListNode tmp = cur.next; cur.next = tmp.next; tmp.next = cur; pre.next = tmp; pre = cur; &#125; return dummy.next; &#125;&#125; 25. Reverse Nodes in k-Group Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.You may not alter the values in the nodes, only nodes itself may be changed.Only constant memory is allowed. For example,Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5 Tags: Array, HashTable C++1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseKGroup(ListNode* head, int k) &#123; ListNode dummy = ListNode(0); dummy.next = head; auto pre = &amp;dummy; auto ptr = &amp;dummy; for (int i = 0; i &lt; k &amp;&amp; ptr != nullptr; ++i) &#123; ptr = ptr-&gt;next; &#125; while (ptr != nullptr) &#123; auto nextDummy = pre-&gt;next; for (int i = 1; i &lt; k; ++i) &#123; auto tmp = pre-&gt;next-&gt;next; pre-&gt;next-&gt;next = ptr-&gt;next; ptr-&gt;next = pre-&gt;next; pre-&gt;next = tmp; &#125; pre = nextDummy; ptr = nextDummy; for (int i = 0; i &lt; k &amp;&amp; ptr != nullptr; ++i) &#123; ptr = ptr-&gt;next; &#125; &#125; return dummy.next; &#125;&#125;; Java12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseKGroup(ListNode head, int k) &#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode pre = dummy; ListNode ptr = dummy; for (int i = 0; i &lt; k &amp;&amp; ptr != null; ++i) &#123; ptr = ptr.next; &#125; while (ptr != null) &#123; ListNode nextDummy = pre.next; for (int i = 1; i &lt; k; ++i) &#123; ListNode tmp = pre.next.next; pre.next.next = ptr.next; ptr.next = pre.next; pre.next = tmp; &#125; pre = nextDummy; ptr = nextDummy; for (int i = 0; i &lt; k &amp;&amp; ptr != null; ++i) &#123; ptr = ptr.next; &#125; &#125; return dummy.next; &#125;&#125; 26. Remove Duplicates from Sorted ArrayCpp1234567891011121314class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int pre = -1; for (int cur = 0; cur &lt; static_cast&lt;int&gt;(nums.size()); ++cur) &#123; if (pre == -1) &#123; ++pre; &#125; else if (nums[cur] != nums[cur - 1]) &#123; nums[++pre] = nums[cur]; &#125; &#125; return pre + 1; &#125;&#125;; Java12345678910111213public class Solution &#123; public int removeDuplicates(int[] nums) &#123; int pre = -1; for (int cur = 0; cur &lt; nums.length; ++cur) &#123; if (pre == -1) &#123; ++pre; &#125; else if (nums[cur] != nums[cur - 1]) &#123; nums[++pre] = nums[cur]; &#125; &#125; return pre + 1; &#125;&#125; Scala1234567891011121314object Solution &#123; def removeDuplicates(nums: Array[Int]): Int = &#123; var pre = -1 for (cur &lt;- 0 until nums.length) &#123; if (pre == -1) &#123; pre += 1 &#125; else if (nums(cur) != nums(cur - 1)) &#123; pre += 1 nums(pre) = nums(cur) &#125; &#125; return pre + 1 &#125;&#125; 27. Remove ElementC++123456789101112class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int ret = 0; for (auto n : nums) &#123; if (n != val) &#123; nums[ret++] = n; &#125; &#125; return ret; &#125;&#125;; Java1234567891011class Solution &#123; public int removeElement(int[] nums, int val) &#123; int ret = 0; for (int i = 0; i &lt; nums.length; ++i) &#123; if (nums[i] != val) &#123; nums[ret++] = nums[i]; &#125; &#125; return ret; &#125;&#125; Scala123456789101112object Solution &#123; def removeElement(nums: Array[Int], v: Int): Int = &#123; var ret = 0 for (i &lt;- 0 until nums.size) &#123; if (nums(i) != v) &#123; nums(ret) = nums(i) ret += 1 &#125; &#125; return ret &#125;&#125; 28. Implement strStrTags: Two Pointers, String C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Solution &#123;public: int strStr(string haystack, string needle) &#123; int ret1 = strStrBackoff(haystack, needle); int ret2 = strStrBruteForce(haystack, needle); int ret3 = strStrKMP(haystack, needle); cout &lt;&lt; ret1 &lt;&lt; " " &lt;&lt; ret2 &lt;&lt; " " &lt;&lt; ret3 &lt;&lt; endl; assert(ret1 == ret2 &amp;&amp; ret2 == ret3); return ret1; &#125; private: int strStrBruteForce(const string &amp;source, const string &amp;target) &#123; int src_len = static_cast&lt;int&gt;(source.size()); int tgt_len = static_cast&lt;int&gt;(target.size()); for (int i = 0; i &lt;= src_len - tgt_len; ++i) &#123; int j = 0; for ( ; j &lt; tgt_len &amp;&amp; source[i + j] == target[j]; ++j) &#123;&#125; if (j == tgt_len) &#123; return i; &#125; &#125; return -1; &#125; int strStrBackoff(const string &amp;source, const string &amp;target) &#123; int src_len = static_cast&lt;int&gt;(source.size()); int tgt_len = static_cast&lt;int&gt;(target.size()); int i = 0; int j = 0; for ( ; i &lt; src_len &amp;&amp; j &lt; tgt_len; ++i) &#123; if (source[i] == target[j]) &#123; ++j; &#125; else &#123; i -= j; j = 0; &#125; &#125; if (j == tgt_len) &#123; return i - tgt_len; &#125; return -1; &#125; int strStrKMP(string source, string target) &#123; if (target.empty()) &#123; return 0; &#125; auto getPattern = [](const string&amp; str) &#123; vector&lt;int&gt; pattern(str.length(), 0); int k = 0; for (size_t i = 1; i &lt; str.length(); ++i) &#123; while (k &gt; 0 &amp;&amp; str[k] != str[i]) &#123; k = pattern[k - 1]; &#125; if (str[k] == str[i]) &#123; ++k; &#125; pattern[i] = k; &#125; return pattern; &#125;; auto pattern = getPattern(target); int k = 0; for (size_t i = 0; i &lt; source.length(); ++i) &#123; while (k &gt; 0 &amp;&amp; source[i] != target[k]) &#123; k = pattern[k - 1]; &#125; if (source[i] == target[k]) &#123; ++k; &#125; if (k == target.length()) &#123; return i - k + 1; &#125; &#125; return -1; &#125;&#125;; Java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class Solution &#123; public int strStr(String haystack, String needle) &#123; int ret1 = strStrBruteForce(haystack, needle); int ret2 = strKMP(haystack, needle); int ret3 = strStrBackoff(haystack, needle); System.out.println("ret1 = " + ret1 + " ret2 = " + ret2 + " ret3 = " + ret3); assert ret1 == ret2; assert ret2 == ret3; return ret2; &#125; private int strStrBackoff(String source, String target) &#123; int i = 0; int j = 0; for ( ; i &lt; source.length() &amp;&amp; j &lt; target.length(); ) &#123; if (source.charAt(i) == target.charAt(j)) &#123; ++j; &#125; else &#123; i -= j; j = 0; &#125; ++i; &#125; if (j == target.length()) &#123; return i - j; &#125; return -1; &#125; private int strStrBruteForce(String source, String target) &#123; for (int i = 0; i &lt;= source.length() - target.length(); ++i) &#123; int j = 0; for ( ; j &lt; target.length() &amp;&amp; source.charAt(i + j) == target.charAt(j); ++j) &#123;&#125; if (j == target.length()) &#123; return i; &#125; &#125; return -1; &#125; private List&lt;Integer&gt; kmpPattern(String target) &#123; List&lt;Integer&gt; pattern = new ArrayList&lt;&gt;(Collections.nCopies(target.length(), 0)); int k = 0; for (int i = 1; i &lt; target.length(); ++i) &#123; while (k &gt; 0 &amp;&amp; target.charAt(k) != target.charAt(i)) &#123; k = pattern.get(k - 1); &#125; if (target.charAt(k) == target.charAt(i)) &#123; ++k; &#125; pattern.set(i, k); &#125; return pattern; &#125; private int strKMP(String source, String target) &#123; if (target.isEmpty()) &#123; return 0; &#125; List&lt;Integer&gt; pattern = kmpPattern(target); int k = 0; for (int i = 0; i &lt; source.length(); ++i) &#123; while (k &gt; 0 &amp;&amp; source.charAt(i) != target.charAt(k)) &#123; k = pattern.get(k - 1); &#125; if (source.charAt(i) == target.charAt(k)) &#123; ++k; &#125; if (k == target.length()) &#123; return i - k + 1; &#125; &#125; return -1; &#125;&#125; 33. Search in Rotated Sorted ArrayTags: Binary Search Cpp123456789101112131415161718192021222324252627class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0; int right = static_cast&lt;int&gt;(nums.size()) - 1; while (left &lt;= right) &#123; int mid = (right - left) / 2 + left; if (nums[mid] == target) &#123; return mid; &#125; if (nums[mid] &gt;= nums[left]) &#123; if (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; else &#123; if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; &#125; return -1; &#125;&#125;; Java1234567891011121314151617181920212223242526class Solution &#123; public int search(int[] nums, int target) &#123; int left = 0; int right = nums.length - 1; while (left &lt;= right) &#123; int mid = (right - left) / 2 + left; if (nums[mid] == target) &#123; return mid; &#125; if (nums[mid] &gt;= nums[left]) &#123; if (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; else &#123; if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; &#125; return -1; &#125;&#125; 34. Search for a RangeCpp12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; ret&#123;-1, -1&#125;; ret[0] = findLowerBound(nums, target); ret[1] = findUpperBound(nums, target); return ret; &#125;private: int findLowerBound(const vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0; int right = static_cast&lt;int&gt;(nums.size()) - 1; while (left &lt;= right) &#123; int mid = (right - left) / 2 + left; // move left to get first greater or equal than target if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; return nums[left] == target ? left : -1; &#125; int findUpperBound(const vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0; int right = static_cast&lt;int&gt;(nums.size()) - 1; while (left &lt;= right) &#123; int mid = (right - left) / 2 + left; // move right to get first less or equal than target if (nums[mid] &gt; target) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return nums[right] == target ? right : -1; &#125;&#125;; Java1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; int[] ret = &#123;-1, -1&#125;; ret[0] = lowerBound(nums, target); ret[1] = upperBound(nums, target); return ret; &#125; private int lowerBound(int[] nums, int target) &#123; int left = 0; int right = nums.length - 1; while (left &lt;= right) &#123; int mid = (right - left) / 2 + left; if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; if (nums[left] == target) &#123; return left; &#125; else &#123; return -1; &#125; &#125; private int upperBound(int[] nums, int target) &#123; int left = 0; int right = nums.length - 1; while (left &lt;= right) &#123; int mid = (right - left) / 2 + left; if (nums[mid] &gt; target) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; if (nums[right] == target) &#123; return right; &#125; else &#123; return -1; &#125; &#125;&#125; 39. Combination Sum Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.The same repeated number may be chosen from C unlimited number of times.Note:All numbers (including target) will be positive integers.The solution set must not contain duplicate combinations.For example, given candidate set [2, 3, 6, 7] and target 7,A solution set is:[ [7], [2, 2, 3]] Tags: Array, Backtracking C++123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt;&gt; ret; vector&lt;int&gt; cur; std::sort(candidates.begin(), candidates.end()); combinationSum(candidates, target, 0, ret, cur); return ret; &#125;private: void combinationSum(const vector&lt;int&gt;&amp; candidates, int target, size_t start, vector&lt;vector&lt;int&gt;&gt;&amp; ret, vector&lt;int&gt;&amp; cur) &#123; if (target == 0) &#123; ret.push_back(cur); &#125; else if (target &gt; 0 &amp;&amp; start &lt; candidates.size()) &#123; cur.push_back(candidates[start]); combinationSum(candidates, target - candidates[start], start, ret, cur); cur.pop_back(); combinationSum(candidates, target, start + 1, ret, cur); &#125; &#125;&#125;; Java12345678910111213141516171819202122232425class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); Arrays.sort(candidates); LinkedList&lt;Integer&gt; cur = new LinkedList&lt;&gt;(); combinationSum(ret, cur, candidates, target, 0); return ret; &#125; private void combinationSum( List&lt;List&lt;Integer&gt;&gt; ret, LinkedList&lt;Integer&gt; cur, int[] candidates, int target, int start) &#123; if (target == 0) &#123; ret.add(new ArrayList&lt;&gt;(cur)); &#125; else if (target &gt; 0 &amp;&amp; start &lt; candidates.length) &#123; cur.add(candidates[start]); combinationSum(ret, cur, candidates, target - candidates[start], start); cur.removeLast(); combinationSum(ret, cur, candidates, target, start + 1); &#125; &#125;&#125; 40. Combination Sum II Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.Each number in C may only be used once in the combination.Note:All numbers (including target) will be positive integers.The solution set must not contain duplicate combinations.For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,A solution set is:[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] Tags: Array, Dynamic Programming C++123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt;&gt; ret; vector&lt;int&gt; cur; std::sort(candidates.begin(), candidates.end()); combinationSum2(candidates, target, 0, ret, cur); return ret; &#125; private: void combinationSum2( const vector&lt;int&gt;&amp; candidates, int target, size_t start, vector&lt;vector&lt;int&gt;&gt;&amp; ret, vector&lt;int&gt;&amp; cur) &#123; if (target == 0) &#123; ret.push_back(cur); &#125; else if (target &gt; 0 &amp;&amp; start &lt; candidates.size()) &#123; cur.push_back(candidates[start]); combinationSum2(candidates, target - candidates[start], start + 1, ret, cur); cur.pop_back(); do &#123; ++start; &#125; while (start &gt; 0 &amp;&amp; start &lt; candidates.size() &amp;&amp; candidates[start] == candidates[start - 1]); combinationSum2(candidates, target, start, ret, cur); &#125; &#125;&#125;; Java123456789101112131415161718192021222324252627class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); LinkedList&lt;Integer&gt; cur = new LinkedList&lt;&gt;(); Arrays.sort(candidates); combinationSum2(ret, cur, candidates, target, 0); return ret; &#125; private void combinationSum2(List&lt;List&lt;Integer&gt;&gt; ret, LinkedList&lt;Integer&gt; cur, int[] candidates, int target, int start) &#123; if (target == 0) &#123; ret.add(new ArrayList&lt;&gt;(cur)); &#125; else if (target &gt; 0 &amp;&amp; start &lt; candidates.length) &#123; cur.add(candidates[start]); combinationSum2(ret, cur, candidates, target - candidates[start], start + 1); cur.removeLast(); do &#123; // remove duplicate results when same number of contiguous in candidates ++start; &#125; while (target &gt; 0 &amp;&amp; start &lt; candidates.length &amp;&amp; candidates[start] == candidates[start - 1]); combinationSum2(ret, cur, candidates, target, start); &#125; &#125;&#125; 46. PermutationsTags: Backtracking C++12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; ret; permute(ret, nums, 0); return ret; &#125;private: void permute(vector&lt;vector&lt;int&gt;&gt;&amp; ret, vector&lt;int&gt;&amp; nums, int start) &#123; if (start == nums.size()) &#123; ret.push_back(nums); &#125; else &#123; for (size_t i = start; i != nums.size(); ++i) &#123; swap(nums[start], nums[i]); permute(ret, nums, start + 1); swap(nums[start], nums[i]); &#125; &#125; &#125;&#125;; Java1234567891011121314151617181920class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); List&lt;Integer&gt; numList = Arrays.stream(nums).boxed().collect(Collectors.toList()); permute(ret, numList, 0); return ret; &#125; private void permute(List&lt;List&lt;Integer&gt;&gt; ret, List&lt;Integer&gt; nums, int start) &#123; if (start &gt;= nums.size()) &#123; ret.add(new ArrayList(nums)); &#125; else &#123; for (int i = start; i &lt; nums.size(); ++i) &#123; Collections.swap(nums, start, i); permute(ret, nums, start + 1); Collections.swap(nums, start, i); &#125; &#125; &#125;&#125; 47. Permutations IITags: Backtracking C++123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; ret; permutation(ret, nums, 0); return ret; &#125;private: void permutation(vector&lt;vector&lt;int&gt;&gt;&amp; ret, vector&lt;int&gt;&amp; nums, size_t start) &#123; if (start &gt;= nums.size()) &#123; ret.push_back(nums); &#125; else &#123; for (size_t idx = start; idx != nums.size(); ++idx) &#123; if (std::find(nums.begin() + start, nums.begin() + idx, nums[idx]) == (nums.begin() + idx)) &#123; swap(nums[idx], nums[start]); permutation(ret, nums, start + 1); swap(nums[idx], nums[start]); &#125; &#125; &#125; &#125;&#125;; Java1234567891011121314151617181920212223242526272829class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); List&lt;Integer&gt; numList = Arrays.stream(nums).boxed().collect(Collectors.toList()); permute(ret, numList, 0); return ret; &#125; private void permute(List&lt;List&lt;Integer&gt;&gt; ret, List&lt;Integer&gt; nums, int start) &#123; if (start &gt;= nums.size()) &#123; ret.add(new ArrayList(nums)); &#125; else &#123; for (int i = start; i &lt; nums.size(); ++i) &#123; int idx = start; for ( ; idx &lt; i; ++idx) &#123; if (nums.get(idx) == nums.get(i)) &#123; break; &#125; &#125; if (idx &lt; i) &#123; continue; &#125; Collections.swap(nums, start, i); permute(ret, nums, start + 1); Collections.swap(nums, start, i); &#125; &#125; &#125;&#125; 53. Maximum Subarray Find the contiguous subarray within an array (containing at least one number) which has the largest sum.For example, given the array [-2,1,-3,4,-1,2,1,-5,4],the contiguous subarray [4,-1,2,1] has the largest sum = 6. Tags: Array, Dynamic Programming C++12345678910111213141516class Solution &#123;public: // nums[i] may be part of current maxSubArray just start of new current maxSubArray int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) &#123; return 0; &#125; int cur_max = nums[0]; int ret = cur_max; for (int i = 1; i &lt; static_cast&lt;int&gt;(nums.size()); ++i) &#123; cur_max = std::max(cur_max + nums[i], nums[i]); ret = std::max(ret, cur_max); &#125; return ret; &#125;&#125;; Java123456789101112131415class Solution &#123; public int maxSubArray(int[] nums) &#123; if (nums.length == 0) &#123; return 0; &#125; int ret = nums[0]; int cur_max = nums[0]; for (int i = 1; i &lt; nums.length; ++i) &#123; // nums[i] is either part of cur_max sequence or start of a new one cur_max = Math.max(cur_max + nums[i], nums[i]); ret = Math.max(cur_max, ret); &#125; return ret; &#125;&#125; 94. Binary Tree Inorder TraversalTags: Tree C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; // return inorderTraversalIterative(root); return inorderTraversalMorris(root); &#125;private: vector&lt;int&gt; inorderTraversalMorris(TreeNode* root) &#123; vector&lt;int&gt; ret; if (root == nullptr) &#123; return ret; &#125; auto cur = root; while (cur != nullptr) &#123; if (cur-&gt;left == nullptr) &#123; ret.push_back(cur-&gt;val); cur = cur-&gt;right; &#125; else &#123; auto pre = cur-&gt;left; while (pre-&gt;right != nullptr &amp;&amp; pre-&gt;right != cur) &#123; pre = pre-&gt;right; &#125; if (pre-&gt;right == nullptr) &#123; pre-&gt;right = cur; cur = cur-&gt;left; &#125; else &#123; ret.push_back(cur-&gt;val); // move to if would make this preorderTraversal pre-&gt;right = nullptr; cur = cur-&gt;right; &#125; &#125; &#125; return ret; &#125; vector&lt;int&gt; inorderTraversalIterative(const TreeNode* root) &#123; vector&lt;int&gt; ret; if (root == nullptr) &#123; return ret; &#125; stack&lt;const TreeNode*&gt; stc; auto ptr = root; while (ptr != nullptr || !stc.empty()) &#123; if (ptr == nullptr) &#123; ptr = stc.top(); stc.pop(); ret.push_back(ptr-&gt;val); ptr = ptr-&gt;right; &#125; else &#123; stc.push(ptr); ptr = ptr-&gt;left; &#125; &#125; return ret; &#125;&#125;; Java12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); if (root == null) &#123; return ret; &#125; TreeNode cursor = root; Stack&lt;TreeNode&gt; stc = new Stack&lt;&gt;(); while (cursor != null || !stc.empty()) &#123; if (cursor == null) &#123; cursor = stc.peek(); stc.pop(); ret.add(cursor.val); cursor = cursor.right; &#125; else &#123; stc.push(cursor); cursor = cursor.left; &#125; &#125; return ret; &#125;&#125; 103. Binary Tree Zigzag Level Order TraversalTags: Tree, BFS C++12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; ret; if (root == nullptr) &#123; return ret; &#125; vector&lt;TreeNode*&gt; curLevel&#123;root&#125;; bool flag = false; while (!curLevel.empty()) &#123; vector&lt;TreeNode*&gt; nextLevel; vector&lt;int&gt; cur; cur.reserve(curLevel.size()); if (flag) &#123; for (auto itr = curLevel.rbegin(); itr != curLevel.rend(); ++itr) &#123; cur.push_back((*itr)-&gt;val); &#125; &#125; else &#123; for (auto itr = curLevel.begin();itr != curLevel.end(); ++itr) &#123; cur.push_back((*itr)-&gt;val); &#125; &#125; for (auto node : curLevel) &#123; if (node-&gt;left != nullptr) &#123; nextLevel.push_back(node-&gt;left); &#125; if (node-&gt;right != nullptr) &#123; nextLevel.push_back(node-&gt;right); &#125; &#125; flag = !flag; std::swap(curLevel, nextLevel); ret.push_back(std::move(cur)); &#125; return ret; &#125;&#125;; Java12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); if (root == null) &#123; return ret; &#125; List&lt;TreeNode&gt; curLevel = new ArrayList&lt;&gt;(); boolean flag = false; curLevel.add(root); while (!curLevel.isEmpty()) &#123; List&lt;TreeNode&gt; nextLevel = new ArrayList&lt;&gt;(); List&lt;Integer&gt; cur = new ArrayList&lt;&gt;(); if (flag) &#123; for (int i = curLevel.size() - 1; i &gt;= 0; --i) &#123; cur.add(curLevel.get(i).val); &#125; &#125; else &#123; for (TreeNode n : curLevel) &#123; cur.add(n.val); &#125; &#125; for (TreeNode node : curLevel) &#123; if (node.left != null) &#123; nextLevel.add(node.left); &#125; if (node.right != null) &#123; nextLevel.add(node.right); &#125; &#125; ret.add(new ArrayList&lt;&gt;(cur)); flag = !flag; curLevel = nextLevel; nextLevel = null; &#125; return ret; &#125;&#125; 112. Path Sum Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.For example:Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22. Tags: Tree, Backtracking C++1234567891011121314151617181920class Solution &#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; if (root == nullptr) &#123; return false; &#125; sum -= root-&gt;val; if (isLeaf(root)) &#123; return sum == 0; &#125; else &#123; return hasPathSum(root-&gt;left, sum) || hasPathSum(root-&gt;right, sum); &#125; &#125; private: inline bool isLeaf(const TreeNode* root) &#123; return root != nullptr &amp;&amp; root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr; &#125; &#125;; Java12345678910111213141516class Solution &#123; public boolean hasPathSum(TreeNode root, int sum) &#123; if (root == null) &#123; return false; &#125; if (isLeaf(root)) &#123; return sum == root.val; &#125; else &#123; return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val); &#125; &#125; private boolean isLeaf(TreeNode node) &#123; return node.left == null &amp;&amp; node.right == null; &#125;&#125; 113. Path Sum II Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.For example:Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ / \ 7 2 5 1return[ [5,4,11,2], [5,8,4,5]] Tags: Tree, Backtracking C++1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123; vector&lt;vector&lt;int&gt;&gt; ret; vector&lt;int&gt; path; pathSum(root, sum ,ret, path); return ret; &#125; private: void pathSum(const TreeNode* root, int sum, vector&lt;vector&lt;int&gt;&gt;&amp; ret, vector&lt;int&gt;&amp; path) &#123; if (root == nullptr) &#123; return; &#125; path.push_back(root-&gt;val); sum -= root-&gt;val; if (isLeaf(root) &amp;&amp; sum == 0) &#123; ret.push_back(path); &#125; else &#123; pathSum(root-&gt;left, sum, ret, path); pathSum(root-&gt;right, sum, ret, path); &#125; path.pop_back(); &#125; inline bool isLeaf(const TreeNode* root) &#123; return root != nullptr &amp;&amp; root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr; &#125;&#125;; Java12345678910111213141516171819202122232425262728class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123; List&lt;List&lt;Integer&gt;&gt; ret = new LinkedList&lt;&gt;(); LinkedList&lt;Integer&gt; cur = new LinkedList&lt;&gt;(); pathSum(ret, cur, root, sum); return ret; &#125; private void pathSum(List&lt;List&lt;Integer&gt;&gt; ret, LinkedList&lt;Integer&gt; cur, TreeNode root, int sum) &#123; if (root == null) &#123; return; &#125; sum -= root.val; cur.add(root.val); if (isLeaf(root) &amp;&amp; sum == 0) &#123; ret.add(new LinkedList&lt;&gt;(cur)); &#125; else &#123; pathSum(ret, cur, root.left, sum); pathSum(ret, cur, root.right, sum); &#125; cur.removeLast(); &#125; private boolean isLeaf(TreeNode root) &#123; return root != null &amp;&amp; root.left == null &amp;&amp; root.right == null; &#125; &#125; 121. Best Time to Buy and Sell Stock Say you have an array for which the ith element is the price of a given stock on day i.If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. Tags: Dynamic Programming C++123456789101112131415class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if (prices.empty()) &#123; return 0; &#125; int ret = 0; int last_min = prices[0]; for (size_t i = 1; i &lt; prices.size(); ++i) &#123; ret = std::max(prices[i] - last_min, ret); last_min = std::min(prices[i], last_min); &#125; return ret; &#125;&#125;; Java1234567891011121314class Solution &#123; public int maxProfit(int[] prices) &#123; if (prices.length &lt;= 0) &#123; return 0; &#125; int ret = 0; int curMin = prices[0]; for (int i = 1; i &lt; prices.length; ++i) &#123; ret = Math.max(ret, prices[i] - curMin); curMin = Math.min(prices[i], curMin); &#125; return ret; &#125;&#125; 122. Best Time to Buy and Sell Stock II Say you have an array for which the ith element is the price of a given stock on day i.Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). Tags: Greedy C++1234567891011class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int ret = 0; for (size_t i = 1; i &lt; prices.size(); ++i) &#123; auto tmp = prices[i] - prices[i - 1]; ret += (tmp &gt; 0 ? tmp : 0); &#125; return ret; &#125;&#125;; Java123456789101112class Solution &#123; public int maxProfit(int[] prices) &#123; if (prices.length &lt;= 0) &#123; return 0; &#125; int ret = 0; for (int i = 1; i &lt; prices.length; ++i) &#123; ret += Math.max(prices[i] - prices[i - 1], 0); &#125; return ret; &#125;&#125; 144. Binary Tree Preorder TraversalTags: Tree C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; //return preorderTraversalIterative(root); return preorderTraversalMorris(root); &#125;private: vector&lt;int&gt; preorderTraversalMorris(TreeNode* root) &#123; vector&lt;int&gt; ret; if (root == nullptr) &#123; return ret; &#125; // swap left and right and ret make it postorderTraversal auto cur = root; while (cur != nullptr) &#123; if (cur-&gt;left == nullptr) &#123; ret.push_back(cur-&gt;val); cur = cur-&gt;right; &#125; else &#123; auto pre = cur-&gt;left; while (pre-&gt;right != nullptr &amp;&amp; pre-&gt;right != cur) &#123; pre = pre-&gt;right; &#125; if (pre-&gt;right == nullptr) &#123; ret.push_back(cur-&gt;val); // move it to else make this inorderTraversa; pre-&gt;right = cur; cur = cur-&gt;left; &#125; else &#123; pre-&gt;right = nullptr; cur = cur-&gt;right; &#125; &#125; &#125; return ret; &#125; vector&lt;int&gt; preorderTraversalIterative(const TreeNode* root) &#123; vector&lt;int&gt; ret; if (root == nullptr) &#123; return ret; &#125; stack&lt;const TreeNode*&gt; stc; auto ptr = root; while (ptr != nullptr || !stc.empty()) &#123; if (ptr == nullptr) &#123; ptr = stc.top(); stc.pop(); &#125; ret.push_back(ptr-&gt;val); if (ptr-&gt;right != nullptr) &#123; stc.push(ptr-&gt;right); &#125; ptr = ptr-&gt;left; &#125; return ret; &#125;&#125;; Java12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); if (root == null) &#123; return ret; &#125; TreeNode cursor = root; Stack&lt;TreeNode&gt; stc = new Stack&lt;&gt;(); while (cursor != null || !stc.empty()) &#123; if (cursor == null) &#123; cursor = stc.peek(); stc.pop(); &#125; ret.add(cursor.val); if (cursor.right != null) &#123; stc.push(cursor.right); &#125; cursor = cursor.left; &#125; return ret; &#125;&#125; 145. Binary Tree Postorder TraversalTags: Tree C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; //return postorderTraversalIterative(root); return postorderTraversalMorris(root); &#125;private: vector&lt;int&gt; postorderTraversalMorris(TreeNode* root) &#123; vector&lt;int&gt; ret; if (root == nullptr) &#123; return ret; &#125; // swap preorder's left and right and reverse ret makes this postorderTraversal auto cur = root; while (cur != nullptr) &#123; if (cur-&gt;right == nullptr) &#123; ret.push_back(cur-&gt;val); cur = cur-&gt;left; &#125; else &#123; auto pre = cur-&gt;right; while (pre-&gt;left != nullptr &amp;&amp; pre-&gt;left != cur) &#123; pre = pre-&gt;left; &#125; if (pre-&gt;left == nullptr) &#123; ret.push_back(cur-&gt;val); pre-&gt;left = cur; cur = cur-&gt;right; &#125; else &#123; pre-&gt;left = nullptr; cur = cur-&gt;left; &#125; &#125; &#125; reverse(ret.begin(), ret.end()); return ret; &#125; vector&lt;int&gt; postorderTraversalIterative(const TreeNode* root) &#123; vector&lt;int&gt; ret; if (root == nullptr) &#123; return ret; &#125; // swap preorder's left and right and reverse ret makes this postorderTraversal stack&lt;const TreeNode*&gt; stc; auto ptr = root; while (ptr != nullptr || !stc.empty()) &#123; if (ptr == nullptr) &#123; ptr = stc.top(); stc.pop(); &#125; ret.push_back(ptr-&gt;val); if (ptr-&gt;left != nullptr) &#123; stc.push(ptr-&gt;left); &#125; ptr = ptr-&gt;right; &#125; reverse(ret.begin(), ret.end()); return ret; &#125;&#125;; Java123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); if (root == null) &#123; return ret; &#125; // swap preorder's left and right and reverse ret makes this postorderTraversal TreeNode cursor = root; Stack&lt;TreeNode&gt; stc = new Stack&lt;&gt;(); while (cursor != null || !stc.empty()) &#123; if (cursor == null) &#123; cursor = stc.peek(); stc.pop(); &#125; ret.add(cursor.val); if (cursor.left != null) &#123; stc.push(cursor.left); &#125; cursor = cursor.right; &#125; Collections.reverse(ret); return ret; &#125;&#125; 152. Maximum Product Subarray Find the contiguous subarray within an array (containing at least one number) which has the largest product.For example, given the array [2,3,-2,4],the contiguous subarray [2,3] has the largest product = 6. Tags: Array, Dynamic Programming C++12345678910111213141516171819202122class Solution &#123;public: // num[i] is eithor end of last maxProduct or last minProduct // or start of new maxProduct or minProduct // cur_max = max(cur_max * nums[i], cur_min * nums[i], nums[i]) // cur_min = min(cur_max * nums[i], cur_min * nums[i], nums[i]) int maxProduct(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) &#123; return 0; &#125; int cur_max = nums[0]; int cur_min = nums[0]; int ret = cur_max; for (int i = 1; i &lt; static_cast&lt;int&gt;(nums.size()); ++i) &#123; int tmp = cur_max; cur_max = std::max(cur_max * nums[i], std::max(cur_min * nums[i], nums[i])); cur_min = std::min(tmp * nums[i], std::min(cur_min * nums[i], nums[i])); ret = std::max(cur_max, ret); &#125; return ret; &#125;&#125;; Java12345678910111213141516171819class Solution &#123; public int maxProduct(int[] nums) &#123; if (nums.length == 0) &#123; return 0; &#125; int ret = nums[0]; int cur_min = ret; int cur_max = ret; for (int i = 1; i &lt; nums.length; ++i) &#123; int tmp = cur_min; // num[i] is either part of cur_min sequnce or cur_max sequnce or start of new, // and the cur_min or cur_max would be flipped when encounter negtive number. cur_min = Math.min(Math.min(nums[i], cur_min * nums[i]), cur_max * nums[i]); cur_max = Math.max(Math.max(nums[i], cur_max * nums[i]), tmp * nums[i]); ret = Math.max(cur_max, ret); &#125; return ret; &#125;&#125; 173. Binary Search Tree Iterator mplement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.Calling next() will return the next smallest number in the BST.Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree. Tags: Tree C++123456789101112131415161718192021222324252627282930313233343536/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class BSTIterator &#123;public: BSTIterator(TreeNode *root) &#123; for ( ; root != nullptr; root = root-&gt;left) &#123; stc.push(root); &#125; &#125; /** @return whether we have a next smallest number */ bool hasNext() &#123; return !stc.empty(); &#125; /** @return the next smallest number */ int next() &#123; auto ret = stc.top()-&gt;val; auto ptr = stc.top()-&gt;right; stc.pop(); for ( ; ptr != nullptr; ptr = ptr-&gt;left) &#123; stc.push(ptr); &#125; return ret; &#125;private: stack&lt;TreeNode*&gt; stc;&#125;; Java123456789101112131415161718192021222324252627282930313233343536/** * Definition for binary tree * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class BSTIterator &#123; public BSTIterator(TreeNode root) &#123; for ( ; root != null; root = root.left) &#123; stc.push(root); &#125; &#125; /** @return whether we have a next smallest number */ public boolean hasNext() &#123; return !stc.empty(); &#125; /** @return the next smallest number */ public int next() &#123; int ret = stc.peek().val; TreeNode cursor = stc.peek().right; stc.pop(); for ( ; cursor != null; cursor = cursor.left) &#123; stc.push(cursor); &#125; return ret; &#125; private Stack&lt;TreeNode&gt; stc = new Stack&lt;&gt;();&#125; 236. Lowest Common Ancestor of a Binary TreeTags: Tree C++123456789101112131415161718192021class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if (root == nullptr || root == p || root == q) &#123; return root; &#125; // find lca node or at least one of (p, q) in left and right subtree auto left = lowestCommonAncestor(root-&gt;left, p, q); auto right = lowestCommonAncestor(root-&gt;right, p, q); // if both left and right are not null (p, q) must exist in left and right that root // is the lca; if left or right is null, lca is in another subtree (right or left). if (left == nullptr) &#123; return right; &#125; else if (right == nullptr) &#123; return left; &#125; else &#123; return root; &#125; &#125;&#125;; Java1234567891011121314151617181920class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if (root == null || root == p || root == q) &#123; return root; &#125; // find lca node or at least one of (p, q) in left and right subtree TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); // if both left and right are not null (p, q) must exist in left and right that root // is the lca; if left or right is null, lca is in another subtree (right or left). if (left == null) &#123; return right; &#125; else if (right == null) &#123; return left; &#125; else &#123; return root; &#125; &#125;&#125; 264. Ugly Number II Write a program to find the n-th ugly number.Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.Note that 1 is typically treated as an ugly number, and n does not exceed 1690. Tags: Array, Dynamic Programming C++123456789101112131415161718192021class Solution &#123;public: int nthUglyNumber(int n) &#123; std::array&lt;int, 3&gt; base&#123;2, 3, 5&#125;; std::array&lt;size_t, 3&gt; index&#123;1, 1, 1&#125;; std::vector&lt;int&gt; ret(n + 1, 1); for (size_t i = 2; i &lt;= n; ++i) &#123; auto cur_min = std::numeric_limits&lt;int&gt;::max(); for (size_t j = 0; j &lt; base.size(); ++j) &#123; cur_min = std::min(cur_min, base.at(j) * ret.at(index.at(j))); &#125; for (size_t j = 0; j &lt; base.size(); ++j) &#123; if (cur_min == base.at(j) * ret.at(index.at(j))) &#123; ++index[j]; &#125; &#125; ret[i] = cur_min; &#125; return ret.at(n); &#125;&#125;; Java1234567891011121314151617181920212223class Solution &#123; public int nthUglyNumber(int n) &#123; List&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); for (int i = 0; i &lt;= n; ++i) &#123; ret.add(1); &#125; int base[] = &#123;2, 3, 5&#125;; int index[] = &#123;1, 1, 1&#125;; for (int i = 2; i &lt;= n; ++i) &#123; int cur_min = Integer.MAX_VALUE; for (int j = 0; j &lt; 3; ++j) &#123; cur_min = Math.min(cur_min, base[j] * ret.get(index[j])); &#125; for (int j = 0; j &lt; 3; ++j) &#123; if (cur_min == base[j] * ret.get(index[j])) &#123; ++index[j]; &#125; &#125; ret.set(i, cur_min); &#125; return ret.get(n); &#125;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F11%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy Generate and Deploy1$ hexo g -d More info: Deployment Test Insert Image:]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
