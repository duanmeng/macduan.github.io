<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[GFS总结]]></title>
    <url>%2F2017%2F12%2F07%2Fgfs-notes%2F</url>
    <content type="text"><![CDATA[本文是阅读完google经典的论文The Google File System后的总结。 场景]]></content>
      <tags>
        <tag>distributed</tag>
        <tag>google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式原理与工程 —— Quorum机制]]></title>
    <url>%2F2017%2F12%2F03%2FQuorum%2F</url>
    <content type="text"><![CDATA[Quorum机制，是一种分布式系统中常用的，用来保证数据冗余和最终一致性的投票算法， 其主要数学思想来源于鸽巢原理1。 Quorum机制定义我们普遍使用副本(Replication)技术来保证一致的性能和高可用性2，Quorum是一种简单有效的管理副本的机制，我们先建立如下定以（[2]中也有描述）： N = 存储数据副本的节点的数量W = 更新成功所需的副本更新成功的数量R = 一次数据对象读取要访问的副本的数量 更新时，只有至少W副本更新成功时才算更新操作成功；读取时，至少要读取R个副本的数据。这样当$W + R &gt; N$时，对于同一个数据对象，更新集合与读取集合一定有重叠，保证了读取的数据中一定有最近更新的值。 WARO (Write All Read One)WARO是Quorum机制的特例（GFS使用WARO），也就是更新时必须所有的副本都更新成功，而读取时只需要读取一个副本的数据就可以。 参考链接 https://zh.wikipedia.org/wiki/Quorum_(分布式系统) https://duanmeng.github.io/2017/11/19/Eventually-Consistent%20-%20Revisited/ 未完待续]]></content>
      <tags>
        <tag>distributed</tag>
        <tag>system design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[deeplearning.ai系列学习笔记]]></title>
    <url>%2F2017%2F11%2F26%2Fcoursera-ng-deeplearning-notes%2F</url>
    <content type="text"><![CDATA[吴恩达(Andrew Ng)离开老东家之后创立了一个创业公司叫deeplearing.ai，并且在Coursera（Ng也是cofounder）上开设一个5门课程组成deeplearning系列，我学习了前两门（完成了作业和实验拿到了证书，算是上班远坐地铁时间长的福利吧），难能可贵的是Ng考虑到国内的情况在网易云课堂上免费提供了该系列课程的学习视频和资料，所以我可以在笔记中引用课程资料，但是不会上传作业答案与实验代码。 1. Neural Networks and Deep Learning1.1 week01什么是神经网络以房价预测为例（Ng很喜欢这个例子）给出了一个非常简单的Neural Network，如下图所示，有输入层，隐藏层和输出层（输入层不算做NN的层数之中），输入层是简单的特征，隐藏层则是输入层简单特征组合成的更复杂的特征，那些圆圈是“激励”（activator）一般是ReLU）和Sigmoid这一类函数。 深度学习为什么兴起大数据驱动了深度学习的兴起（当然少不了Hinton大神的卓越贡献)，如下图可以看到随着数据量的增大，深度学习/神经网络与传统机器学习的效果差距越来越大。之前团队培训时一个策略高工说过业务 &gt; 数据 &gt; 模型，离开具体业务场景和数据支撑空谈模型是没有意义的。 该课程的术语与表示因为本系列课程都是用Python，为了优化会矩阵化，矩阵形状对比是一个很实用且重要的调试手段之一，比如输入X的形状是(nx, m)，m是训练用例的数量，nx则是输入特征的数量。 1.2 week02Logistic Regression （逻辑回归）LR虽然叫逻辑回归，但它实际是解决分类问题；它是一个线性回归在一个激励（ReLU, Sigmoid等）上的输出，本周以Sigmoid为例，其实就是神经网络图中的一个圆圈，用数学公式描述如下， Model: $a = \sigma(W^TX + b)$ where $\sigma(Z) = \frac{1}{1 + e^{-z}}$Train: $\lbrace(x^{(1), y^{(1)}}), … (x^{(i), y^{(i)}}) … , (x^{(m), y^{(m)}})\rbrace$ where $a^{(i)} \approx y^{(i)}$ Logistic Regression Cost Function度量Cost时很常见的一种方法就是square error（$\frac{(a - y)^2}{2}$），但是如果采用它会使得LR的cost function非凸，无法找到全局最优解（估计是sigmoid的特性造成的，数学原理我就不去深究了）；所以采用cross-entropy: $L(a, y) = -(ylog(a) + (1 - y)log(1 - a))$对此一个Ng给出了个感性的解释：由于$0 &lt; a, y &lt; 1$，当$y = 1$时$L(a, y) = -log(a)$，那么a无限接近1时L(a, y)最小；当$y = 0$时$L(a, y) = -log(1 - a)$，那么a无限接近0时$L(a, y)$最小。选择cross-entropy后cost function如下：$J(W, b) = \frac{1}{m}\sum^{m}_{i = 1}{L(a, y)^2}$ Gradient Descent （梯度下降）梯度下降是通过反复迭代找到使J最小的parameters（W和b），其中迭代次数和learning rate（$\alpha$）属于hyper parameters（后面会讲到）， $W := W - \alpha\frac{\nabla{J}}{\nabla{W}}$$d := d - \alpha\frac{\nabla{J}}{\nabla{b}}$ forward propagation与post propagation从梯度下降的公式可以看出迭代过程中需要知道$\frac{\nabla{J}}{\nabla{W}}$，这就是通过fp与pp推到出来的，以下面的LR过程为例： forward propagation:$[x_1, w_1, x_2, w_2, b]$ -&gt; $[z = w_1x_1 + w_2x_2 + b]$ -&gt; $[a = sigmoid(z)]$ -&gt; $[L(a, y)]$ 以推导dw1为例演示post propagation, 其中d(xx)代表$\frac{\nabla{J}}{\nabla{(xx)}}$: $[a = sigmoid(z)]$ &lt;- $[L(a, y)]$ =&gt; $da = \frac{\nabla{L}}{\nabla{a}} = -\frac{y}{a} + \frac{1 - y}{1 - a}$ $[z = w_1x_1 + w_2x_2 + b]$ &lt;- $[a = sigmoid(z)]$ =&gt; $dz = \frac{\nabla{L(a, y)}}{\nabla{z}} = \frac{\nabla{L}}{\nabla{a}}\frac{\nabla{a}}{\nabla{z}} = da\frac{\nabla{a}}{\nabla{z}} = a - y$ $[x_1, w_1, x_2, w_2, b]$ &lt;- $[z = w_1x_1 + w_2x_2 + b]$ =&gt; $dw_{1} = \frac{\nabla{L}}{\nabla{w_1}} = \frac{\nabla{L}}{\nabla{z}}\frac{\nabla{z}}{\nabla{w_1}} = x_1dz$ 这样$dw_1$就推导出来了，同理$dw_2 = x_2dz$，$db = dz$。 汇总用上面几节的结论以及python的向量化（主要是解决m个训练样本时避免for循环）汇总一个训练W，b的伪代码， 12345678for i in xrange(iterNum): Z = W.T * X + b A = sigmoid(Z) dZ = A - y dw = 1 / m * X * dZ.T db = 1 / m * sum(dZ) W = W - alpha * dW b = b - alpha * db]]></content>
      <tags>
        <tag>coursera</tag>
        <tag>deep learning</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++11 Memory Model]]></title>
    <url>%2F2017%2F11%2F24%2FC-11-Memory-Model%2F</url>
    <content type="text"><![CDATA[Herb Sutter在一次对C++11内存模型的演讲中提到C++11的内存模型让C++有了标准独立于编译器和平台线程库和标准的多线程内存控制方式。 咋一看这个句话很奇怪，难道C++98/03及以前的内存模型不支持多线程吗， 用C++03的标准不照样写多线程程序。 其实我忽略了一个事实在B家同学们都是gcc &amp; linux，潜意识posix标准的pthread就是C++的线程库存，其实还有cl &amp; windows:) C++标准是基于一个抽象的机器制定的（大部分语言标准应该也是这样），它没有具体的CPU或编译器。 C++98/03标准没有对每次读写（loads and stores)以及执行顺序作出规定，所以无法写出完全可移植的多线程代码（能同时支持freebsd，linux和windows就很不错了）。C++11标准则在设计上引入了支持多线程的内存模型，它规定了在多线程环境中内存的读写的操作以及可能的执行顺序1。 在cppreference.com上可以看到load和store的原型如下, 12T load( std::memory_order order = std::memory_order_seq_cst ) const noexcept;void store( T desired, std::memory_order order = std::memory_order_seq_cst ) noexcept; 对于memory order多线程环境中（CPU也是乱序执行的）的几种规定如下下表， Value Explanation memory_order_relaxed 对其它读写操作没有同步，只保证本操作是原子的 memory_order_consume load操作，当前线程依赖该原子变量的访存操作不能reorder到该指令之前，对其他线程store操作(release)可见 memory_order_acquire load操作，当前线程所有访存操作不能reorder到该指令之前，对其他线程store操作(release)可见 memory_order_release store操作，当前线程所有访存操作不能reorder到该指令之后，对其他线程load操作(consume)可见 memory_order_acq_rel load/store操作，memory_order_acquire + memory_order_release memory_order_seq_cst memory_order_acq_rel + 顺序一致性(sequential consisten) 关于memory_order_seq_cst与memory_order_acq_rel，下面这段代码很直观的体现了， 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;thread&gt;#include &lt;atomic&gt;#include &lt;cassert&gt; std::atomic&lt;bool&gt; x = &#123;false&#125;;std::atomic&lt;bool&gt; y = &#123;false&#125;;std::atomic&lt;int&gt; z = &#123;0&#125;; void write_x()&#123; x.store(true, std::memory_order_seq_cst);&#125; void write_y()&#123; y.store(true, std::memory_order_seq_cst);&#125; void read_x_then_y()&#123; while (!x.load(std::memory_order_seq_cst)) ; if (y.load(std::memory_order_seq_cst)) &#123; ++z; &#125;&#125; void read_y_then_x()&#123; while (!y.load(std::memory_order_seq_cst)) ; if (x.load(std::memory_order_seq_cst)) &#123; ++z; &#125;&#125; int main()&#123; std::thread a(write_x); std::thread b(write_y); std::thread c(read_x_then_y); std::thread d(read_y_then_x); a.join(); b.join(); c.join(); d.join(); assert(z.load() != 0); // will never happen&#125; 知乎上有个G家的stephen w很认真的翻阅了经典计算机体系结构：量化研究方法给了不错的总结2, “SC要求所有内存操作表现为(appear)逐个执行（任一次的执行结果都像是所有处理器的操作都以某种次序执行），每个处理器中的操作都以其程序指定的次序执行。SC有两点要求：在每个处理器内，维护每个处理器的程序次序；在所有处理器间，维护单一的表征所有操作的次序。对于写操作W1, W2, 不能出现从处理器 P1 看来，执行次序为 W1-&gt;W2; 从处理器 P2 看来，执行次序却为 W2-&gt;W1 这种情况。 参考链接 https://stackoverflow.com/questions/6319146/c11-introduced-a-standardized-memory-model-what-does-it-mean-and-how-is-it-g https://www.zhihu.com/question/24301047/answer/83422523]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译]最终一致性 - 修订版(Eventually Consistent - Revisited)]]></title>
    <url>%2F2017%2F11%2F19%2FEventually-Consistent%20-%20Revisited%2F</url>
    <content type="text"><![CDATA[译者注：这是AWS CTO Werner Vogels写的一致性模型的经典文章 在其博客All Things Distributed上亦有发布。 大约一年前，我发表了关于一致性模型文章的第一个版本，但是我对它一直不是很满意，因为它写的很匆忙，而且这个太重要值得更充分的研究。 ACM Queue让我修订一下发表在他们的杂志上，我利用这个机会改进了这篇文章。这篇是那篇的修订版。 最终一致性 - 在全球范围构建可靠的分布式系统需要在一致性和支撑Amazon云计算的基础服务，例如Amazon的S3(Simple Storage Service)，SimpleDB和EC2(Elastic Compute Cloud)提供构建互联网规模计算平台和各种应用所需的资源。放在这些基础服务的需求非常严格；它们需要在安全性、 可伸缩性、 可用性、 性能和成本效率方面都非常优秀，同时为全球数以百万计的客户持续提供服务。 这些服务底层是全球范围运行的大规模分布式系统。这样的规模带来了额外的挑战，因为当一个系统处理海量请求时，那些低概率事件就会变成必然事件，并且需要在系统设计和架构中预先列出。考虑到这些全球范围的系统，我们普遍使用副本(Replication)技术来保证一致的性能和高可用性。 虽然副本技术让我们更接近目标，但是它不能以完全透明的方式实现它们；在一些条件下，这些服务的用户将会面临使用副本技术带来的后果。 这些方面的表现方式之一就是提供的数据一致性类型，特别当底层的分布式系统为数据副本提供一种最终一致性模型。当在Amazon设计这些大规模系统时，我们用一组与大规模数据副本(data replication)相关的指导原则和抽象，并集中在高可用性与数据一致性的权衡上。 这篇文章我介绍了一些相关背景展示了我们交付需要在全球范围运行的可靠的分布式系统的方法。这篇文章的早期版本于2017年12月发表在网络博客All Things Distributed，并且在读者的帮助下改进了很多。 历史观点在理想世界中，只会有一种一致性模型：当更新完成，所有的观察者都会看到。 70年代末期，在数据系统中第一次发现这个模型难以实现。关于这个主题最好的历史文献是Bruce Lindsay等人的分布式数据库注释 5。 它阐述了数据库副本的基本原则，并讨论了一些找实现一致性的技术。 这些技术中许多试图实现分布式透明，就是对用户来说它似乎只在使用一个系统而不是多个协作系统。这段时期许多系统采用这种方法，即使让整个系统失效也不破坏透明性 2。 在90年代中期，随着大型互联网的兴起，这些方法被重新审视。 当时人们开始意识到对于这些系统而言可用性是最重要的属性，但是他们也在纠结牺牲什么来保证可用性。 Eric Brewer，加州伯克利的系统学教授，Inktomi的头，在2001年的PODC(Principles of Distributed Computing)会议的主题演讲上提出了一并提出了不同的取舍方案 1。 他演示CAP理论，指出共享数据系统的三大属性即数据一致性，系统可用性和网络分区容忍性，在任何时刻只能同时保证两个。 Seth Gilbert和Nancy Lynch在他们2002年的一篇论文 4中给出了正式确认。 不能容忍网络分区的系统可以同时实现数据一致性和可用性，这个通常是通过事务协议来实现。 为了实现这样的系统，客户端和存储系统必须在相同环境中； 他们在某些场景下会整体失效，只有这样客户端才无法感知分区。 一个重要发现是在大型分布式系统中，网络分区无法避免，因此，一致性和可用性无法同时实现。 这意味着有两个放弃的选项： 放宽一致性保证系统的可用性，或者保证一致性接受某些场景下系统不可用。 两个选项都需要客户端开发者清楚系统可以提供什么。 如果强调一致性，开发者需要面对系统可能不可用的现实，例如，一次写操作。 如果这次写操作因为系统不可用，客户端开发者需要处理数据无法写入。 如果系统强调可用性，它可能会一直接受写操作，但是一些条件下读操作无法返回最新写入的数据。 开发者需要决定客户端是否始终访问最新的更新。 有一批应用可以处理稍微陈旧的数据，它们在这个模型下可以很好的提供服务。 原则上事务系统的ACID（原子性，一致性，隔离线，持久性）中的一致性属性是一种不同的一致性保证。 在ACID中，一致性是指事务完成后数据库是处于一种一致状态；例如，一个账户转钱给另一个账户，两个账户总额不应该改变。 在ACID-based系统中，这样的一致性通常是编写事务的开发者的责任，但是可以由数据库管理完整性约束来辅助。 一致性 —— 客户端与服务端有两种视角看待一致性。 一种是开发者/客户端的视角：他们如何观察数据更新。 另一种是服务端视角：更新如何在系统中流通，以及系统能给这些更新的保证。 客户端一致性 客户端有以下部分： 一种存储系统。 我们先把它当作一个黑盒，但是要了解它底层是大规模分布式系统，为保证持久性和可用性而构建。 进程A。 这个进程读写存储系统。 进程B和进程C。 这两个进程独立于进程A且读写存储系统。这与他们是否真是进程或者同一进程中的线程无关；真正重要的是他们相互独立且需要通信共享信息。 客户端一致性需要处理如何和何时观察者们（这个例子中进程A，B或者C）看到数据对象在存储系统中更新。 接下来的例子演示了不同的类型的一致性，流程A对数据对象进行了更新： 强一致性。 更新完成后，任何后续访问（来自A，B或C）将会返回更新的值。 弱一致性。 系统不保证后续访问会得到更新的值。 获取更新值之前需要满足一些条件。 从更新到保证任何观察者将会一直看到更新值的时期被称为不一致窗口。 最终一致性。 这是弱一致性的一种特例； 存储系统保证如果对象没有新的更新，最终所以的访问将会返回最近更新的值。 如果没有失败发生，不一致窗口的大小由通信延迟，系统负载和复制方案的副本数量决定。 最广泛的最终一致性系统是DNS(Nomain Name System)。 一个域名的更新根据配置模式以及时间控制缓存被分布；最终，所以客户端将会看到更新。 最终一致性模型有一些重要的变种需要被考虑到： 因果一致性。 如果进程A通知进程B它更新了一项数据，后续进程B的访存会返回更新的值，并且保证写入将取代之前的写入。与过程A没有因果关系的进程C的访存是遵循一般的最终一致性规则。 读你所写一致性。 这是一种重要的模型，进程A更新一个数据项之后总会得到更新的值永远不会得到旧值。这是因果一致性的一种特例。 会话一致性。 这是上个模型的实践版本，其中是一个进程在一个会话上下文中访问存储系统。 只要这个会话存在，系统保证读你所写一致性。 如果会话因为一些特定场景失效，一个新的会话需要被创建且一致性保证不会跨会话。 单调读一致性。 如果一个进程读取到了一个对象的值，任何后续访问都不会得到之前的值。 单调写一致性。 在这种情况下，系统保证由相同的进程序列化写操作。系统不保证这样的一致性非常难以编程。 以上一致性特性中的一部分可以被组合。例如，单调读一致性可以和会话一致性组合。从实践角度来看，这两个特性（单调读和读你所写）是最终一致性系统中最需要的，但不是一直必须的。这两个特性让开发者更容易构建应用，同时允许存储系统放松一致性且提供高可用性。 从这些变化中可以看出，很多场景是可能的。相应的后果能否被接受取决于特定的应用程序。 最终一致性不是什么极限分布式系统的深奥特性。许多现代关系型数据库管理系统（RDBMSs），提供主备（primary-backup）可靠性，在同步和异步模式实现副本技术。在同步模式副本更新是事务的一部分。在异步模式会延迟到达副本，通常通过日志传输的方式。在异步模式如果主服务在log送达之前宕机，从切换的备份服务读取的将会是旧的，不一致的值。同时，为了支持更好大规模读性能，RDBMSs已经提供从备份服务读取的功能，这是一个经典的保证最终一致性的案例，其不一致性窗口取决于日志传送的周期。 服务端一致性在服务端我们需要更深入地理解更新在系统中执行的流程，从而理解是什么让开发者遇到不同模式。开始前，让我们先建立一些定义： N = 存储数据副本的节点的数量W = 更新成功所需的副本更新成功的数量 （译者注：如果副本更新没有达到这个数量就是更新失败）R = 一次数据对象读取要访问的副本的数量 如果$W + R &gt; N$，那么写集和读集会一直重叠，这样可以保证强一致性。在使用同步副本的主备RDBMSs场景中，$N = 2, W = 2, R = 1$。客户端无论从哪个副本读都会得到一致的结果。在异步模式且可从备份读取的场景中，$N = 2, W = 1, R = 1$，一致性不能被保证。 这些配置方案就是基本的仲裁协议（quorum protocols），当系统以为故障无法写入W个节点时，写操作失败，意味着系统的不可用。例如$N = 3, W = 3$且只有2个节点可用，系统的写操作失败。 在需要提供高性能和高可用性的分布式存储系统中，副本数量基本上要大于2。只关注容错的系统通常用$N = 3$且$W =2, R = 2$的配置。需要提供非常高的读负载的系统通常会使用超过关注容错系统的副本数量；N可以是几十甚至几百，R配置成1，这样读一次副本就可以返回结果。关注一致性的系统通常为更新设置W = N，这样就降低了写成功的可能性。关注容错而不是一致性的系统通常配置是$W = 1$，获取最小更新持久性（译者注：这是什么鬼）并通过惰性（lazy/epidemic，译者注：跟GFS的primary-secondary更新很像）更新机制去更新其他副本。 如何更新$N, W, R$，依赖于常见的操作是什么和哪个性能指标需要被优化。当$R = 1, N = W$时我们优化读操作，当$W = 1, R = N$我们优化快速写操作。当然对于后者持久性在发生异常时不被保证，如果$W &lt; (N + 1) / 2$，冲突写（译者注：比如，不同客户端发起的写操作）的集合可能不会重叠。 弱或最终一致性产生于$W + R &lt;= N$，意味着存在读写集没有重叠的可能性。如果不是刻意的配置或者基于容错用例，几乎没有任何理由设置R为1而不是其它值。这发生在两种场景中：第一个为了前面提到的读操作扩展的大规模副本；第二个是数据获取更复杂。在简单键值模型非常容易通过版本对比来决定最新写入系统的值，但是在返回对象集的系统中非常难决定最新正确的集合应该是哪个。在大多数写集合小于副本集合的系统中，有一种机制就是，用惰性更新的方式更新副本中剩余未更新的节点。所有副本更新之前的时间段被称为前面提到的不一致性窗口。如果$W + R &lt;= N$，那么系统容易从尚未更新的节点读取数据。 读你所写一致性，会话一致性和单调一致性能否实现，大体上依赖于客户端与对它们执行分布式协议服务端的“粘性”。如果每次都是相同的服务器，那么比较容易保证读你所写和单调一致性读。这样会让负载均衡和容错稍微难以管理，但是是一个简单解决方案。用粘性的会话，让这个显示和提供了一个客户端可以推断的暴露级别。（译者注：什么鬼） 有时候在客户端实现了读你所写和单调读。通过为写添加版本，客户端丢弃读取的版本号比上次所见低的数据。 当系统中一些节点与其它节点断开时分区发生了，但是这两批节点可以被一组客户端访问。如果使用经典的多数仲裁方法，那么当其它副本无法访问时，拥有W个节点的副本集依旧可以继续接受更新。读集合亦是如此。考虑到两个集合的重叠，根据定义，少数集合变得不可用。分区不会经常发生，但是他们的确发生在数据中心之间，以及数据中心内部。 在一些应用中任何分区的不可达都是不可接受的，重要的是能够访问该分区的客户端可以取得进展。在这种场景下两个分区都分配一组新的存储节点接收数据，并且在分区恢复后执行合并操作。例如，在亚马逊购物车就是使用这样的永远可写系统；这样即使发生分区，客户可以继续添加商品到购物车，即使原来的购物车位于其它分区。一旦分区恢复购物车应用（译者注：客户端？）会帮助购物车数据合并。 亚马逊的Dynamo亚马逊的Dynamo就是这样一个把所有这些特性显示控制的应用架构的系统，它是一个键值存储系统，跟AWS（Amazon’s Web Service）一样，它在内部被广泛用于构建亚马逊电子商务平台的服务。一个重要的设计目标就是让创建Dynamo存储系统（它通常分布在多个数据中心）实例的应用服务的拥有者能在一致性，持久性，可用性和性能之间在一定代价上作出权衡。3 总结在大规模可靠的分布式系统中，必须容忍数据不一致的原因有两个：在高并发条件下改善读写性能；处理分区场景中大部分模型让系统不可用，即使节点都在运行。 能否接受非一致性取决于客户端应用。在所有场景中，开发者需要意识到一致性保证由存储系统提供，需要在开发应用时考虑到。有许多对最终一致性模型实际的改进，比如会话一致性和单调读，它们提供了更好的工具给开发者。很多时候应用可以很好的处理存储系统的最终一致性。一个流行的用例就是网站，我们可以有用户感知一致性的概念。在这个场景下，不一致性窗口需要小于返回客户加载的下一页所需的时间。这个允许在下次读之前更新可以传播到整个系统。 这篇文章的目的就是引起运行在全球范围的工程系统复杂性的认识，这个系统需要仔细调优来保证它们可以交付应用所需要的持久性，可用性和性能。系统设计者拥有的一个工具之一就是一致性窗口的长度，在这个时间段内系统的客户端可能暴露在大规模工程系统的现实中。 参考文献 Brewer, E. A. 2000. Towards robust distributed systems (abstract). In Proceedings of the 19th Annual ACM Symposium on Principles of Distributed Computing (July 16-19, Portland, Oregon): 7 A Conversation with Bruce Lindsay. 2004. ACM Queue 2(8): 22-33. DeCandia, G., Hastorun, D., Jampani, M., Kakulapati, G., Lakshman, A., Pilchin, A., Sivasubramanian, S., Vosshall, P., Vogels, W. 2007. Dynamo: Amazon’s highly available key-value store. In Proceedings of the 21st ACM Symposium on Operating Systems Principles (Stevenson, Washington, October). Gilbert , S., Lynch, N. 2002. Brewer’s conjecture and the feasibility of consistent, available, partition-tolerant Web services. ACM SIGACT News 33(2). Lindsay, B. G., Selinger, P. G., et al. 1980. Notes on distributed databases. In Distributed Data Bases, ed. I. W. Draffan and F. Poole, 247-284. Cambridge: Cambridge University Press. Also available as IBM Research Report RJ2517, San Jose, California (July 1979).]]></content>
      <tags>
        <tag>distributed</tag>
        <tag>system design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Learning Design and Coding From LevelDB]]></title>
    <url>%2F2017%2F11%2F05%2FLearning-Design-and-Coding-From-LevelDB%2F</url>
    <content type="text"><![CDATA[LevelDB is a fast key-value storage library written at Google by Jeff Dean that provides an ordered mapping from string keys to string values. We could learn design and coding from the source code. 概述include/leveldb &amp; utilStatus include/leveldb/status.h util/status.cc Status是对每次操作结果的封装, 它只有一个成员变量char* state_来表示状态信息，它包含三个字段[length, code, message], length表示message的长度，code是返回码，message是状态信息：123456789101112131415161718192021222324252627// OK status has a NULL state_. Otherwise, state_ is a new[] array// of the following form:// state_[0..3] == length of message// state_[4] == code// state_[5..] == messageconst char* state_;enum Code &#123; kOk = 0, kNotFound = 1, kCorruption = 2, kNotSupported = 3, kInvalidArgument = 4, kIOError = 5&#125;;Code code() const &#123; return (state_ == NULL) ? kOk : static_cast&lt;Code&gt;(state_[4]);&#125;const char* Status::CopyState(const char* state) &#123; uint32_t size; memcpy(&amp;size, state, sizeof(size)); char* result = new char[size + 5]; memcpy(result, state, size + 5); return result;&#125; 这个类对字符串的操作非常精妙，比如上述代码通过memcpy获取message长度信息. Slice include/leveldb/slice.h 封装数据和其长度，便于直接通过指针操作, 并提供向std::String的转换.1234567class Slice &#123;...private: const char* data_; size_t size_; ...&#125; Cache include/leveldb/cache.h utils/cache.cc overviewCache一个接口类，提供了有淘汰机制KV的接口，客户代码可以自己定义具体的实现，也可以使用默认的LRUCache,从下面代码中的注释中可以看出设计思路。12345678910111213141516171819202122232425// A Cache is an interface that maps keys to values. It has internal// synchronization and may be safely accessed concurrently from// multiple threads. It may automatically evict entries to make room// for new entries. Values have a specified charge against the cache// capacity. For example, a cache where the values are variable// length strings, may use the length of the string as the charge for// the string.//// A builtin cache implementation with a least-recently-used eviction// policy is provided. Clients may use their own implementations if// they want something more sophisticated (like scan-resistance, a// custom eviction policy, variable cache sizing, etc.)// Create a new cache with a fixed size capacity. This implementation// of Cache uses a least-recently-used eviction policy.extern Cache* NewLRUCache(size_t capacity);class Cache &#123; public: // Opaque handle to an entry stored in the cache. struct Handle &#123; &#125;; virtual Handle* Insert(const Slice&amp; key, void* value, size_t charge, void (*deleter)(const Slice&amp; key, void* value)) = 0; virtual Handle* Lookup(const Slice&amp; key) = 0; ... ... 虽然其接口参数有明确，但是数据类型并没有明确而是留给具体实现代码，所以返回类型是12Handle*struct Handle &#123;&#125;; 这就是一个典型的Opaque data type的应用，wikipedia: opaque pointer, wikipedia: opaque data type, stackoverflow: What is an opaque value? 你会发现在cache.h中有一段extern声明,1extern Cache* NewLRUCache(size_t capacity); 在cache.cc中有它的一种实现,123Cache* NewLRUCache(size_t capacity) &#123; return new ShardedLRUCache(capacity);&#125; 通过extern声明(#include “cache.h”), 在链接的时候(链接cache.o)既可以选择cache.cc的默认实现即ShardedLRUCache, 也可以链接自己的实现。 ShardedLRUCachecache.cc中提供了一个默认的cache实现即ShardedLRUCache, 其组成是LRUCache并基于key进行shard.LRUCache依赖cache.c中的opaque数据抽象的具体实现LRUHandle和自己实现的一个哈希表HashHandle.总而言之ShardedLRUCache就是二级hashtable, 其节点就是多个LRUCache. ShardedLRUCache在bucket分配与key的shard时用一些非常有意思的位操作，代码如下12345678static const int kNumShardBits = 4;static const int kNumShards = 1 &lt;&lt; kNumShardBits;LRUCache shard_[kNumShards];static uint32_t Shard(uint32_t hash) &#123; return hash &gt;&gt; (32 - kNumShardBits);&#125; kNumShards = 2 ^ kNumShardBits 这个左移代替指数计算好理解，但是shard操作hash &gt;&gt; (32 - kNumShardBits)这个值得思考，一般会直接余除，但是这样效果会一样吗或者说会均匀分布在kNumShards个bucket中吗？假设我们考虑4个bit的uint4_t（虽然并没有这样的类型），当kNumShardBits = 1时，bucket数量也就是kNumShards为2,那么 4 - kNumShardBits = 3，每次Shard的时候右移动3个bit，这时会发现只有bit 3的那个bit右移没有消失（在bit 0），也就是说bit 3的那个bit决定了Shard的value(0 / 1)，正好均匀分布在2个bucket上了.同理对于32bit的uint32_t整型数，其bit分布如下 31 … (32 - kNumShardBits), (32 - kNumShardBits - 1) … 0 如果右移32 - kNumShardBits，只有第一部分kNumShardBits个高位的bit有效，那么正好有2 ^ kNumShardBits 种可能的值，均匀分布在index为0 - (2 ^ kNumShardBits - 1)的bucket上.一个简单的Shard对效率都这么苛刻(位操作避免除法)，由此可见作者对性能的要求. LRUCache &amp; LRUHandle &amp; HandleTableLRUCache由两个循环链表和一个HashTable组成（List+Hash的经典实现），一个链表是连接正在被使用的Node，一个链表连接不再被使用的Node，HashTable就是使用链表解决Hash碰撞，所以每个Node（即LURHandle包含三个pointer和一个ref），作者使用了经典的链表操作dummy node和二级指针Linus。Hash值的生成实现请见Hash &amp; Coding哪一章。 Hash &amp; Codingutil/hash.cc util/hash.hutil/coding.cc util/coding.hhash.cc提供了一个默认的类似murmurhash的hash值计算的实现，coding.cc中提供了32/64整型数和Slice/String的转换. env &amp; env_posixutil/env.cc include/leveldb/env.hutil/env_posix.cc envenv中的接口类Env（虚基类）提供了文件操作的抽象，比如目录操作，日志，文件顺序/随机读取，在Option中可以配置Env使用的实现, leveldb提供了默认的posix标准的实现（具体见下一节）.SequentialFile/RandomAccessFile封装了文件顺序/随机Read和Skip，WritableFile封装了文件的Append/Close/Flush/Sync操作，Loger则封装了类似变长参数的logv接口（类似vprintf）. env_posixenv_posix是leveldb对Env接口类提供的默认implementation.Limiter类通过基于RAII的Scope互斥锁和原子操作提供线程安全的计数操作，避免资源过度消耗，比如fd, mmap file数量.PosixSequentialFile是SequentialFile的子类实现了其Read和Seek接口, 本质就是对fread和seek的wrapper.PosixRandomAccessFile是RandomAccessFile的子类, 实际是pread() based random-access, 同时包含了Limiter, 不知道为什么Random Accesss为什么需要Limiter.PosixMmapReadableFile是MmapReadableFile的子类, 实际是mmap() based random-access.]]></content>
      <tags>
        <tag>C++</tag>
        <tag>leveldb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode using C++ and Java (keep updating ...)]]></title>
    <url>%2F2017%2F11%2F04%2FLeetCode%20with%20C%2B%2B%20and%20Java%20and%20little%20scala%2F</url>
    <content type="text"><![CDATA[LeetCode的题目非常是碎片化时间来做，而且可以尝试最新的C++标准和多种语言， 正好要学习Java，就C++和Java两种语言来做题，如果碰到可以用immutable方式的题目就再用Scala做一下。 1. Two Sum Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution, and you may not use the same element twice. Example:Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. Tags: Array, HashTable C++123456789101112131415class Solution &#123; // (both index1 and index2) are not zero-based.public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, size_t&gt; umap; for (size_t i = 0; i &lt; nums.size(); ++i) &#123; auto item = nums[i]; if (umap.find(target - item) == umap.end()) &#123; umap[item] = i; &#125; else &#123; return vector&lt;int&gt;&#123;umap[target - item], i&#125;; &#125; &#125; return vector&lt;int&gt;&#123;-1, -1&#125;; &#125;&#125;; Java1234567891011121314public class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; hm = new HashMap&lt;&gt;(); for (int i = 0; i != nums.length; ++i) &#123; int complement = target - nums[i]; if (hm.get(complement) != null) &#123; return new int[] &#123;hm.get(complement), i&#125;; &#125; else &#123; hm.put(nums[i], i); &#125; &#125; return null; &#125;&#125; Scala1234567891011121314object Solution &#123; def twoSum(nums: Array[Int], target: Int): Array[Int] = &#123; var ht = collection.mutable.Map.empty[Int, Int] for (i &lt;- 0 until nums.size) &#123; val tmp = target - nums(i) if (ht.contains(tmp)) &#123; return Array(ht(tmp), i) &#125; else &#123; ht(nums(i)) = i &#125; &#125; Array(-1, -1) &#125;&#125; 2. Add Two Numbers You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself.Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 Tags: Linked List, Math C++12345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode dummy(-1); ListNode* ptr = &amp;dummy; int carry = 0; while (l1 != nullptr || l2 != nullptr) &#123; int a = 0; if (l1 != nullptr) &#123; a = l1-&gt;val; l1 = l1-&gt;next; &#125; int b = 0; if (l2 != nullptr) &#123; b = l2-&gt;val; l2 = l2-&gt;next; &#125; int sum = a + b + carry; carry = sum / 10; ptr-&gt;next = new ListNode(sum % 10); ptr = ptr-&gt;next; &#125; if (carry &gt; 0) &#123; ptr-&gt;next = new ListNode(carry); &#125; return dummy.next; &#125;&#125;; Java123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; int carrier = 0; ListNode dummy = new ListNode(0); ListNode cur = dummy; while (l1 != null || l2 != null) &#123; int x = l1 == null ? 0 : l1.val; int y = l2 == null ? 0 : l2.val; int val = x + y + carrier; carrier = val / 10; cur.next = new ListNode(val % 10); cur = cur.next; if (l1 != null) &#123; l1 = l1.next; &#125; if (l2 != null) &#123; l2 = l2.next; &#125; &#125; if (carrier &gt; 0) &#123; cur.next = new ListNode(carrier); &#125; return dummy.next; &#125;&#125; Scala123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * class ListNode(var _x: Int = 0) &#123; * var next: ListNode = null * var x: Int = _x * &#125; */object Solution &#123; def addTwoNumbers(l1: ListNode, l2: ListNode): ListNode = &#123; var dummyNode = new ListNode(0) var cur = dummyNode var carry = 0 def addInternal(l1: ListNode, l2: ListNode): Unit = &#123; if (l1 != null || l2 != null) &#123; var a = if (l1 != null) l1.x else 0 var b = if (l2 != null) l2.x else 0 var sum = a + b + carry cur.next = new ListNode(sum % 10) cur = cur.next carry = sum / 10 addInternal(if (l1 != null) l1.next else null, if(l2 != null) l2.next else null) &#125; &#125; addInternal(l1, l2) if (carry &gt; 0) &#123; cur.next = new ListNode(carry) &#125; dummyNode.next &#125;&#125; 3. Longest Substring Without Repeating Characters Given a string, find the length of the longest substring without repeating characters. Examples:Given “abcabcbb”, the answer is “abc”, which the length is 3.Given “bbbbb”, the answer is “b”, with the length of 1.Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring. Tags: Hash Table, Two Pointers, String C++123456789101112131415161718class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int ret = 0; vector&lt;int&gt; ht(256, -1); int i = 0; for (int j = 0; j &lt; s.size(); ++j) &#123; auto k = ht[s[j]]; if (k &gt;= i) &#123; i = k + 1; &#125; else &#123; ret = std::max(ret, j - i + 1); &#125; ht[s[j]] = j; &#125; return ret; &#125;&#125;; Java1234567891011121314151617public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int ret = 0; Map&lt;Character, Integer&gt; hm = new HashMap&lt;&gt;(); int i = 0; for (int j = 0; j &lt; s.length(); ++j) &#123; int k = hm.getOrDefault(s.charAt(j), -1); if (k &gt;= i) &#123; i = k + 1; &#125; else &#123; ret = Math.max(ret, j - i + 1); &#125; hm.put(s.charAt(j), j); &#125; return ret; &#125;&#125; 4. Median of Two Sorted Arrays There are two sorted arrays nums1 and nums2 of size m and n respectively.Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). Example 1:nums1 = [1, 3]nums2 = [2]The median is 2.0 Example 2:nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 Tags: Divide and Conquer, Binary Search, Array C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; auto sz = nums1.size() + nums2.size(); if (sz &amp; 0x01) &#123; auto ret = findKthElement(begin(nums1), nums1.size(), begin(nums2), nums2.size(), sz / 2 + 1); //auto ret = findKthElement(nums1.data(), nums1.size(), nums2.data(), nums2.size(), sz / 2 + 1); return static_cast&lt;double&gt;(ret); &#125; else &#123; auto ret1 = findKthElement(begin(nums1), nums1.size(), begin(nums2), nums2.size(), sz / 2); auto ret2 = findKthElement(begin(nums1), nums1.size(), begin(nums2), nums2.size(), sz / 2 + 1); //auto ret1 = findKthElement(nums1.data(), nums1.size(), nums2.data(), nums2.size(), sz / 2); //auto ret2 = findKthElement(nums1.data(), nums1.size(), nums2.data(), nums2.size(), sz / 2 + 1); return (static_cast&lt;double&gt;(ret1) + static_cast&lt;double&gt;(ret2)) / 2.0; &#125; &#125; private: int findKthElement(const int* nums1, size_t len1, const int* nums2, size_t len2, size_t k) &#123; if (len1 &gt; len2) &#123; return findKthElement(nums2, len2, nums1, len1, k); &#125; if (len1 == 0) &#123; return nums2[k - 1]; &#125; if (k == 1) &#123; return min(nums1[k - 1], nums2[k - 1]); &#125; auto dis1 = min(k / 2, len1); auto dis2 = k - dis1; if (nums1[dis1 - 1] &lt; nums2[dis2 - 1]) &#123; return findKthElement(nums1 + dis1, len1 - dis1, nums2, len2, k - dis1); &#125; else if (nums1[dis1 - 1] &gt; nums2[dis2 - 1]) &#123; return findKthElement(nums1, len1, nums2 + dis2, len2 - dis2, k - dis2); &#125; else &#123; return nums1[dis1 - 1]; &#125; return -1; &#125; int findKthElement(vector&lt;int&gt;::const_iterator begin_1, size_t len_1, vector&lt;int&gt;::const_iterator begin_2, size_t len_2, size_t k) &#123; if (len_1 &gt; len_2) &#123; return findKthElement(begin_2, len_2, begin_1, len_1, k); &#125; if (len_1 == 0) &#123; return *(begin_2 + k - 1); &#125; if (k == 1) &#123; return std::min(*begin_1, *begin_2); &#125; auto dis_1 = std::min(k / 2, len_1); auto dis_2 = k - dis_1; if (*(begin_1 + dis_1 - 1) &lt; *(begin_2 + dis_2 - 1)) &#123; return findKthElement(begin_1 + dis_1, len_1 - dis_1, begin_2, len_2, k - dis_1); &#125; else if (*(begin_1 + dis_1 - 1) &gt; *(begin_2 + dis_2 - 1)) &#123; return findKthElement(begin_1, len_1, begin_2 + dis_2, len_2 - dis_2, k - dis_2); &#125; else &#123; return *(begin_1 + dis_1 - 1); &#125; return -1; &#125;&#125;; Java123456789101112131415161718192021222324252627282930313233public class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int len = nums1.length + nums2.length; if ((len &amp; 0x01) == 0x01) &#123; return findKthElement(nums1, 0, nums2, 0, len / 2 + 1); &#125; else &#123; double left = findKthElement(nums1, 0, nums2, 0, len / 2); double right = findKthElement(nums1, 0, nums2, 0, len / 2 + 1); return (left + right) / 2.0; &#125; &#125; private double findKthElement(int[] nums1, int start1, int[] nums2, int start2, int k) &#123; if ((nums1.length - start1) &gt; (nums2.length - start2)) &#123; return findKthElement(nums2, start2, nums1, start1, k); &#125; if ((nums1.length - start1) &lt;= 0) &#123; return (double) nums2[start2 + k - 1]; &#125; if (k == 1) &#123; return Math.min((double) nums1[start1], (double) nums2[start2]); &#125; int dis1 = Math.min(k / 2, nums1.length - start1); int dis2 = k - dis1; if (nums1[start1 + dis1 - 1] &lt; nums2[start2 + dis2 - 1]) &#123; return findKthElement(nums1, start1 + dis1, nums2, start2, k - dis1); &#125; else if (nums1[start1 + dis1 - 1] &gt; nums2[start2 + dis2 - 1]) &#123; return findKthElement(nums1, start1, nums2, start2 + dis2, k - dis2); &#125; else &#123; return (double) nums1[start1 + dis1 - 1]; &#125; &#125;&#125; 5. Longest Palindromic Substring Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example:Input: “babad”Output: “bab”Note: “aba” is also a valid answer. Example:Input: “cbbd”Output: “bb” Tags String 注意C++的substr和Java的substring的区别 C++1234567891011121314151617181920212223242526272829class Solution &#123;public: string longestPalindrome(string s) &#123; int start = 0; int len = 1; for (int i = 0; i &lt; s.length(); ++i) &#123; auto cur = _getLongestPalindromeLength(s, i); if (cur &gt; len) &#123; len = cur; start = i - (len - 1) / 2; &#125; &#125; return s.substr(start, len); &#125; private: inline int _getLongestPalindromeLength(const string &amp;s, int i) &#123; return max(_getLongestPalindromeLength(s, i, i), _getLongestPalindromeLength(s, i, i + 1)); &#125; inline int _getLongestPalindromeLength(const string &amp;s, int left, int right) &#123; while (left &gt;= 0 &amp;&amp; right &lt; static_cast&lt;int&gt;(s.length()) &amp;&amp; s[left] == s[right]) &#123; --left; ++right; &#125; return right - left - 1; &#125; &#125;; Java1234567891011121314151617181920212223242526public class Solution &#123; public String longestPalindrome(String s) &#123; int len = 1; int start = 0; for (int i = 0; i &lt; s.length(); ++i) &#123; int cur = getLongestPalindromeLength(s, i); if (cur &gt; len) &#123; len = cur; start = i - (len - 1) / 2; &#125; &#125; return s.substring(start, start + len); &#125; private int getLongestPalindromeLength(String s, int i) &#123; return Math.max(getLongestPalindromeLength(s, i, i), getLongestPalindromeLength(s, i, i + 1)); &#125; private int getLongestPalindromeLength(String s, int left, int right) &#123; while (left &gt;= 0 &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123; --left; ++right; &#125; return right - left - 1; &#125;&#125; 6. ZigZag Conversion The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)P A H NA P L S I I GY I RAnd then read line by line: “PAHNAPLSIIGYIR”Write the code that will take a string and make this conversion given a number of rows:string convert(string text, int nRows);convert(“PAYPALISHIRING”, 3) should return “PAHNAPLSIIGYIR”. Tags: string C++123456789101112131415161718192021222324class Solution &#123;public: string convert(string s, int numRows) &#123; if (numRows &lt;= 1 || numRows &gt;= static_cast&lt;int&gt;(s.size())) &#123; return s; &#125; vector&lt;string&gt; ret(numRows, ""); int row_cursor = 0; int step = 0; for (size_t idx = 0; idx != s.size(); ++idx) &#123; ret[row_cursor].push_back(s[idx]); if (row_cursor == 0) &#123; step = 1; &#125; else if (row_cursor == numRows - 1) &#123; step = -1; &#125; row_cursor += step; // update row_cursor &#125; string result; result.reserve(numRows); for_each(ret.begin(), ret.end(), [&amp;result](string&amp; item) &#123; result += std::move(item); &#125;); return result; &#125;&#125;; Java1234567891011121314151617181920212223242526public class Solution &#123; public String convert(String s, int numRows) &#123; if (s.isEmpty() || numRows ==1 || numRows &gt;= s.length()) &#123; return s; &#125; ArrayList&lt;StringBuilder&gt; ret = new ArrayList&lt;&gt;(Collections.nCopies(numRows, null)); int idx = 0; int step = 0; for (int i = 0; i &lt; s.length(); ++i) &#123; if (ret.get(idx) == null) &#123; ret.set(idx, new StringBuilder()); &#125; ret.get(idx).append(s.charAt(i)); if (idx == numRows - 1) &#123; step = -1; &#125; else if (idx == 0) &#123; step = 1; &#125; idx += step; &#125; for (int i = 1; i &lt; ret.size(); ++i) &#123; ret.get(0).append(ret.get(i)); &#125; return ret.get(0).toString(); &#125;&#125; 7. Reverse Integer Reverse digits of an integer.Example1: x = 123, return 321Example2: x = -123, return -321 Tags: Math C++1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int reverse(int x) &#123; int ret = 0; for ( ; x != 0; x /= 10) &#123; int tail = x % 10; int tmp = ret * 10 + tail; if ((tmp - tail) / 10 != ret) &#123; // overflow return 0; &#125; ret = tmp; &#125; return ret; &#125;&#125;;class Solution &#123;public: int reverse(int x) &#123; int flag = x &lt; 0 ? -1 : 1; int ret = 0; while (x != 0) &#123; int cur = (x % 10) * flag; if (ret &gt; INT_MAX / 10 || (ret == INT_MAX / 10 &amp;&amp; cur &gt; INT_MAX % 10)) &#123; return 0; &#125; ret = 10 * ret + cur; x /= 10; &#125; return flag * ret; &#125;&#125;; Java123456789101112131415161718192021222324252627282930public class Solution &#123; public int reverse(int x) &#123; int ret = 0; for ( ; x != 0; x /= 10) &#123; int tail = x % 10; int tmp = ret * 10 + tail; if ((tmp - tail) / 10 != ret) &#123; return 0; &#125; ret = tmp; &#125; return ret; &#125;&#125;public class Solution &#123; public int reverse(int x) &#123; int ret = 0; int flag = x &lt; 0 ? -1 : 1; while (x != 0) &#123; int cur = (x % 10) * flag; if (ret &gt; Integer.MAX_VALUE / 10 || (ret == Integer.MAX_VALUE / 10 &amp;&amp; cur &gt; Integer.MAX_VALUE % 10)) &#123; return 0; &#125; ret = 10 * ret + cur; x /= 10; &#125; return flag * ret; &#125;&#125; 8. String to Integer (atoi) Implement atoi to convert a string to an integer.Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases. Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. Tags: Math, String C++123456789101112131415161718192021222324252627class Solution &#123;public: int myAtoi(string str) &#123; int ret = 0; auto int_max = std::numeric_limits&lt;int&gt;::max(); auto int_min = std::numeric_limits&lt;int&gt;::min(); auto iter = std::begin(str); while (*iter == ' ') &#123; ++iter; &#125; bool negative = false; if (*iter == '-' || *iter == '+') &#123; if(*iter == '-') &#123; negative = true; &#125; ++iter; &#125; for ( ; iter != std::end(str) &amp;&amp; std::isdigit(*iter); ++iter) &#123; int cur = *iter - '0'; if (ret &gt; int_max / 10 || (ret == int_max / 10 &amp;&amp; cur &gt; int_max % 10)) &#123; return negative ? int_min : int_max; &#125; ret = ret * 10 + cur; &#125; return negative ? -ret : ret; &#125;&#125;; Java123456789101112131415161718192021222324252627282930public class Solution &#123; public int myAtoi(String str) &#123; int ret = 0; boolean negative = false; int idx = 0; // deal empty string which not the same as C++ and String is iteratable (java Collections) if (str.isEmpty()) &#123; return ret; &#125; // remove leading space for ( ; str.charAt(idx) == ' '; ++idx) &#123;&#125; // get flag if (str.charAt(idx) == '+' || str.charAt(idx) == '-') &#123; negative = (str.charAt(idx) == '-' ? true : false); ++idx; &#125; // parsing digit chars for ( ; idx &lt; str.length(); ++idx) &#123; int cur = str.charAt(idx) - '0'; if (cur &lt; 0 || cur &gt; 9) &#123; break; &#125; if (ret &gt; Integer.MAX_VALUE / 10 || (ret == Integer.MAX_VALUE / 10 &amp;&amp; Integer.MAX_VALUE % 10 &lt; cur)) &#123; return negative ? Integer.MIN_VALUE : Integer.MAX_VALUE; &#125; ret = ret * 10 + cur; &#125; return negative ? -ret : ret; &#125;&#125; 9. Palindrome NumberTags: String Cpp123456789class Solution &#123;public: bool isPalindrome(int x) &#123; string s1 = std::move(std::to_string(x)); string s2(s1); reverse(s1.begin(), s1.end()); return s1 == s2; &#125;&#125;; Java1234567public class Solution &#123; public boolean isPalindrome(int x) &#123; String a = String.valueOf(x); String b = (new StringBuilder(a)).reverse().toString(); return a.equals(b); &#125;&#125; 10. Regular Expression Matching Implement regular expression matching with support for ‘.’ and ‘*‘.‘.’ Matches any single character.‘*‘ Matches zero or more of the preceding element.The matching should cover the entire input string (not partial).The function prototype should be:bool isMatch(const char s, const char p) Some examples:isMatch(“aa”,”a”) ? falseisMatch(“aa”,”aa”) ? trueisMatch(“aaa”,”aa”) ? falseisMatch(“aa”, “a“) ? trueisMatch(“aa”, “.“) ? trueisMatch(“ab”, “.“) ? trueisMatch(“aab”, “ca*b”) ? true Tag: String, Dynamic Programming, Backtracking Use Dynamic ProgrammingCpp12345678910111213141516171819202122232425262728293031class Solution &#123;public: bool isMatch(string s, string p) &#123; // last char is the key postion, which may be '*' or not // match[i][j] record the s[0 : i - 1] matched p[0 : j - 1] so // match[0][0] = true, match[1 : ][0] = false, match[0][1 : ] = (j &gt; 1 &amp;&amp; match[0][j - 2] &amp;&amp; p[j - 1] == '*') // match[i][j] = p[j - 1] != '*' &amp;&amp; (match[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == '.')) // match[i][j] = p[j - 1] == '*' &amp;&amp; (match[i][j - 2] || (match[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 1] == '.'))) vector&lt;vector&lt;bool&gt;&gt; match(s.length() + 1, vector&lt;bool&gt;(p.length() + 1, false)); match[0][0] = true; for (size_t i = 1; i &lt; match.size(); ++i) &#123; match[i][0] = false; &#125; for (size_t j = 1; j &lt; match[0].size(); ++j) &#123; match[0][j] = (j &gt; 1) &amp;&amp; match[0][j - 2] &amp;&amp; (p[j - 1] == '*'); &#125; for (size_t i = 1; i &lt; match.size(); ++i) &#123; for (size_t j = 1; j &lt; match[0].size(); ++j) &#123; if (p[j - 1] != '*') &#123; match[i][j] = match[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == '.'); &#125; else &#123; // p[j - 1] is '*' so p[j - 2] must exist and match[i - 1][j] covers match[i - 1][j - 2] match[i][j] = match[i][j - 2] || (match[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 2] == '.')); &#125; &#125; &#125; return match.back().back(); &#125;&#125;; Java123456789101112131415161718192021222324252627282930public class Solution &#123; public boolean isMatch(String s, String p) &#123; // last char is the key postion, which may be '*' or not // match[i][j] record the s[0 : i - 1] matched p[0 : j - 1] so // match[0][0] = true, match[1 : ][0] = false, match[0][1 : ] = (j &gt; 1 &amp;&amp; match[0][j - 2] &amp;&amp; p[j - 1] == '*') // match[i][j] = p[j - 1] != '*' &amp;&amp; (match[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == '.')) // match[i][j] = p[j - 1] == '*' &amp;&amp; (match[i][j - 2] || (match[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 1] == '.'))) boolean[][] match = new boolean[s.length() + 1][p.length() + 1]; match[0][0] = true; for (int i = 1; i &lt; match.length; ++i) &#123; match[i][0] = false; &#125; for (int j = 1; j &lt; match[0].length; ++j) &#123; match[0][j] = (j &gt; 1) &amp;&amp; match[0][j - 2] &amp;&amp; p.charAt(j - 1) == '*'; &#125; for (int i = 1; i &lt; match.length; ++i) &#123; for (int j = 1; j &lt; match[0].length; ++j) &#123; if (p.charAt(j - 1) != '*') &#123; match[i][j] = match[i - 1][j - 1] &amp;&amp; (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.'); &#125; else &#123; // p[j - 1] is '*' so p[j - 2] must exist and match[i - 1][j] covers match[i - 1][j - 2] match[i][j] = match[i][j - 2] || (match[i - 1][j] &amp;&amp; (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.')); &#125; &#125; &#125; return match[s.length()][p.length()]; &#125;&#125; Use Backtracking123456789101112131415161718192021222324class Solution &#123;public: bool isMatch(string s, string p) &#123; return isMatch(s.c_str(), p.c_str()); &#125;private: // use c++ string's feature (end with '\0') to avoid some condition check in java inline bool charMatch(const char *s, const char *p) &#123; return (*s == *p || (*p == '.' &amp;&amp; *s != '\0')); &#125; bool isMatch(const char *s, const char *p) &#123; if (*p == '\0') &#123; return *s == '\0'; &#125; if (*(p + 1) != '*') &#123; return charMatch(s, p) &amp;&amp; isMatch(s + 1, p + 1); &#125; else if (charMatch(s, p)) &#123; return isMatch(s + 1, p) || isMatch(s, p + 2); &#125; else &#123; return isMatch(s, p + 2); &#125; &#125;&#125;; 11. Container With Most Water Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.Note: You may not slant the container and n is at least 2. Tags: two pointer Cpp12345678910111213141516class Solution &#123;public: int maxArea(vector&lt;int&gt;&amp; height) &#123; int ret = 0; if (height.size() &lt; 2) &#123; return ret; &#125; size_t left = 0; size_t right = height.size() - 1; while (left &lt; right) &#123; ret = max(ret, min(height[left], height[right]) * static_cast&lt;int&gt;(right - left)); height[left] &lt; height[right] ? ++left : --right; &#125; return ret; &#125;&#125;; Java12345678910111213141516171819public class Solution &#123; public int maxArea(int[] height) &#123; int ret = 0; if (height.length &lt; 2) &#123; return ret; &#125; int left = 0; int right = height.length - 1; while (left &lt; right) &#123; ret = Math.max(ret, Math.min(height[left], height[right]) * (right - left)); if (height[left] &lt; height[right]) &#123; ++left; &#125; else &#123; --right; &#125; &#125; return ret; &#125;&#125; 12. Integer to RomanCpp123456789101112131415class Solution &#123;public: string intToRoman(int num) &#123; vector&lt;string&gt; symbol&#123;"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"&#125;; vector&lt;int&gt; value&#123;1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1&#125;; string ret; for (int i = 0; num &gt; 0; ++i) &#123; while (num &gt;= value[i]) &#123; num -= value[i]; ret += symbol[i]; &#125; &#125; return ret; &#125;&#125;; Java12345678910111213141516public class Solution &#123; public String intToRoman(int num) &#123; String ret = ""; ArrayList&lt;String&gt; symbol = new ArrayList( Arrays.asList("M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I")); ArrayList&lt;Integer&gt; value = new ArrayList( Arrays.asList(1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)); for (int i = 0; num &gt; 0; ++i) &#123; while (num &gt;= value.get(i)) &#123; num -= value.get(i); ret = ret + symbol.get(i); &#125; &#125; return ret; &#125;&#125; 13. Roman to IntegerCpp123456789101112131415161718192021class Solution &#123;public: int romanToInt(string s) &#123; int ret = 0; int pre = 0; unordered_map&lt;char, int&gt; umap &#123; make_pair('I', 1), make_pair('V', 5), make_pair('X', 10), \ make_pair('L', 50), make_pair('C', 100), make_pair('D', 500), \ make_pair('M', 1000)&#125;; for (const auto&amp; c : s) &#123; int cur = umap.at(c); if (cur &lt;= pre) &#123; ret += cur; &#125; else &#123; ret += cur - 2 * pre; // ret = ret - pre + cur - pre &#125; pre = cur; &#125; return ret; &#125;&#125;; Java123456789101112131415161718192021222324public class Solution &#123; public int romanToInt(String s) &#123; HashMap&lt;Character, Integer&gt; hmap = new HashMap&lt;&gt;(); hmap.put('I', 1); hmap.put('V', 5); hmap.put('X', 10); hmap.put('L', 50); hmap.put('C', 100); hmap.put('D', 500); hmap.put('M', 1000); int ret = 0; int pre = 0; for (int i = 0; i &lt; s.length(); ++i) &#123; int cur = hmap.get(s.charAt(i)); if (cur &lt;= pre) &#123; ret += cur; &#125; else &#123; ret = ret - 2 * pre + cur; &#125; pre = cur; &#125; return ret; &#125;&#125; 14. Longest Common PrefixCpp1234567891011121314151617class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if (strs.size() &lt; 1) &#123; return string(""); &#125; for (size_t cursor = 0; cursor &lt; strs[0].size(); ++cursor) &#123; auto cur = strs[0][cursor]; for (size_t i = 1; i &lt; strs.size(); ++i) &#123; if (cur != strs[i][cursor]) &#123; return strs[0].substr(0, cursor); &#125; &#125; &#125; return strs[0]; &#125;&#125;; Java12345678910111213141516public class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; if (strs.length &lt;= 0) &#123; return ""; &#125; for (int cursor = 0; cursor &lt; strs[0].length(); ++cursor) &#123; char pre = strs[0].charAt(cursor); for (int i = 1; i &lt; strs.length; ++i) &#123; if (cursor &gt;= strs[i].length() || strs[i].charAt(cursor) != pre) &#123; return strs[0].substring(0, cursor); &#125; &#125; &#125; return strs[0]; &#125;&#125; 15. 3SumCpp123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; ret; int len = static_cast&lt;int&gt;(nums.size()); std::sort(nums.begin(), nums.end()); for (int i = 0; i &lt; len - 2 &amp;&amp; nums[i] &lt;= 0; ++i) &#123; // remove possible duplicate results if (i &gt; 0 &amp;&amp; nums[i] == nums[i -1 ]) &#123; continue; &#125; int left = i + 1; int right = len - 1; while (left &lt; right) &#123; auto sum = nums[i] + nums[left] + nums[right]; if (sum == 0) &#123; ret.push_back(vector&lt;int&gt;&#123;nums[i], nums[left++], nums[right--]&#125;); // remove possible duplicate results while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) &#123; ++left; &#125; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) &#123; --right; &#125; &#125; else if (sum &gt; 0) &#123; --right; &#125; else &#123; ++left; &#125; &#125; &#125; return ret; &#125;&#125;; Java12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); int len = nums.length; Arrays.sort(nums); for (int i = 0; i &lt; len - 2 &amp;&amp; nums[i] &lt;= 0; ++i) &#123; // remove possible duplicate results if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; int left = i + 1; int right = len - 1; while (left &lt; right) &#123; int sum = nums[i] + nums[left] + nums[right]; if (sum == 0) &#123; ret.add(new ArrayList(Arrays.asList(nums[i], nums[left], nums[right]))); ++left; --right; // remove possible duplicate results while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) &#123; ++left; &#125; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) &#123; --right; &#125; &#125; else if (sum &gt; 0) &#123; --right; &#125; else &#123; ++left; &#125; &#125; &#125; return ret; &#125;&#125; 16. 3sum closetCpp1234567891011121314151617181920212223242526272829class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; int len = nums.size(); assert(len &gt;= 3); int min_diff = INT_MAX; std::sort(nums.begin(), nums.end()); for (int i = 0; i &lt; (len - 2); ++i) &#123; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; int left = i + 1; int right = len - 1; while (left &lt; right) &#123; int cur_diff = nums[i] + nums[left] + nums[right] - target; if (cur_diff == 0) &#123; return target; &#125; else if (cur_diff &gt; 0) &#123; right--; &#125; else &#123; left++; &#125; min_diff = abs(cur_diff) &lt; abs(min_diff) ? cur_diff : min_diff; &#125; &#125; return min_diff + target; &#125;&#125;; Java123456789101112131415161718192021222324252627282930public class Solution &#123; public int threeSumClosest(int[] nums, int target) &#123; int len = nums.length; int minDiff = Integer.MAX_VALUE; Arrays.sort(nums); for (int i = 0; i &lt; len - 2; ++i) &#123; // avoid duplicate calc if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; int left = i + 1; int right = len - 1; while (left &lt; right) &#123; int curDiff = nums[i] + nums[left] + nums[right] - target; if (curDiff == 0) &#123; return target; &#125; else if (curDiff &gt; 0) &#123; --right; &#125; else &#123; ++left; &#125; if (Math.abs(curDiff) &lt; Math.abs(minDiff)) &#123; minDiff = curDiff; &#125; &#125; &#125; return minDiff + target; &#125;&#125; 17. Letter Combinations of a Phone Number Given a digit string, return all possible letter combinations that the number could represent.A mapping of digit to letters (just like on the telephone buttons) is given below. Tags: backtracking, string Cpp12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; vector&lt;string&gt; ret; if (digits.empty()) &#123; return ret; &#125; vector&lt;string&gt; keyboard&#123;" ", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"&#125;; // return letterCombinationsIterative(digits, keyboard); letterCombinations(ret, "", 0, digits, keyboard); return ret; &#125;private: void letterCombinations(vector&lt;string&gt; &amp;ret, const string &amp;cur, size_t idx, const string &amp;digits, const vector&lt;string&gt; &amp;keyboard) &#123; if (idx &gt;= digits.size()) &#123; ret.push_back(cur); &#125; else &#123; for (auto c : keyboard[digits[idx] - '0']) &#123; letterCombinations(ret, cur + c, idx + 1, digits, keyboard); &#125; &#125; &#125; vector&lt;string&gt; letterCombinationsIterative(const string &amp;digits, const vector&lt;string&gt; &amp;keyboard) &#123; vector&lt;string&gt; ret&#123;""&#125;; for (auto d : digits) &#123; vector&lt;string&gt; tmp; for (auto r : ret) &#123; for (auto c : keyboard[d - '0']) &#123; tmp.push_back(r + c); &#125; &#125; ret.swap(tmp); &#125; return ret; &#125;&#125;; Java1234567891011121314151617181920212223242526272829303132333435363738394041public class Solution &#123; public List&lt;String&gt; letterCombinations(String digits) &#123; List&lt;String&gt; ret = new ArrayList&lt;&gt;(); if (digits.isEmpty()) &#123; return ret; &#125; ArrayList&lt;String&gt; keyboard = new ArrayList( Arrays.asList(" ", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz")); // return letterCombinationsIterative(digits, keyboard); letterCombinationsRecursive(ret, "", 0, digits, keyboard); return ret; &#125; private void letterCombinationsRecursive(List&lt;String&gt; ret, String cur, int idx, String digits, List&lt;String&gt; keyboard) &#123; if (idx &gt;= digits.length()) &#123; ret.add(cur); &#125; else &#123; String key = keyboard.get(digits.charAt(idx) - '0'); for (int i = 0; i &lt; key.length(); ++i) &#123; letterCombinationsRecursive(ret, cur + key.charAt(i), idx + 1, digits, keyboard); &#125; &#125; &#125; private List&lt;String&gt; letterCombinationsIterative(String digits, List&lt;String&gt; keyboard) &#123; List&lt;String&gt; ret = new ArrayList&lt;&gt;(); ret.add(""); for (int i = 0; i &lt; digits.length(); ++i) &#123; List&lt;String&gt; tmp = new ArrayList&lt;&gt;(); for (String r : ret) &#123; int cur = digits.charAt(i) - '0'; for (int j = 0; j &lt; keyboard.get(cur).length(); ++j) &#123; tmp.add(r + keyboard.get(cur).charAt(j)); &#125; &#125; ret = tmp; &#125; return ret; &#125;&#125; Scala12345678910111213141516171819202122232425262728object Solution &#123; def letterCombinations(digits: String): List[String] = &#123; val ret = List[String]() val keyboard = Array(" ", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz") digits.isEmpty match &#123; case true =&gt; ret case false =&gt; //letterCombinationsIterative(digits, keyboard) letterCombinationsRecursive(0, digits, keyboard) &#125; &#125; private def letterCombinationsRecursive(start: Int, digits: String, keyboard: Array[String]): List[String] = &#123; if (start &gt;= digits.size) &#123; List("") &#125; else &#123; val tmp = letterCombinationsRecursive(start + 1, digits, keyboard) (for &#123; k &lt;- keyboard(digits(start) - '0') t &lt;- tmp &#125; yield (k + t)).toList &#125; &#125; private def letterCombinationsIterative(digits: String, keyboard: Array[String]): List[String] = &#123; digits.foldLeft(List("")) &#123; (ret, d) =&gt; ret.flatMap &#123; r =&gt; keyboard(d - '0').map &#123; k =&gt; r + k &#125; &#125; &#125; &#125;&#125; 18. 4Sum Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.Note: The solution set must not contain duplicate quadruplets.For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] Tags: two pointer Cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;vector&lt;int&gt;&gt; ret; if (nums.size() &lt; 4) &#123; return ret; &#125; sort(nums.begin(), nums.end()); vector&lt;int&gt; cur; ksum(ret, 0, 4, cur, target, nums); return ret; &#125;private: void ksum(vector&lt;vector&lt;int&gt;&gt; &amp;ret, int start, int k, vector&lt;int&gt; &amp;cur, int target, const vector&lt;int&gt; &amp;nums) &#123; if (k * nums.front() &gt; target || k * nums.back() &lt; target) &#123; return; &#125; else if (k == 2) &#123; int left = start; int right = nums.size() - 1; while (left &lt; right) &#123; auto sum = nums[left] + nums[right] - target; if (sum == 0) &#123; auto tmp = cur; tmp.push_back(nums[left]); tmp.push_back(nums[right]); ret.push_back(tmp); ++left; --right; // avoid possible duplicates while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) &#123; ++left; &#125; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) &#123; --right; &#125; &#125; else if (sum &gt; 0) &#123; --right; &#125; else &#123; ++left; &#125; &#125; &#125; else &#123; for (int i = start; i &lt; nums.size() -k + 1; ++i) &#123; if (i &gt; start &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; cur.push_back(nums[i]); ksum(ret, i + 1, k - 1, cur, target - nums[i], nums); cur.pop_back(); &#125; &#125; &#125; &#125;; Java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); if (nums.length &lt; 4) &#123; return ret; &#125; Arrays.sort(nums); List&lt;Integer&gt; cur = new ArrayList&lt;&gt;(); ksum(ret, 0, 4, cur, target, nums); return ret; &#125; private void ksum(List&lt;List&lt;Integer&gt;&gt; ret, int start, int k, List&lt;Integer&gt; cur, int target, int[] nums) &#123; if (k * nums[0] &gt; target || k * nums[nums.length - 1] &lt; target) &#123; return; &#125; else if (k == 2) &#123; int left = start; int right = nums.length - 1; while (left &lt; right) &#123; int sum = nums[left] + nums[right] - target; if (sum == 0) &#123; List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(cur); tmp.add(nums[left]); tmp.add(nums[right]); ret.add(tmp); ++left; --right; // avoid possible duplicates while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) &#123; ++left; &#125; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) &#123; --right; &#125; &#125; else if (sum &gt; 0) &#123; --right; &#125; else &#123; ++left; &#125; &#125; &#125; else &#123; for (int i = start; i &lt; nums.length - k + 1; ++i) &#123; if (i &gt; start &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; cur.add(nums[i]); ksum(ret, i + 1, k - 1, cur, target - nums[i], nums); cur.remove(cur.size() - 1); &#125; &#125; &#125;&#125; Scala123456789101112131415161718192021222324252627282930313233343536373839object Solution &#123; def fourSum(nums: Array[Int], target: Int): List[List[Int]] = &#123; var ret: List[List[Int]] = List() if (nums.size &lt; 4) return ret val sortedNums = nums.sorted var cur: List[Int] = List() def ksum(start: Int, k: Int, target: Int): Unit = &#123; if (k == 2) &#123; var left = start; var right = sortedNums.size - 1 while (left &lt; right) &#123; var sum = sortedNums(left) + sortedNums(right) - target if (sum == 0) &#123; var tmp = cur ::: List(sortedNums(left), sortedNums(right)) ret = ret ::: List(tmp) left += 1 right -= 1 while (left &lt; right &amp;&amp; sortedNums(left) == sortedNums(left - 1)) left += 1 while (left &lt; right &amp;&amp; sortedNums(right) == sortedNums(right + 1)) right -= 1 &#125; else if (sum &gt; 0) &#123; right -= 1 &#125; else left += 1 &#125; &#125; else &#123; for (i &lt;- start until sortedNums.length - k + 1) &#123; if (i == start || sortedNums(i) != sortedNums(i - 1)) &#123; var tmp = cur cur = cur ::: List(sortedNums(i)) ksum(i + 1, k - 1, target - sortedNums(i)) cur = tmp &#125; &#125; &#125; &#125; ksum(0, 4, target) ret &#125;&#125; 19. Remove Nth Node From End of ListTags: List Cpp1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode dummy = ListNode(0); dummy.next = head; ListNode *first = &amp;dummy; for (int i = 0; i &lt; n; ++i) &#123; if (first == nullptr) &#123; return nullptr; &#125; else &#123; first = first-&gt;next; &#125; &#125; ListNode *pre = &amp;dummy; for (; first != nullptr &amp;&amp; first-&gt;next != nullptr; first = first-&gt;next) &#123; pre = pre-&gt;next; &#125; auto tmp = pre-&gt;next-&gt;next; delete pre-&gt;next; pre-&gt;next = tmp; return dummy.next; &#125;&#125;; Java123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode first = dummy; for (int i = 0; i &lt; n; ++i) &#123; if (first == null) &#123; return null; &#125; else &#123; first = first.next; &#125; &#125; ListNode ptr = dummy; for (; first != null &amp;&amp; first.next != null; first = first.next) &#123; ptr = ptr.next; &#125; ListNode tmp = ptr.next.next; ptr.next = null; ptr.next = tmp; return dummy.next; &#125;&#125; 20. Valid ParenthesesTags: Stack Cpp123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: bool isValid(string s) &#123; stack&lt;char&gt; stc; for (auto c : s) &#123; if (isLeft(c)) &#123; stc.push(c); &#125; else if (stc.empty()) &#123; return false; &#125; else if (isMatch(stc.top(), c)) &#123; stc.pop(); &#125; else &#123; return false; &#125; &#125; return stc.empty(); &#125; private: bool isLeft(char c) &#123; return (c == '(' || c == '&#123;' || c == '['); &#125; bool isMatch(char l, char r) &#123; if (l == '(') &#123; return r == ')'; &#125; else if (l == '&#123;') &#123; return r == '&#125;'; &#125; else if (l == '[') &#123; return r == ']'; &#125; else &#123; return false; &#125; &#125; &#125;; Java1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stc = new Stack&lt;&gt;(); for (int i = 0; i &lt; s.length(); ++i) &#123; char c = s.charAt(i); if (isLeft(c)) &#123; stc.push(c); &#125; else if (stc.empty()) &#123; return false; &#125; else if (isMatch(stc.peek(), c)) &#123; stc.pop(); &#125; else &#123; return false; &#125; &#125; return stc.empty(); &#125; private boolean isLeft(char c) &#123; return (c == '(' || c == '&#123;' || c == '['); &#125; private boolean isMatch(char l, char r) &#123; if (l == '(') &#123; return r == ')'; &#125; else if (l == '&#123;') &#123; return r == '&#125;'; &#125; else if (l == '[') &#123; return r == ']'; &#125; else &#123; return false; &#125; &#125; &#125;; Scala123456789101112131415object Solution &#123; def isValid(s: String): Boolean = &#123; val parenthesesMap = Map('(' -&gt; ')', '&#123;' -&gt; '&#125;', '[' -&gt; ']') val ret = s.foldLeft(List[Char]()) &#123; (stc, c) =&gt; c match &#123; case '(' | '&#123;' | '[' =&gt; c :: stc case ')' | '&#125;' | ']' =&gt; if (stc.isEmpty) return false else if (parenthesesMap.get(stc.head) != Some(c)) return false else stc.tail &#125; &#125; ret.isEmpty &#125;&#125; 21. Merge Two Sorted ListsCpp123456789101112131415161718192021222324/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if (l1 == nullptr) &#123; return l2; &#125; else if (l2 == nullptr) &#123; return l1; &#125; else if (l1-&gt;val &lt; l2-&gt;val) &#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125; else &#123; l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; &#125; &#125;&#125;; Java1234567891011121314151617181920212223/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) &#123; return l2; &#125; else if (l2 == null) &#123; return l1; &#125; else if (l1.val &lt; l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125; &#125;&#125; Scala1234567891011121314151617181920212223/** * Definition for singly-linked list. * class ListNode(var _x: Int = 0) &#123; * var next: ListNode = null * var x: Int = _x * &#125; */object Solution &#123; def mergeTwoLists(l1: ListNode, l2: ListNode): ListNode = &#123; (l1, l2) match &#123; case (null, _) =&gt; l2 case (_, null) =&gt; l1 case _ =&gt; (l1.x &lt; l2.x) match &#123; case true =&gt; l1.next = mergeTwoLists(l1.next, l2) l1 case false =&gt; l2.next = mergeTwoLists(l1, l2.next) l2 &#125; &#125; &#125;&#125; 22. Generate ParenthesesCpp123456789101112131415161718192021class Solution &#123;public: vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; ret; generateParenthesis(ret, "", n, n); return ret; &#125;private: void generateParenthesis(vector&lt;string&gt; &amp;ret, string cur, int curLeftNum, int curRightNum) &#123; if (curLeftNum == 0 &amp;&amp; curRightNum == 0) &#123; ret.push_back(cur); &#125; if (curLeftNum &gt; 0) &#123; generateParenthesis(ret, cur + '(', curLeftNum - 1, curRightNum); &#125; if (curRightNum &gt; curLeftNum) &#123; generateParenthesis(ret, cur + ')', curLeftNum, curRightNum - 1); &#125; &#125;&#125;; Java12345678910111213141516171819public class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; ret = new ArrayList&lt;&gt;(); generateParenthesis(ret, "", n, n); return ret; &#125; private void generateParenthesis(List&lt;String&gt; ret, String cur, int curLeftNum, int curRightNum) &#123; if (curLeftNum == 0 &amp;&amp; curRightNum == 0) &#123; ret.add(cur); &#125; if (curLeftNum &gt; 0) &#123; generateParenthesis(ret, cur + "(", curLeftNum - 1, curRightNum); &#125; if (curRightNum &gt; curLeftNum) &#123; generateParenthesis(ret, cur + ")", curLeftNum, curRightNum - 1); &#125; &#125;&#125; Scala12345678910111213141516171819202122232425object Solution &#123; def generateParenthesis(n: Int): List[String] = &#123; generateInternal(List[String](), "", n, n) &#125; private def generateInternal(ret: List[String], cur: String, curLeftNum: Int, curRightNum: Int): List[String] = &#123; if (curLeftNum == 0 &amp;&amp; curRightNum == 0) &#123; ret ::: List(cur) &#125; else &#123; val ret1 = &#123; if (curLeftNum &gt; 0) generateInternal(ret, cur + "(", curLeftNum - 1, curRightNum) else ret &#125; val ret2 = &#123; if (curRightNum &gt; curLeftNum) generateInternal(ret1, cur + ")", curLeftNum, curRightNum - 1) else ret1 &#125; ret2 &#125; &#125;&#125; 23. Merge k Sorted Lists Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. Tags: Linked List, Divide and Conquer, Heap C++123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; if (lists.empty()) &#123; return nullptr; &#125; for (int sz = static_cast&lt;int&gt;(lists.size()); sz &gt; 1; ) &#123; int offset = (sz + 1) / 2; for (int i = 0; i &lt; sz / 2; ++i) &#123; lists[i] = mergeTwoLists(lists[i], lists[i + offset]); &#125; sz = offset; &#125; return lists.front(); &#125; private: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if (l1 == nullptr) &#123; return l2; &#125; else if (l2 == nullptr) &#123; return l1; &#125; else if (l1-&gt;val &lt; l2-&gt;val) &#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125; else &#123; l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; &#125; &#125;&#125;; Java12345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; if (lists.length == 0) &#123; return null; &#125; for (int sz = lists.length; sz &gt; 1; ) &#123; int offset = (sz + 1) / 2; for (int i = 0; i &lt; sz / 2; ++i) &#123; lists[i] = mergeTwoLists(lists[i], lists[i + offset]); &#125; sz = offset; &#125; return lists[0]; &#125; private ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) &#123; return l2; &#125; else if (l2 == null) &#123; return l1; &#125; else if (l1.val &lt; l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125; &#125;&#125; 24. Swap Nodes in Pairs Given a linked list, swap every two adjacent nodes and return its head.For example,Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. Tags: LinkedList C++123456789101112131415161718192021222324/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; ListNode dummy(1); dummy.next = head; auto pre = &amp;dummy; for (auto cur = head; cur != nullptr &amp;&amp; cur-&gt;next != nullptr; cur = cur-&gt;next) &#123; auto tmp = cur-&gt;next; cur-&gt;next = tmp-&gt;next; tmp-&gt;next = cur; pre-&gt;next = tmp; pre = cur; &#125; return dummy.next; &#125;&#125;; Java1234567891011121314151617181920212223/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode swapPairs(ListNode head) &#123; ListNode dummy = new ListNode(1); dummy.next = head; ListNode pre = dummy; for (ListNode cur = head; cur != null &amp;&amp; cur.next != null; cur = cur.next) &#123; ListNode tmp = cur.next; cur.next = tmp.next; tmp.next = cur; pre.next = tmp; pre = cur; &#125; return dummy.next; &#125;&#125; 25. Reverse Nodes in k-Group Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.You may not alter the values in the nodes, only nodes itself may be changed.Only constant memory is allowed. For example,Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5 Tags: Array, HashTable C++1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseKGroup(ListNode* head, int k) &#123; ListNode dummy = ListNode(0); dummy.next = head; auto pre = &amp;dummy; auto ptr = &amp;dummy; for (int i = 0; i &lt; k &amp;&amp; ptr != nullptr; ++i) &#123; ptr = ptr-&gt;next; &#125; while (ptr != nullptr) &#123; auto nextDummy = pre-&gt;next; for (int i = 1; i &lt; k; ++i) &#123; auto tmp = pre-&gt;next-&gt;next; pre-&gt;next-&gt;next = ptr-&gt;next; ptr-&gt;next = pre-&gt;next; pre-&gt;next = tmp; &#125; pre = nextDummy; ptr = nextDummy; for (int i = 0; i &lt; k &amp;&amp; ptr != nullptr; ++i) &#123; ptr = ptr-&gt;next; &#125; &#125; return dummy.next; &#125;&#125;; Java12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseKGroup(ListNode head, int k) &#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode pre = dummy; ListNode ptr = dummy; for (int i = 0; i &lt; k &amp;&amp; ptr != null; ++i) &#123; ptr = ptr.next; &#125; while (ptr != null) &#123; ListNode nextDummy = pre.next; for (int i = 1; i &lt; k; ++i) &#123; ListNode tmp = pre.next.next; pre.next.next = ptr.next; ptr.next = pre.next; pre.next = tmp; &#125; pre = nextDummy; ptr = nextDummy; for (int i = 0; i &lt; k &amp;&amp; ptr != null; ++i) &#123; ptr = ptr.next; &#125; &#125; return dummy.next; &#125;&#125; 26. Remove Duplicates from Sorted ArrayCpp1234567891011121314class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int pre = -1; for (int cur = 0; cur &lt; static_cast&lt;int&gt;(nums.size()); ++cur) &#123; if (pre == -1) &#123; ++pre; &#125; else if (nums[cur] != nums[cur - 1]) &#123; nums[++pre] = nums[cur]; &#125; &#125; return pre + 1; &#125;&#125;; Java12345678910111213public class Solution &#123; public int removeDuplicates(int[] nums) &#123; int pre = -1; for (int cur = 0; cur &lt; nums.length; ++cur) &#123; if (pre == -1) &#123; ++pre; &#125; else if (nums[cur] != nums[cur - 1]) &#123; nums[++pre] = nums[cur]; &#125; &#125; return pre + 1; &#125;&#125; Scala1234567891011121314object Solution &#123; def removeDuplicates(nums: Array[Int]): Int = &#123; var pre = -1 for (cur &lt;- 0 until nums.length) &#123; if (pre == -1) &#123; pre += 1 &#125; else if (nums(cur) != nums(cur - 1)) &#123; pre += 1 nums(pre) = nums(cur) &#125; &#125; return pre + 1 &#125;&#125; 27. Remove ElementC++123456789101112class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int ret = 0; for (auto n : nums) &#123; if (n != val) &#123; nums[ret++] = n; &#125; &#125; return ret; &#125;&#125;; Java1234567891011class Solution &#123; public int removeElement(int[] nums, int val) &#123; int ret = 0; for (int i = 0; i &lt; nums.length; ++i) &#123; if (nums[i] != val) &#123; nums[ret++] = nums[i]; &#125; &#125; return ret; &#125;&#125; Scala123456789101112object Solution &#123; def removeElement(nums: Array[Int], v: Int): Int = &#123; var ret = 0 for (i &lt;- 0 until nums.size) &#123; if (nums(i) != v) &#123; nums(ret) = nums(i) ret += 1 &#125; &#125; return ret &#125;&#125; 28. Implement strStrTags: Two Pointers, String C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Solution &#123;public: int strStr(string haystack, string needle) &#123; int ret1 = strStrBackoff(haystack, needle); int ret2 = strStrBruteForce(haystack, needle); int ret3 = strStrKMP(haystack, needle); cout &lt;&lt; ret1 &lt;&lt; " " &lt;&lt; ret2 &lt;&lt; " " &lt;&lt; ret3 &lt;&lt; endl; assert(ret1 == ret2 &amp;&amp; ret2 == ret3); return ret1; &#125; private: int strStrBruteForce(const string &amp;source, const string &amp;target) &#123; int src_len = static_cast&lt;int&gt;(source.size()); int tgt_len = static_cast&lt;int&gt;(target.size()); for (int i = 0; i &lt;= src_len - tgt_len; ++i) &#123; int j = 0; for ( ; j &lt; tgt_len &amp;&amp; source[i + j] == target[j]; ++j) &#123;&#125; if (j == tgt_len) &#123; return i; &#125; &#125; return -1; &#125; int strStrBackoff(const string &amp;source, const string &amp;target) &#123; int src_len = static_cast&lt;int&gt;(source.size()); int tgt_len = static_cast&lt;int&gt;(target.size()); int i = 0; int j = 0; for ( ; i &lt; src_len &amp;&amp; j &lt; tgt_len; ++i) &#123; if (source[i] == target[j]) &#123; ++j; &#125; else &#123; i -= j; j = 0; &#125; &#125; if (j == tgt_len) &#123; return i - tgt_len; &#125; return -1; &#125; int strStrKMP(string source, string target) &#123; if (target.empty()) &#123; return 0; &#125; auto getPattern = [](const string&amp; str) &#123; vector&lt;int&gt; pattern(str.length(), 0); int k = 0; for (size_t i = 1; i &lt; str.length(); ++i) &#123; while (k &gt; 0 &amp;&amp; str[k] != str[i]) &#123; k = pattern[k - 1]; &#125; if (str[k] == str[i]) &#123; ++k; &#125; pattern[i] = k; &#125; return pattern; &#125;; auto pattern = getPattern(target); int k = 0; for (size_t i = 0; i &lt; source.length(); ++i) &#123; while (k &gt; 0 &amp;&amp; source[i] != target[k]) &#123; k = pattern[k - 1]; &#125; if (source[i] == target[k]) &#123; ++k; &#125; if (k == target.length()) &#123; return i - k + 1; &#125; &#125; return -1; &#125;&#125;; Java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class Solution &#123; public int strStr(String haystack, String needle) &#123; int ret1 = strStrBruteForce(haystack, needle); int ret2 = strKMP(haystack, needle); int ret3 = strStrBackoff(haystack, needle); System.out.println("ret1 = " + ret1 + " ret2 = " + ret2 + " ret3 = " + ret3); assert ret1 == ret2; assert ret2 == ret3; return ret2; &#125; private int strStrBackoff(String source, String target) &#123; int i = 0; int j = 0; for ( ; i &lt; source.length() &amp;&amp; j &lt; target.length(); ) &#123; if (source.charAt(i) == target.charAt(j)) &#123; ++j; &#125; else &#123; i -= j; j = 0; &#125; ++i; &#125; if (j == target.length()) &#123; return i - j; &#125; return -1; &#125; private int strStrBruteForce(String source, String target) &#123; for (int i = 0; i &lt;= source.length() - target.length(); ++i) &#123; int j = 0; for ( ; j &lt; target.length() &amp;&amp; source.charAt(i + j) == target.charAt(j); ++j) &#123;&#125; if (j == target.length()) &#123; return i; &#125; &#125; return -1; &#125; private List&lt;Integer&gt; kmpPattern(String target) &#123; List&lt;Integer&gt; pattern = new ArrayList&lt;&gt;(Collections.nCopies(target.length(), 0)); int k = 0; for (int i = 1; i &lt; target.length(); ++i) &#123; while (k &gt; 0 &amp;&amp; target.charAt(k) != target.charAt(i)) &#123; k = pattern.get(k - 1); &#125; if (target.charAt(k) == target.charAt(i)) &#123; ++k; &#125; pattern.set(i, k); &#125; return pattern; &#125; private int strKMP(String source, String target) &#123; if (target.isEmpty()) &#123; return 0; &#125; List&lt;Integer&gt; pattern = kmpPattern(target); int k = 0; for (int i = 0; i &lt; source.length(); ++i) &#123; while (k &gt; 0 &amp;&amp; source.charAt(i) != target.charAt(k)) &#123; k = pattern.get(k - 1); &#125; if (source.charAt(i) == target.charAt(k)) &#123; ++k; &#125; if (k == target.length()) &#123; return i - k + 1; &#125; &#125; return -1; &#125;&#125; 46. PermutationsTags: Backtracking C++12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; ret; permute(ret, nums, 0); return ret; &#125;private: void permute(vector&lt;vector&lt;int&gt;&gt;&amp; ret, vector&lt;int&gt;&amp; nums, int start) &#123; if (start == nums.size()) &#123; ret.push_back(nums); &#125; else &#123; for (size_t i = start; i != nums.size(); ++i) &#123; swap(nums[start], nums[i]); permute(ret, nums, start + 1); swap(nums[start], nums[i]); &#125; &#125; &#125;&#125;; Java1234567891011121314151617181920class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); List&lt;Integer&gt; numList = Arrays.stream(nums).boxed().collect(Collectors.toList()); permute(ret, numList, 0); return ret; &#125; private void permute(List&lt;List&lt;Integer&gt;&gt; ret, List&lt;Integer&gt; nums, int start) &#123; if (start &gt;= nums.size()) &#123; ret.add(new ArrayList(nums)); &#125; else &#123; for (int i = start; i &lt; nums.size(); ++i) &#123; Collections.swap(nums, start, i); permute(ret, nums, start + 1); Collections.swap(nums, start, i); &#125; &#125; &#125;&#125; 47. Permutations IITags: Backtracking C++123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; ret; permutation(ret, nums, 0); return ret; &#125;private: void permutation(vector&lt;vector&lt;int&gt;&gt;&amp; ret, vector&lt;int&gt;&amp; nums, size_t start) &#123; if (start &gt;= nums.size()) &#123; ret.push_back(nums); &#125; else &#123; for (size_t idx = start; idx != nums.size(); ++idx) &#123; if (std::find(nums.begin() + start, nums.begin() + idx, nums[idx]) == (nums.begin() + idx)) &#123; swap(nums[idx], nums[start]); permutation(ret, nums, start + 1); swap(nums[idx], nums[start]); &#125; &#125; &#125; &#125;&#125;; Java1234567891011121314151617181920212223242526272829class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); List&lt;Integer&gt; numList = Arrays.stream(nums).boxed().collect(Collectors.toList()); permute(ret, numList, 0); return ret; &#125; private void permute(List&lt;List&lt;Integer&gt;&gt; ret, List&lt;Integer&gt; nums, int start) &#123; if (start &gt;= nums.size()) &#123; ret.add(new ArrayList(nums)); &#125; else &#123; for (int i = start; i &lt; nums.size(); ++i) &#123; int idx = start; for ( ; idx &lt; i; ++idx) &#123; if (nums.get(idx) == nums.get(i)) &#123; break; &#125; &#125; if (idx &lt; i) &#123; continue; &#125; Collections.swap(nums, start, i); permute(ret, nums, start + 1); Collections.swap(nums, start, i); &#125; &#125; &#125;&#125; 94. Binary Tree Inorder TraversalTags: Tree C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; // return inorderTraversalIterative(root); return inorderTraversalMorris(root); &#125;private: vector&lt;int&gt; inorderTraversalMorris(TreeNode* root) &#123; vector&lt;int&gt; ret; if (root == nullptr) &#123; return ret; &#125; auto cur = root; while (cur != nullptr) &#123; if (cur-&gt;left == nullptr) &#123; ret.push_back(cur-&gt;val); cur = cur-&gt;right; &#125; else &#123; auto pre = cur-&gt;left; while (pre-&gt;right != nullptr &amp;&amp; pre-&gt;right != cur) &#123; pre = pre-&gt;right; &#125; if (pre-&gt;right == nullptr) &#123; pre-&gt;right = cur; cur = cur-&gt;left; &#125; else &#123; ret.push_back(cur-&gt;val); // move to if would make this preorderTraversal pre-&gt;right = nullptr; cur = cur-&gt;right; &#125; &#125; &#125; return ret; &#125; vector&lt;int&gt; inorderTraversalIterative(const TreeNode* root) &#123; vector&lt;int&gt; ret; if (root == nullptr) &#123; return ret; &#125; stack&lt;const TreeNode*&gt; stc; auto ptr = root; while (ptr != nullptr || !stc.empty()) &#123; if (ptr == nullptr) &#123; ptr = stc.top(); stc.pop(); ret.push_back(ptr-&gt;val); ptr = ptr-&gt;right; &#125; else &#123; stc.push(ptr); ptr = ptr-&gt;left; &#125; &#125; return ret; &#125;&#125;; Java12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); if (root == null) &#123; return ret; &#125; TreeNode cursor = root; Stack&lt;TreeNode&gt; stc = new Stack&lt;&gt;(); while (cursor != null || !stc.empty()) &#123; if (cursor == null) &#123; cursor = stc.peek(); stc.pop(); ret.add(cursor.val); cursor = cursor.right; &#125; else &#123; stc.push(cursor); cursor = cursor.left; &#125; &#125; return ret; &#125;&#125; 144. Binary Tree Preorder TraversalTags: Tree C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; //return preorderTraversalIterative(root); return preorderTraversalMorris(root); &#125;private: vector&lt;int&gt; preorderTraversalMorris(TreeNode* root) &#123; vector&lt;int&gt; ret; if (root == nullptr) &#123; return ret; &#125; // swap left and right and ret make it postorderTraversal auto cur = root; while (cur != nullptr) &#123; if (cur-&gt;left == nullptr) &#123; ret.push_back(cur-&gt;val); cur = cur-&gt;right; &#125; else &#123; auto pre = cur-&gt;left; while (pre-&gt;right != nullptr &amp;&amp; pre-&gt;right != cur) &#123; pre = pre-&gt;right; &#125; if (pre-&gt;right == nullptr) &#123; ret.push_back(cur-&gt;val); // move it to else make this inorderTraversa; pre-&gt;right = cur; cur = cur-&gt;left; &#125; else &#123; pre-&gt;right = nullptr; cur = cur-&gt;right; &#125; &#125; &#125; return ret; &#125; vector&lt;int&gt; preorderTraversalIterative(const TreeNode* root) &#123; vector&lt;int&gt; ret; if (root == nullptr) &#123; return ret; &#125; stack&lt;const TreeNode*&gt; stc; auto ptr = root; while (ptr != nullptr || !stc.empty()) &#123; if (ptr == nullptr) &#123; ptr = stc.top(); stc.pop(); &#125; ret.push_back(ptr-&gt;val); if (ptr-&gt;right != nullptr) &#123; stc.push(ptr-&gt;right); &#125; ptr = ptr-&gt;left; &#125; return ret; &#125;&#125;; Java12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); if (root == null) &#123; return ret; &#125; TreeNode cursor = root; Stack&lt;TreeNode&gt; stc = new Stack&lt;&gt;(); while (cursor != null || !stc.empty()) &#123; if (cursor == null) &#123; cursor = stc.peek(); stc.pop(); &#125; ret.add(cursor.val); if (cursor.right != null) &#123; stc.push(cursor.right); &#125; cursor = cursor.left; &#125; return ret; &#125;&#125; 145. Binary Tree Postorder TraversalTags: Tree C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; //return postorderTraversalIterative(root); return postorderTraversalMorris(root); &#125;private: vector&lt;int&gt; postorderTraversalMorris(TreeNode* root) &#123; vector&lt;int&gt; ret; if (root == nullptr) &#123; return ret; &#125; // swap preorder's left and right and reverse ret makes this postorderTraversal auto cur = root; while (cur != nullptr) &#123; if (cur-&gt;right == nullptr) &#123; ret.push_back(cur-&gt;val); cur = cur-&gt;left; &#125; else &#123; auto pre = cur-&gt;right; while (pre-&gt;left != nullptr &amp;&amp; pre-&gt;left != cur) &#123; pre = pre-&gt;left; &#125; if (pre-&gt;left == nullptr) &#123; ret.push_back(cur-&gt;val); pre-&gt;left = cur; cur = cur-&gt;right; &#125; else &#123; pre-&gt;left = nullptr; cur = cur-&gt;left; &#125; &#125; &#125; reverse(ret.begin(), ret.end()); return ret; &#125; vector&lt;int&gt; postorderTraversalIterative(const TreeNode* root) &#123; vector&lt;int&gt; ret; if (root == nullptr) &#123; return ret; &#125; // swap preorder's left and right and reverse ret makes this postorderTraversal stack&lt;const TreeNode*&gt; stc; auto ptr = root; while (ptr != nullptr || !stc.empty()) &#123; if (ptr == nullptr) &#123; ptr = stc.top(); stc.pop(); &#125; ret.push_back(ptr-&gt;val); if (ptr-&gt;left != nullptr) &#123; stc.push(ptr-&gt;left); &#125; ptr = ptr-&gt;right; &#125; reverse(ret.begin(), ret.end()); return ret; &#125;&#125;; Java123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); if (root == null) &#123; return ret; &#125; // swap preorder's left and right and reverse ret makes this postorderTraversal TreeNode cursor = root; Stack&lt;TreeNode&gt; stc = new Stack&lt;&gt;(); while (cursor != null || !stc.empty()) &#123; if (cursor == null) &#123; cursor = stc.peek(); stc.pop(); &#125; ret.add(cursor.val); if (cursor.left != null) &#123; stc.push(cursor.left); &#125; cursor = cursor.right; &#125; Collections.reverse(ret); return ret; &#125;&#125; 173. Binary Search Tree Iterator mplement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.Calling next() will return the next smallest number in the BST.Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree. Tags: Tree C++123456789101112131415161718192021222324252627282930313233343536/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class BSTIterator &#123;public: BSTIterator(TreeNode *root) &#123; for ( ; root != nullptr; root = root-&gt;left) &#123; stc.push(root); &#125; &#125; /** @return whether we have a next smallest number */ bool hasNext() &#123; return !stc.empty(); &#125; /** @return the next smallest number */ int next() &#123; auto ret = stc.top()-&gt;val; auto ptr = stc.top()-&gt;right; stc.pop(); for ( ; ptr != nullptr; ptr = ptr-&gt;left) &#123; stc.push(ptr); &#125; return ret; &#125;private: stack&lt;TreeNode*&gt; stc;&#125;; Java123456789101112131415161718192021222324252627282930313233343536/** * Definition for binary tree * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class BSTIterator &#123; public BSTIterator(TreeNode root) &#123; for ( ; root != null; root = root.left) &#123; stc.push(root); &#125; &#125; /** @return whether we have a next smallest number */ public boolean hasNext() &#123; return !stc.empty(); &#125; /** @return the next smallest number */ public int next() &#123; int ret = stc.peek().val; TreeNode cursor = stc.peek().right; stc.pop(); for ( ; cursor != null; cursor = cursor.left) &#123; stc.push(cursor); &#125; return ret; &#125; private Stack&lt;TreeNode&gt; stc = new Stack&lt;&gt;();&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F11%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy Generate and Deploy1$ hexo g -d More info: Deployment Test Insert Image:]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
